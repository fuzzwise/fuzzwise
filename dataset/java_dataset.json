[
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02916",
        "code_tokens": "import java.util.*;\npublic class Main{\n  public static void main(String[]args){\n      Scanner sc = new Scanner(System.in);\n      int n = sc.nextInt();\n      int[] adata = new int[n];\n      int[] bdata = new int[n];\n      int[] cdata = new int[n-1];\n      int sum = 0;\n      for (int i =0 ;i<n ;i++ ) {\n        adata[i] = sc.nextInt();\n      }\n      for (int i =0 ;i<n ;i++ ) {\n        bdata[i] = sc.nextInt();\n      }\n      for (int i =0 ;i<n-1 ;i++ ) {\n        cdata[i] = sc.nextInt();\n      }\n      for (int i =0 ;i<n ;i++ ) {\n        sum = sum + bdata[i];\n      }\n      if (n>3) {\n        for (int i =0 ;i<n-1 ;i++ ) {\n          if (adata[i]==adata[i+1]-1) {\n            sum = sum + cdata[i+1];\n          }\n        }\n      }else if(n==2){\n        for (int i =0 ;i<n-1 ;i++ ) {\n          if (adata[i]==adata[i+1]-1) {\n            sum = sum + cdata[i];\n          }\n        }\n      }else{\n        for (int i =0 ;i<n-1 ;i++ ) {\n          if (adata[i]==adata[i+1]-1) {\n            sum = sum + cdata[i-1];\n          }\n        }\n      }\n      System.out.println(sum);\n}\n}",
        "submission_id": "s006308236",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 43,
        "cyclomatic_complexity": 13,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03219",
        "code_tokens": "import java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\npublic class Main {\n    private static final long MOD = 1_000_000_007;\n    private static int nextUnitAmida(int x) {\n        int mask1 = 1;\n        int mask2 = 3;\n        ++x;\n        for (;;) {\n            int ck = x & mask2;\n            if (ck == mask1) {\n                break;\n            } else if (ck == mask2) {\n                x += mask1;\n            } else {\n                ;\n            }\n            mask1 <<= 1;\n            mask2 <<= 1;\n        }\n        return x;\n    }\n    private static int[] createUnitAmida(int w) {\n        List<Integer> uAmidas = new ArrayList<>();\n        int x = 0;\n        int limit = (1 << (w - 1));\n        do {\n            uAmidas.add(x);\n            x = nextUnitAmida(x);\n        } while (x < limit);\n        int[] result = new int[uAmidas.size()];\n        for (int i = 0; i < result.length; ++i) {\n            result[i] = uAmidas.get(i);\n        }\n        return result;\n    }\n    private final int height;\n    private final int width;\n    private final int[] unitAmidas;\n    private Main(int h, int w) {\n        height = h;\n        width = w;\n        unitAmidas = createUnitAmida(w);\n    }\n    private long countIt(int h, int start, int goal) {\n        if (h == 0) {\n            return (start == goal ? 1 : 0);\n        } else if (Math.abs(start - goal) > h) {\n            return 0;\n        }\n        final int rMask = (1 << (start - 1));\n        final int lMask = (rMask >> 1);\n        int rCase = 0;\n        int lCase = 0;\n        int mCase = 0;\n        for (int unitAmida : unitAmidas) {\n            if ((unitAmida & rMask) != 0) {\n                ++rCase;\n            } else if ((unitAmida & lMask) != 0) {\n                ++lCase;\n            } else {\n                ++mCase;\n            }\n        }\n        long result = 0;\n        if (rCase != 0) {\n            result += (countIt(h - 1, start + 1, goal) * rCase);\n        }\n        if (lCase != 0) {\n            result += (countIt(h - 1, start - 1, goal) * lCase);\n        }\n        result += (countIt(h - 1, start, goal) * mCase);\n        return result % MOD;\n    }\n    public static void main(String[] args) {\n        try (\n                Scanner in = new Scanner(System.in);\n                PrintWriter out = new PrintWriter(System.out))\n        {\n            final int H = in.nextInt();\n            final int W = in.nextInt();\n            final int K = in.nextInt();\n            long result = new Main(H, W).countIt(H, 1, K);\n            out.println(result);\n        }\n    }\n}",
        "submission_id": "s012056345",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 89,
        "cyclomatic_complexity": 18,
        "branch_factor": 13
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03404",
        "code_tokens": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int a = sc.nextInt();\n    int b = sc.nextInt();\n    System.out.println(100 + \" \" + 100);\n    String[][] grid = new String[100][100];\n    for(int i = 0; i < 100; i++) {\n      for(int j = 0; j < 100; j++) {\n        if(i < 50) {\n          grid[i][j] = \"*\";\n        } else {\n          grid[i][j] = \".\";\n        }\n      }\n    }\n    a--;\n    b--;\n    for(int i = 0; i < 50; i++) {\n      for(int j = 0; j < 100; j++) {\n        if(a == 0) break;\n        if((i % 2 == 0) && (j % 2 == 0)) {\n          grid[i][j] = \".\";\n          a--;\n        }\n      }\n    }\n    for(int i = 99; i > 50; i--) {\n      for(int j = 0; j < 100; j++) {\n        if(b == 0) break;\n        if((i % 2 == 1) && (j % 2 == 0)) {\n          grid[i][j] = \"*\";\n          b--;\n        }\n      }\n    }\n    for(int i = 0; i < 100; i++) {\n      for(int j = 0; j < 100; j++) {\n        System.out.print(grid[i][j]);\n      }\n      System.out.println();\n    }\n  }\n}",
        "submission_id": "s016834584",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 46,
        "cyclomatic_complexity": 16,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02936",
        "code_tokens": "import java.util.*;\npublic class Main{\n    static int[][] d;\n    static int N;\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        N = sc.nextInt();\n        int Q = sc.nextInt();\n        int[][] a = new int[2][N-1];\n        int[][] p = new int[2][Q];\n        d = new int[N][N];\n        for(int i = 0; i < N-1; i++){\n            a[0][i] = sc.nextInt();\n            a[1][i] = sc.nextInt();\n            d[a[0][i]-1][a[1][i]-1] = 1;\n        }\n        for(int i = 0; i < Q; i++){\n            p[0][i] = sc.nextInt();\n            p[1][i] = sc.nextInt();\n        }\n        sc.close();\n        int[] count = new int[N];\n        Arrays.fill(count, 0);\n        for(int i = 0; i < N; i++){\n            d[i][i] = 1;\n        }\n        dps(0, 0);\n        for(int i = 0; i < Q; i++){\n            for(int j = 0; j < N; j++){\n                count[j] += p[1][i] * d[p[0][i]-1][j];\n            }\n        }\n        for(int i = 0; i < N; i++)\n            System.out.println(count[i]);\n    }\n    static void dps(int now, int before){\n        if(now != 0){\n            for(int i = now+1; i < N; i++){\n                if(d[now][i] == 1){\n                    d[before][i] = 1;\n                }\n            }\n        }\n        for(int i = now+1; i < N; i++){\n            if(d[now][i] == 1){\n                dps(i, now);\n            }\n        }\n    }\n}",
        "submission_id": "s033994695",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 50,
        "cyclomatic_complexity": 13,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03361",
        "code_tokens": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tString[] s = new String[h];\n\t\tchar[][] c = new char[h+2][w+2];\n\t\tArrays.fill(c, '.');\n\t\tfor(int i=0; i<h; i++){\n\t\t\ts[i] = sc.next();\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tc[i+1][j+1] = s[i].charAt(j);\n\t\t\t}\n\t\t}\n\t\tboolean bl = true;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tif(c[i][j]=='.')break;\n\t\t\t\telse {\n\t\t\t\t\tif(c[i-1][j]!='#' && c[i+1][j]!='#' && c[i][j-1]!='#' && c[i][j+1]!='#'){\n\t\t\t\t\t\tbl=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(bl==true? \"Yes\" : \"No\");\n\t}\n}",
        "submission_id": "s038351727",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 30,
        "cyclomatic_complexity": 11,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02803",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\npublic class Main {\n\tstatic int[] around = { -1, 0, 1, 0, -1, 1, 1, -1, -1 };\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString W = in.readLine();\n\t\tint HI = Integer.parseInt(W.split(\" \")[0])+2;\n\t\tint WI = Integer.parseInt(W.split(\" \")[1])+2;\n\t\tboolean[][] S = new boolean[HI][WI] ;\n\t\tfor(int i=0;i<S.length;i++){\n\t\t\tArrays.fill(S[i], false);\n\t\t}\n\t\tfor(int i=0;i<S.length-2;i++){\n\t\t\tW = in.readLine();\n\t\t\tfor(int k=0;k<W.length();k++){\n\t\t\t\tif('.' == W.charAt(k)){\n\t\t\t\t\tS[i+1][k+1] = true;\n\t\t\t\t}else{\n\t\t\t\t\tS[i+1][k+1] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tfor(int w=0;w<S.length;w++){\n\t\t\tfor(int h=0;h<S[0].length;h++){\n\t\t\t\tif(!S[w][h]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean[][] tmpS = new boolean[HI][WI] ;\n\t\t\t\tfor(int i=0;i<S.length;i++){\n\t\t\t\t\ttmpS[i] = Arrays.copyOf(S[i], S[i].length);\n\t\t\t\t}\n\t\t\t \tans = Math.max(BWS(w, h,tmpS),ans);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tpublic static int BWS(int w , int h,boolean[][] S){\n\t\tint len = 0;\n\t\tArrayList<int[]> queue = new ArrayList<int[]>();\n\t\tint[] p = {w,h};\n\t\tqueue.add(p);\n\t\tS[p[0]][p[1]]=false;\n\t\twhile(queue.size()!=0){\n\t\t\tArrayList<int[]> queue2 = new ArrayList<int[]>();\n\t\t\twhile(queue.size()!=0){\n\t\t\t\tp = queue.get(0);\n\t\t\t\tqueue.remove(0);\n\t\t\t\tfor(int i=0;i<5;i++){\n\t\t\t\t\tint[] aftP = {around[i],around[i+1]};\n\t\t\t\t\tif(S[aftP[0]][aftP[1]]){\n\t\t\t\t\t\tS[aftP[0]][aftP[1]]=false;\n\t\t\t\t\t\tqueue2.add(aftP);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(queue2.size()!=0){\n\t\t\t\tlen++;\n\t\t\t\tqueue=queue2;\n\t\t\t}\n\t\tprint(S);\n\t\t}\n\t\treturn len;\n\t}\n\tpublic static void print(boolean[][] S){\n\t\tfor(int i=0;i<S.length;i++){\n\t\t\tfor(int k=0;k<S[0].length;k++){\n\t\t\t\tif(S[i][k]){\n\t\t\t\t\tSystem.out.print(\". \");\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.print(\"# \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t}\n}",
        "submission_id": "s040465262",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 80,
        "cyclomatic_complexity": 19,
        "branch_factor": 16
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02265",
        "code_tokens": "import java.io.*;\nimport java.util.*;\nclass Node {\n\tint key;\n\tNode next;\n\tNode prev;\n\tNode( int key )\n\t{\n\t\tthis.key = key;\n\t\tthis.next = null;\n\t\tthis.prev = null;\n\t}\n}\nclass DLL {\n\tint size;\n\tNode head;\n\tNode tail;\n\tDLL( )\n\t{\n\t\thead = null;\n\t\ttail = null;\n\t\tsize = 0;\n\t}\n\tpublic void add( int key )\n\t{\n\t\tNode node = new Node( key );\n\t\tif( null == head ) {\n\t\t\ttail = head = node;\n\t\t} else {\n\t\t\thead.prev = node;\n\t\t\tnode.next = head;\n\t\t\thead = node;\n\t\t\tsize++;\n\t\t}\n\t\treturn;\n\t}\n\tpublic void delete( int key )\n\t{\n\t\tNode node = head;\n\t\tNode pre = null;\n\t\tboolean found = false;\n        while( null != node ) {\n        \tif( key == node.key ) {\n        \t\tnode = node.next;\n        \t\tpre.next = node;\n        \t\tif( null != node ) {\n        \t\t\tnode.prev = pre;\n        \t\t} else {\n        \t\t\ttail = pre;\n        \t\t}\n        \t\tfound = true;\n        \t\tsize--;\n        \t\tbreak;\n        \t}\n        \tpre = node;\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn;\n\t}\n\tpublic void deleteFirst( )\n\t{\n\t\thead = head.next;\n\t\tif( null != head ) {\n\t\t\thead.prev = null;\n\t\t} else {\n\t\t\ttail = head;\n\t\t}\n\t\tsize--;\n\t\treturn;\n\t}\n\tpublic void deleteLast( )\n\t{\n\t\ttail = tail.prev;\n\t\ttail.next = null;\n\t\tsize--;\n\t\treturn;\n\t}\n}\nclass Main {\n    public static void main(String[] args) {\n        BufferedReader kb = new BufferedReader( new InputStreamReader( System.in ) );\n        try {\n\t\t\tint n = Integer.parseInt( kb.readLine() );\n\t\t\tString[] str;\n\t\t\tDLL list = new DLL( );\n            for( int i=0; i<n; i++ ) {\n                str = kb.readLine().split( \" \" );\n                if( \"insert\".equals( str[0] ) ) {\n                \tlist.add( Integer.parseInt( str[1] ) );\n                } else if( \"deleteFirst\".equals( str[0] ) ) {\n                \tlist.deleteFirst( );\n                } else if( \"deleteLast\".equals( str[0] ) ) {\n                \tlist.deleteLast( );\n                } else {\n                \tlist.delete( Integer.parseInt( str[1] ) );\n                }\n            }\n\t\t\tStringBuilder output = new  StringBuilder( );\n\t\t\tNode node = list.head;\n            while(  null != node ) {\n\t\t\t\toutput.append( node.key ).append( \" \" );\n\t\t\t\tnode = node.next;\n \t\t\t}\n \t\t\toutput.deleteCharAt( output.lastIndexOf( \" \" ) );\n\t\t\tSystem.out.println( output );\n\t    } catch( IOException e ) {\n\t        System.err.println( e );\n\t    }\n\t}\n}",
        "submission_id": "s041134738",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 110,
        "cyclomatic_complexity": 18,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00047",
        "code_tokens": "import java.util.Scanner;\nimport java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) throws java.io.IOException {\n\t\tScanner scan = new Scanner(System.in);\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tint a = 1;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\twhile(scan.hasNext()){\n\t\t\tString k = br.readLine();\n\t\t\tString[] f = k.split(\",\", -1);\n\t\t\tif(f[0].equals(\"A\")){\n\t\t\t\tif(f[1].equals(\"B\")){\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\ta = 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(a == 1){\n\t\t\t\t\t\ta = 0;\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(f[0].equals(\"B\")){\n\t\t\t\tif(f[1].equals(\"C\")){\n\t\t\t\t\tif(b == 1){\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tc = 1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(b == 1){\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\ta = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(f[1].equals(\"A\")){\n\t\t\t\t\tif(c == 1){\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\ta = 1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(c == 1){\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(a == 1){\n\t\t\tSystem.out.println(\"A\");\n\t\t}else if(b == 1){\n\t\t\tSystem.out.println(\"B\");\n\t\t}else{\n\t\t\tSystem.out.println(\"C\");\n\t\t}\n\t}\n}",
        "submission_id": "s051252507",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 60,
        "cyclomatic_complexity": 15,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p01225",
        "code_tokens": "import java.util.Scanner;\nimport java.util.Arrays;\nclass Main{\n\tpublic static void main(String args[]){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint T = scan.nextInt();\n\t\tint N[][] = new int[T][];\n\t\tchar C[][] = new char[T][];\n\t\tfor(int j=0;j<T;j++){\n\t\t\tN[j] = new int[9];\n\t\t\tC[j] = new char[9];\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tN[j][i] = scan.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\tString str = scan.next();\n\t\t\t\tchar[] inpc = str.toCharArray();\n\t\t\t\tC[j*2][i] = inpc[1];\n\t\t\t}\n\t\t}\n\t\tchar coler[] = {'R','G','B'};\n\t\tfor(int j=0;j<T;j++){\n\t\t\tint a[] = new int[10];\n\t\t\tint count=0;\n\t\t\tint pea=0;\n\t\t\tboolean f = false;\n\t\t\tfor(int cnum=0;cnum<3;cnum++){\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tif(C[j][i] == coler[cnum]){\n\t\t\t\t\t\ta[count]=N[j][i];\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count>2){\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t\tfor(int x=0;a[x+2]==0;x++){\n\t\t\t\t\t\tif((a[x] == a[x+1] && a[x] == a[x+2]) || (a[x] == a[x+1]-1 && a[x] == a[x+2]-2)){\n\t\t\t\t\t\t\tpea++;\n\t\t\t\t\t\t\tx+=2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(pea>=3){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\tSystem.out.println(\"1\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t}\n\t}\n}",
        "submission_id": "s071171854",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 16,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02616",
        "code_tokens": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
        "submission_id": "s109776224",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 51,
        "cyclomatic_complexity": 12,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03417",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.List;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        String[] input = sc.nextLine().split(\" \");\n        int N = Integer.parseInt(input[0]);\n        int M = Integer.parseInt(input[1]);\n        int sum = 0;\n        List<List<Integer>> w = new ArrayList<List<Integer>>(M+2);\n        for(int i = 0; i<=M+1 ; i++){\n            List<Integer> h = new ArrayList<Integer>(N+2);\n            w.add(h);\n            for(int j = 0 ; j<= N+1 ; j++){\n                w.get(i).add(1);\n            }\n        }\n        System.out.println();\n        for(int i = 1; i<=M ; i++){\n            for(int j = 1 ; j<= N ; j++){\n                w.get(i).set(j,0);\n            }\n        }\n        for(int i = 1; i<=M ; i++){\n            for(int j = 1 ; j<= N ; j++){\n                int count = 0;\n                if(w.get(i-1).get(j-1) == 0){\n                    count++;\n                }\n                if(w.get(i-1).get(j) == 0){\n                    count++;\n                }\n                if(w.get(i-1).get(j+1) == 0){\n                    count++;\n                }\n                if(w.get(i).get(j-1) == 0){\n                    count++;\n                }\n                if(w.get(i).get(j) == 0){\n                    count++;\n                }\n                if(w.get(i).get(j+1) == 0){\n                    count++;\n                }\n                if(w.get(i+1).get(j-1) == 0){\n                    count++;\n                }\n                if(w.get(i+1).get(j) == 0){\n                    count++;\n                }\n                if(w.get(i+1).get(j+1) == 0){\n                    count++;\n                }\n                if(count % 2 == 1){\n                    sum ++;\n                }\n            }\n        }\n        System.out.println(sum);\n    }\n}",
        "submission_id": "s110404205",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 62,
        "cyclomatic_complexity": 17,
        "branch_factor": 16
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p01102",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tString[] s = new String[2];\n\t\twhile(true)\n\t\t{\n\t\t\ts[0] = scan.next();\n\t\t\tif(s[0].equals(\".\")) {break;}\n\t\t\ts[1] = scan.next();\n\t\t\tList<String> ss1 = new ArrayList<String>();\n\t\t\tList<Integer> location = new ArrayList<Integer>();\n\t\t\tint miniCounter = -1;\n\t\t\tint stringDifferences = 0;\n\t\t\tint numOfSs2 = 0;\n\t\t\tboolean done = false;\n\t\t\tfor(int c = 0; c <= 1; c++)\n\t\t\t{\n\t\t\t\tint zure = 0;\n\t\t\t\tint start = -1;\n\t\t\t\tint end = 0;\n\t\t\t\tfor(int i = 0; i < s[c].length(); i++)\n\t\t\t\t{\n\t\t\t\t\tif(c == 1)\n\t\t\t\t\t{\n\t\t\t\t\t}\n\t\t\t\t\tString cur = s[c].substring(i, i+1);\n\t\t\t\t\tif(cur.equals(\"\\\"\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(start == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstart = i+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tend = i-1;\n\t\t\t\t\t\t\tif(c == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlocation.add(i);\n\t\t\t\t\t\t\t\tss1.add(s[c].substring(start, end+1));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(c == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnumOfSs2 += 1;\n\t\t\t\t\t\t\t\tminiCounter += 1;\n\t\t\t\t\t\t\t\tString thisOne = s[c].substring(start, end+1);\n\t\t\t\t\t\t\t\tString prevOne = ss1.get(miniCounter);\n\t\t\t\t\t\t\t\tif(!thisOne.equals(prevOne))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tstringDifferences += 1;\n\t\t\t\t\t\t\t\t\tif(stringDifferences >= 2)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(\"DIFFERENT\");\n\t\t\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tzure = prevOne.length() - thisOne.length();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstart = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(start == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(c == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString cur1 = s[0].substring(i+zure, i+1+zure);\n\t\t\t\t\t\t\t\tString cur2 = s[1].substring(i, i+1);\n\t\t\t\t\t\t\t\tif(!cur1.equals(cur2))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSystem.out.println(\"DIFFERENT\");\n\t\t\t\t\t\t\t\t\tdone = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!done)\n\t\t\t{\n\t\t\t\tif(numOfSs2 == ss1.size())\n\t\t\t\t{\n\t\t\t\t\tif(stringDifferences == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"CLOSE\");\n\t\t\t\t\t}\n\t\t\t\t\telse if(stringDifferences == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.out.println(\"IDENTICAL\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(\"DIFFERENT\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
        "submission_id": "s115766934",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 108,
        "cyclomatic_complexity": 19,
        "branch_factor": 18
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02814",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    long m = sc.nextLong();\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextLong();\n    }\n    Main abc150D = new Main();\n    System.out.println(abc150D.solve(m, a));\n  }\n  public Long solve(long m, long[] a) {\n    long multi = 1L;\n    for (int i = 0; i < a.length; i++) {\n      multi = lcm(multi, a[i] / 2);\n    }\n    for (int i = 0; i < a.length; i++) {\n      if (multi % a[i] == 0) {\n        return 0L;\n      }\n    }\n    long ret = 0L;\n    for (int i = 1; i <= m / multi; i++) {\n      if (i % 2 == 1) {\n        ret += 1L;\n      }\n    }\n    return ret;\n  }\n  private long lcm(long a, long b) {\n    if(b > a) {\n      return lcm(b, a);\n    }\n    return a / gcd(a, b) * b;\n  }\n  private long gcd(long a, long b) {\n    if (b > a) {\n      return gcd(b, a);\n    }\n    if (a == b) {\n      return a;\n    } else if (b == 0) {\n      return a > 0 ? a : 1;\n    } else {\n      return gcd(b, a % b);\n    }\n  }\n  private long multiplue(long a, long b) {\n    long ret = a > b ? a : b;\n    long unit = a > b ? a : b;\n    long base = a > b ? b : a;\n    while (ret % base != 0) {\n      ret += unit;\n    }\n    return ret;\n  }\n}",
        "submission_id": "s128643627",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 59,
        "cyclomatic_complexity": 20,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00990",
        "code_tokens": "package aoj_1500_id;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.LinkedList;\npublic class Main {\n\tprivate static int calcCompareNum(int sum, int lack, int[] list) {\n\t\tint combiNum=(int)Math.pow(list.length, lack);\n\t\tint[] sums=new int[combiNum];\n\t\tArrays.fill(sums, 0);\n\t\tint t=1;\n\t\tint base=list.length;\n\t\tfor(int i=lack-1; i>=0; i--) {\n\t\t\tfor(int j=0; j<sums.length; j++) {\n\t\t\t\tint temp=j/t;\n\t\t\t\tsums[j]+=list[temp%base];\n\t\t\t}\n\t\t\tt*=base;\n\t\t}\n\t\tint count=0;\n\t\tfor(int i=0; i<sums.length; i++)\n\t\t\tif(sum==sums[i]%10)\n\t\t\t\tcount++;\n\t\treturn count;\n\t}\n\tprivate static int bai(int val) {\n\t\treturn val>5?(val-4)*2-1:2*val;\n\t}\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tint n;\n\t\tint lackOdd=0, lackEven=0, sum=0;\n\t\tint m;\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tn=Integer.parseInt(br.readLine());\n\t\tchar[] charArray=br.readLine().toCharArray();\n\t\tfor(int i=charArray.length-1; i>=0; i--) {\n\t\t\tif(charArray[i]=='*')\n\t\t\t\tif((i-charArray.length+1)%2==0)\n\t\t\t\t\tlackOdd++;\n\t\t\telse\n\t\t\t\tlackEven++;\n\t\telse\n\t\t\tsum+= i%2==0?Integer.parseInt(charArray[i]+\"\"):bai(Integer.parseInt(charArray[i]+\"\"));\n\t\t}\n\t\tm=Integer.parseInt(br.readLine());\n\t\tString line=br.readLine();\n\t\tString[] strArray=line.split(\" \");\n\t\tLinkedList<Integer> tempCandidate=new LinkedList<Integer>();\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tint tempNum=Integer.parseInt(strArray[i]);\n\t\t\ttempCandidate.add(tempNum);\n\t\t}\n\t\tbr.close();\n\t\tint num=10-sum%10;\n\t\tnum%=10;\n\t\tint[] evenList=new int[tempCandidate.size()];\n\t\tint count=0;\n\t\tfor(int val: tempCandidate)\n\t\t\tevenList[count++]=bai(val);\n\t\tint[] oddList=new int[tempCandidate.size()];\n\t\tcount=0;\n\t\tfor(int val: tempCandidate)\n\t\t\toddList[count++]=val;\n\t\tcount=0;\n\t\tfor(int i=0; i<10; i++) {\n\t\t\tint j=i<=num?(num-i):(num-i+10);\n\t\t\tint c1=calcCompareNum(i, lackEven, evenList);\n\t\t\tint c2=calcCompareNum(j, lackOdd, oddList);\n\t\t\tcount+=c1*c2;\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}",
        "submission_id": "s134442063",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 74,
        "cyclomatic_complexity": 17,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02760",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] array = new int[3][3];\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\tarray[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tint N = sc.nextInt();\n\t\tboolean[][] ansArray = new boolean[3][3];\n\t\tfor (int h = 0; h < N; h++) {\n\t\t\tint number = sc.nextInt();\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tansArray[i][j] = false;\n\t\t\t\t\tif (array[i][j] == number) {\n\t\t\t\t\t\tansArray[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\t\tboolean flag = false;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (ansArray[i][0] && ansArray[i][1] && ansArray[i][2]) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tif (ansArray[0][i] && ansArray[1][i] && ansArray[2][i]) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\tif (ansArray[0][3] && ansArray[1][1] && ansArray[3][0]) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\tif(flag) {\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}else {\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n}",
        "submission_id": "s135259997",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 45,
        "cyclomatic_complexity": 19,
        "branch_factor": 18
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02411",
        "code_tokens": "import java.util.Scanner;\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tint m, f, r;\n\t\tScanner stdIn = new Scanner(System.in);\n\t\tboolean flag = true;\n\t\twhile (flag) {\n\t\t\tm = stdIn.nextInt();\n\t\t\tf = stdIn.nextInt();\n\t\t\tr = stdIn.nextInt();\n\t\t\tif (m == -1 || f == -1 && r != -1) {\n\t\t\t\tSystem.out.println(\"F\");\n\t\t\t} else if (m + f >= 80) {\n\t\t\t\tSystem.out.println(\"A\");\n\t\t\t} else if (m + f >= 65) {\n\t\t\t\tSystem.out.println(\"B\");\n\t\t\t} else if (m + f >= 50) {\n\t\t\t\tSystem.out.println(\"C\");\n\t\t\t} else if (m + f >= 30 || r >= 50) {\n\t\t\t\tSystem.out.println(\"D\");\n\t\t\t} else if (m + f + r <= -3) {\n\t\t\t\tflag = false;\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"F\");\n\t\t\t}\n\t\t}\n\t}\n}",
        "submission_id": "s159736783",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 28,
        "cyclomatic_complexity": 11,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03998",
        "code_tokens": "import java.util.*;\npublic class Main{\n    public static void main(String args[]){\n        Scanner sc = new Scanner(System.in);\n        String Sa = sc.next();\n        String Sb = sc.next();\n        String Sc = sc.next();\n        sc.close();\n        int numA = Sa.length();\n        int numB = Sb.length();\n        int numC = Sc.length();\n        int countA = 0;\n        int countB = 0;\n        int countC = 0;\n        char turn = 'a';\n        while(true){\n            if(turn == 'a'){\n                turn = Sa.charAt(countA);\n                countA++;\n            }\n            if(turn == 'b'){\n                turn = Sb.charAt(countB);\n                countB++;\n            }\n            if(turn == 'c'){\n                turn = Sc.charAt(countC);\n                countC++;\n            }\n            if(countA == numA && turn == 'a'){\n                System.out.println('A');\n                break;\n            }\n            if(countB == numB && turn == 'b'){\n                System.out.println('B');\n                break;\n            }\n            if(countC == numC && turn == 'c'){\n                System.out.println('C');\n                break;\n            }\n        }\n    }\n}",
        "submission_id": "s187209127",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 43,
        "cyclomatic_complexity": 11,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p01225",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Main {\n\tpublic static void main(String[] args)throws Exception{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n        BufferedReader br = new BufferedReader(isr);\n        int n = Integer.parseInt(br.readLine());\n        for (int i = 0; i < n; i++)\n        {\n        \tString[] sinput = br.readLine().split(\" \");\n        \tString[] color = br.readLine().split(\" \");\n        \tint[][] card = new int[3][9];\n        \tfor (int j = 0; j < 9; j++)\n        \t{\n        \t\tint suji = Integer.parseInt(sinput[j]) - 1;\n        \t\tif (color[j].equals(\"R\"))\n        \t\t\tcard[0][suji]++;\n        \t\telse if (color[j].equals(\"G\"))\n        \t\t\tcard[1][suji]++;\n        \t\telse if (color[j].equals(\"B\"))\n        \t\t\tcard[2][suji]++;\n        \t}\n        \tint win = 0;\n        \tfor (int j = 0; j < 3; j++)\n        \t{\n        \t\tfor (int k = 0; k < 9; k++)\n        \t\t{\n        \t\t\tif (card[j][k] > 0 && card[j][k + 1] > 0 && card[j][k + 2] > 0)\n            \t\t{\n            \t\t\twin++;\n            \t\t\tcard[j][k]--;\n            \t\t\tcard[j][k + 1]--;\n            \t\t\tcard[j][k + 2]--;\n            \t\t\tk--;\n            \t\t\tcontinue;\n            \t\t}\n        \t\t\telse if (card[j][k] >= 3)\n        \t\t\t{\n        \t\t\t\twin++;\n            \t\t\tcard[j][k] -= 3;\n            \t\t\tk--;\n        \t\t\t}\n        \t\t}\n        \t}\n        \tif (win >= 3)\n        \t\tSystem.out.println(1);\n        \telse\n        \t\tSystem.out.println(0);\n        }\n\t}\n}",
        "submission_id": "s199459677",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 51,
        "cyclomatic_complexity": 13,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02616",
        "code_tokens": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
        "submission_id": "s211375304",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 67,
        "cyclomatic_complexity": 18,
        "branch_factor": 17
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00884",
        "code_tokens": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString firstGroup = \"\";\n\t\t\tMap<String, ArrayList<String>> groups = new HashMap<String, ArrayList<String>>();\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tString group = line.split(\":\")[0];\n\t\t\t\tif (z == 0) {\n\t\t\t\t\tfirstGroup = group;\n\t\t\t\t}\n\t\t\t\tgroups.put(group, new ArrayList<String>());\n\t\t\t\tString[] members = line.split(\":\")[1].split(\",\");\n\t\t\t\tfor (int i = 0; i < members.length; i++) {\n\t\t\t\t\tgroups.get(group).add(\n\t\t\t\t\t\t\tmembers[i].trim().replaceAll(\"\\\\.\", \"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrayList<String> ansList = new ArrayList<String>();\n\t\t\tDeque<String> deque = new ArrayDeque<String>();\n\t\t\tdeque.add(firstGroup);\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tString person = deque.poll();\n\t\t\t\tif (groups.get(person) == null && !ansList.contains(person)) {\n\t\t\t\t\tansList.add(person);\n\t\t\t\t} else if (groups.get(person) != null) {\n\t\t\t\t\tfor (String child : groups.get(person)) {\n\t\t\t\t\t\tdeque.add(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ansList.size());\n\t\t}\n\t}\n}",
        "submission_id": "s267475420",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 47,
        "cyclomatic_complexity": 11,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02783",
        "code_tokens": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FSilverFoxVsMonster solver = new FSilverFoxVsMonster();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class FSilverFoxVsMonster {\n        public int llt(ArrayList<Long> a, int l, int r, int x) {\n            int temp = r;\n            int mid = (l + r) / 2;\n            if (a.get(mid) >= x) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n            while (l >= temp) l--;\n            while (l > 0 && a.get(l) > x) l--;\n            return l;\n        }\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int D = in.nextInt();\n            int A = in.nextInt();\n            ArrayList<node> a = new ArrayList<node>();\n            for (int i = 0; i < n; i++) {\n                a.add(new node(in.nextInt(), in.nextInt()));\n            }\n            Collections.sort(a, new Comparator<node>() {\n                public int compare(node o1, node o2) {\n                    return o1.x - o2.x;\n                }\n            });\n            long pre[] = new long[n + 1];\n            ArrayList<Long> d = new ArrayList<>();\n            d.add(-1L);\n            int c = 0;\n            c++;\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                int x = a.get(i).x;\n                int y = a.get(i).x - 2 * D;\n                if (y < 0) y = 0;\n                y--;\n                int q = llt(d, 0, c, y);\n                long t = pre[c - 1] - pre[q];\n                a.get(i).y = a.get(i).y - t > 0 ? a.get(i).y - t : 0;\n                long an = (long) Math.ceil((float) a.get(i).y / A);\n                ans += an;\n                pre[c] = pre[c - 1] + an * A;\n                d.add((long) a.get(i).x);\n                c++;\n            }\n            out.println(ans);\n        }\n        class node {\n            int x;\n            long y;\n            node(int x, int y) {\n                this.x = x;\n                this.y = y;\n            }\n        }\n    }\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}",
        "submission_id": "s272417402",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 101,
        "cyclomatic_complexity": 18,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03599",
        "code_tokens": "import java.util.*;\nclass Main {\n    void solve(){\n        Scanner in = new Scanner(System.in);\n        int A = in.nextInt() * 100, B = in.nextInt() * 100, C = in.nextInt(),\n            D = in.nextInt(), E = in.nextInt(), F = in.nextInt();\n        int wMax = (int)((double)F / (100 + E) * 100);\n        int[] dp1 = new int[wMax + 2];\n        for(int i = 0; i < dp1.length; i++){\n            if(i - A >= 0){\n                dp1[i] = Math.max(dp1[i], dp1[i - A] + A);\n            }else{\n                dp1[i] = dp1[i - 1];\n            }\n            if(i - B >= 0){\n                dp1[i] = Math.max(dp1[i], dp1[i - B] + B);\n            }else{\n                dp1[i] = dp1[i - 1];\n            }\n        }\n        int[] dp2 = new int[wMax + 2];\n        for(int i = 0; i < dp2.length; i++){\n            if(i - C >= 0 && dp1[i] != 0){\n                int a = dp2[i - C] + C;\n                if(100 * a <= E * dp1[i]){\n                    dp2[i] = Math.max(dp2[i], dp2[i - C] + C);\n                }else{\n                    dp2[i] = dp2[i - 1];\n                }\n            }\n            if(i - D >= 0 && dp1[i] != 0){\n                int a = dp2[i - D] + D;\n                if(100 * a <= E * dp1[i]){\n                    dp2[i] = Math.max(dp2[i], dp2[i - D] + D);\n                }else{\n                    dp2[i] = dp2[i - 1];\n                }\n            }\n        }\n        int w = A, s = 0;\n        for(int i = 0; i < dp1.length; i++){\n            if(dp1[i] > 0 && w * dp2[i] > s * dp1[i] && dp1[i] + dp2[i] <= F){\n                w = dp1[i];\n                s = dp2[i];\n            }\n        }\n        System.out.println(w+s + \" \" + s);\n    }\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n}",
        "submission_id": "s288353982",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 52,
        "cyclomatic_complexity": 16,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03274",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\npublic class Main\n{\n    public static void main(String[] args)\n    {\n        final Scanner sc = new Scanner(System.in);\n        final int N = sc.nextInt();\n        final int K = sc.nextInt();\n        final List<Long> posiArray = new ArrayList<Long>();\n        final List<Long> negaArray = new ArrayList<Long>();\n        long input;\n        int count = 0;\n        for (int i = 0; i < N; i++)\n        {\n            input = sc.nextInt();\n            if (input < 0)\n            {\n                negaArray.add(input);\n            } else if (input > 0)\n            {\n                posiArray.add(input);\n            } else\n            {\n                count++;\n            }\n        }\n        int posiIndex = 0;\n        int negaIndex = negaArray.size() - 1;\n        long distance = 0;\n        for (int i = 0; i < N; i++)\n        {\n            if (posiArray.size() == 0 && negaArray.size() == 0)\n            {\n                distance = 0;\n                break;\n            } else if (posiArray.size() == 0)\n            {\n                distance = -negaArray.get(K - 1);\n                break;\n            } else if (negaArray.size() == 0)\n            {\n                distance = posiArray.get(K - 1);\n                break;\n            } else if (posiIndex < posiArray.size() && posiArray.get(posiIndex) < -2 * negaArray.get(negaIndex))\n            {\n                posiIndex++;\n            } else\n            {\n                negaIndex--;\n            }\n            count++;\n            if (count == K)\n            {\n                final long posiDis = posiArray.get(posiIndex - 1);\n                final long negaDis = negaArray.get(negaIndex + 1);\n                if (posiDis - 2 * negaDis > 2 * posiDis - negaDis)\n                {\n                    distance = 2 * posiDis - negaDis;\n                } else\n                {\n                    distance = posiDis - 2 * negaDis;\n                }\n                break;\n            }\n        }\n        System.out.println(distance);\n    }\n}",
        "submission_id": "s304518563",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 70,
        "cyclomatic_complexity": 13,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00109",
        "code_tokens": "import java.util.*;\nclass Main{\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0){\n            String line = sc.next();\n            int ans = calc(line.substring(0,line.length()-1));\n            System.out.println(ans);\n        }\n    }\n    int calc(String line){\n        String newLine = \"\";\n        for(int i=0; i<line.length(); i++){\n            if(line.charAt(i)=='('){\n                int idx = i;\n                int left = 1;\n                int right = 0;\n                while(right!=left){\n                    idx++;\n                    if(line.charAt(idx)==')'){\n                        right++;\n                    }else if(line.charAt(idx)=='('){\n                        left++;\n                    }\n                }\n                newLine += calc(line.substring(i+1,idx));\n                i = idx;\n            }else newLine += line.charAt(i);\n        }\n        ArrayList<Integer> list = new ArrayList<Integer>();\n        ArrayList<Character> list2 = new ArrayList<Character>();\n        String tmp = \"\";\n        for(int i=0; i<newLine.length(); i++){\n            char c = newLine.charAt(i);\n            if(c=='*' || c=='/' || c=='+' || c=='-'){\n                list.add(Integer.parseInt(tmp));\n                tmp = \"\";\n                list2.add(c);\n            }else{\n                tmp += c;\n            }\n        }\n        list.add(Integer.parseInt(tmp));\n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='*' || c=='/'){\n                int n1 = list.get(i);\n                int n2 = list.get(i+1);\n                if(c=='*'){\n                    list.set(i, n1*n2);\n                }else{\n                    list.set(i, n1/n2);\n                }\n                list.remove(i+1);\n                list2.remove(i);\n                i--;\n            }\n        }\n        int ans = list.get(0);\n        for(int i=0; i<list2.size(); i++){\n            char c = list2.get(i);\n            if(c=='+'){\n                ans += list.get(i+1);\n            }else{\n                ans -= list.get(i+1);\n            }\n        }\n        return ans;\n    }\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}",
        "submission_id": "s308432740",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 74,
        "cyclomatic_complexity": 20,
        "branch_factor": 17
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02279",
        "code_tokens": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nclass Node {\n    Node parent;\n    Node[] child;\n    int number;\n    String type;\n    int depth;\n    Node(int number) {\n        this.number = number;\n        this.parent = null;\n        this.type = \"new\";\n    }\n    void setDepth(int dep) {\n        this.depth = dep;\n        if (!this.type.equals(\"leaf\")) {\n            for (Node x : this.child) {\n                x.setDepth(dep + 1);\n            }\n        }\n    }\n}\nclass Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        Node[] tree = new Node[n];\n        for (int i = 0; i < n; i++) {\n            tree[i] = new Node(i);\n        }\n        for (int i = 0; i < n; i++) {\n            String[] input = br.readLine().split(\" \");\n            int number = Integer.parseInt(input[0]);\n            int k = Integer.parseInt(input[1]);\n            if (k == 0) {\n                tree[number].type = \"leaf\";\n                continue;\n            } else {\n                tree[number].child = new Node[k];\n                tree[number].type = \"internal node\"; \n            }\n            for (int j = 0; j < k; j++) {\n                tree[number].child[j] = tree[Integer.parseInt(input[2 + j])];\n                tree[Integer.parseInt(input[2 + j])].parent = tree[number];\n            }\n        }\n        Node root = tree[0];\n        while (root.parent != null) {\n            root = root.parent;\n        }\n        root.type = \"root\";\n        root.setDepth(0);\n        int rootNum = root.number;\n        String format = \"node %d: parent = %d, depth = %d, %s, \";\n        for (int i = 0; i < n; i++) {\n            if (i != rootNum) {\n                System.out.printf(format, i, tree[i].parent.number, tree[i].depth, tree[i].type);\n            } else {\n                System.out.printf(format, i, -1, tree[i].depth, tree[i].type);\n            }\n            System.out.print(\"[\");\n            if (!tree[i].type.equals(\"leaf\")) {\n                int j;\n                for (j = 0; j < tree[i].child.length - 1; j++) {\n                    System.out.printf(tree[i].child[j].number + \", \");\n                }\n                System.out.print(tree[i].child[j].number);\n            }\n            System.out.println(\"]\");\n        }\n    }\n}",
        "submission_id": "s311965693",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 73,
        "cyclomatic_complexity": 14,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03402",
        "code_tokens": "package main;\nimport java.util.Scanner;\nimport java.util.Arrays;\npublic class Main {\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n    void solve() {\n        Scanner sc = new Scanner(System.in);\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int t = 1, y = 1;\n        String S[][] = new String[500][500];\n        for (int i = 0; i < 250; i++) {\n            for (int j = 0; j < 500; j++) {\n                S[i][j] = \"#\";\n            }\n        }\n        for (int i = 250; i < 500; i++) {\n            for (int j = 0; j < 500; j++) {\n                S[i][j] = \".\";\n            }\n        }\n        while (A-- > 0) {\n            S[t][y] = \".\";\n            y += 2;\n            if (y > 500) {\n                t += 2;\n                y = 1;\n            }\n        }\n        t=250;\n        while (B-- > 0) {\n            S[t][y] = \"#\";\n            y += 2;\n            if (y > 500) {\n                t += 2;\n                y = 1;\n            }\n        }\n        for (int i = 0; i < 500; i++) {\n            for (int j = 0; j < 500; j++) {\n                System.out.print(S[i][j]);\n            }\n            System.out.println();\n        }\n    }\n}",
        "submission_id": "s346794332",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 48,
        "cyclomatic_complexity": 12,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02603",
        "code_tokens": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n        int[][] dp = new int[8000+5][80+5];\n        for (int i = 0; i < dp.length; i++ ) {\n            for (int j = 0; j < dp[0].length; j++) {\n                dp[i][j] = -1;\n            }\n        }\n        dp[1000][0] = 0;\n        for (int j = 0; j < dp[0].length; j++ ) {\n            for (int i = 0; i < dp.length; i++) {\n                if (dp[i][j] == -1 || j >= N) continue;\n                int price = A[j];\n                int num = i/price;\n                int remain = i - num*price;\n                if (num > 0) {\n                    dp[remain][j+1] = Math.max(dp[remain][j+1], dp[i][j]+num);\n                }\n                if (dp[i][j] > 0) {\n                    remain = i + dp[i][j]*price;\n                    dp[remain][j+1] = Math.max(dp[remain][j+1], 0);\n                }\n                dp[i][j+1] = Math.max(dp[i][j+1], dp[i][j]);\n            }\n        }\n        int ans = -1;\n        for (int i = 0; i < dp.length; i++) {\n            if (dp[i][N] == -1) continue;\n            ans = i;\n        }\n        System.out.println(ans);\n    }\n}",
        "submission_id": "s390425931",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 40,
        "cyclomatic_complexity": 12,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03921",
        "code_tokens": "import java.util.*;\npublic class Main{\n\tpublic static class Node{\n\t\tArrayList<Integer> to;\n\t\tint p_or_l;\n\t\tNode(){\n\t\t\tto = new ArrayList<Integer>();\n\t\t}\n\t}\n\tstatic Scanner sn = new Scanner(System.in);\n\tstatic int N = sn.nextInt();\n\tstatic int M = sn.nextInt();\n\tstatic Node[] peple = new Node[1002];\n\tstatic Node[] lang = new Node[1002];\n\tstatic boolean[] visit = new boolean[1002];\n\tpublic static void main(String[] args){\t\t\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tpeple[i] = new Node();\n\t\t\tpeple[i].p_or_l = 0;\n\t\t\tvisit[i] = false;\n\t\t}\n\t\tfor(int i = 0;i < M; ++i){\n\t\t\tlang[i] = new Node();\n\t\t\tlang[i].p_or_l = 1;\t\t\n\t\t}\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tint K = sn.nextInt();\n\t\t\tfor(int j = 0; j < K; ++j){\n\t\t\t\tint l = sn.nextInt();\n\t\t\t\tpeple[i].to.add(l-1);\n\t\t\t\tlang[l-1].to.add(i);\n\t\t\t}\n\t\t}\n\t\tvisit[0] = true;\n\t\tsolve(peple[0]);\n\t\tcheck();\n\t}\n\tpublic static void solve(Node p){\n\t\tif(p.to.isEmpty()) return;\n\t\tfor(int i = 0; i < p.to.size(); ++i){\t\t\n\t\t\tint next = p.to.get(i);\t\t\t\n\t\t\tif(p.p_or_l == 0){\t\t\t\t\n\t\t\t\tsolve(lang[next]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(visit[next]) continue;\n\t\t\t\tvisit[next] = true;\n\t\t\t\tsolve(peple[next]);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void check(){\n\t\tboolean flag = true;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tif(!visit[i]){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}  \n\t\t}\n\t\tif(flag) System.out.println(\"YES\");\n\t\telse System.out.println(\"NO\");\n\t}\n}",
        "submission_id": "s402263112",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 63,
        "cyclomatic_complexity": 15,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03105",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N=sc.nextInt();\n\t\tint M=sc.nextInt();\n\t\tint[][] data=new int[M][2];\n\t\tlong[] res=new long[M+1];\n\t\tlong fumando=((long)N)*((long)N-1)/2L;\n\t\tres[0]=fumando;\n\t\tfor(int i=M-1; i>=0; i--) {\n\t\t\tdata[i][0]=sc.nextInt();\n\t\t\tdata[i][1]=sc.nextInt();\n\t\t}\n\t\tUnionFindTree UFT=new UnionFindTree(N);\n\t\tfor(int i=0; i<M; i++) {\n\t\t\tint AR=UFT.find(data[i][0]);\n\t\t\tint BR=UFT.find(data[i][1]);\n\t\t\tlong a=(long)UFT.size(AR);\n\t\t\tlong b=(long)UFT.size(BR);\n\t\t\tUFT.union(data[i][0], data[i][1]);\n\t\t\tif(AR!=BR) {\n\t\t\t\tres[i+1]=res[i]-a*b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres[i+1]=res[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=M-1; i>=0; i--) {\n\t\t\tSystem.out.println(res[i]);\n\t\t}\n\t}\n\tpublic static class UnionFindTree {\n\t\tint nodeNum;\t\n\t\tint [] parent;\t\n\t\tint [] height;\t\n\t\tint [] treeSize;\t\n\t\tpublic UnionFindTree(int nodeNum) {\n\t\t\tthis.nodeNum = nodeNum;\n\t\t\tparent = new int[nodeNum+1];\n\t\t\theight = new int[nodeNum+1];\n\t\t\ttreeSize = new int[nodeNum+1];\n\t\t\tfor (int i = 1; i <= nodeNum; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t\theight[i] = 0;\n\t\t\t\ttreeSize[i] = 1;\n\t\t\t}\n\t\t}\n\t\tint find(int x) {\n\t\t\tif (parent[x] == x) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn parent[x] = find(parent[x]);\n\t\t\t}\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tint rootX = find(x);\n\t\t\tint rootY = find(y);\n\t\t\tif (rootX == rootY) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (height[rootX] < height[rootY]) {\n\t\t\t\tparent[rootX] = rootY;\n\t\t\t\ttreeSize[rootY] += treeSize[rootX];\n\t\t\t} else {\n\t\t\t\tif (height[rootX] == height[rootY]) {\n\t\t\t\t\theight[rootX]++;\n\t\t\t\t}\n\t\t\t\tparent[rootY] = rootX;\n\t\t\t\ttreeSize[rootX] += treeSize[rootY];\n\t\t\t}\n\t\t}\n\t\tint size(int vertex) {\n\t\t\treturn treeSize[vertex];\n\t\t}\n\t}\n}",
        "submission_id": "s405270519",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 14,
        "branch_factor": 9
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02951",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\nclass Main {\n    static int[] primes;\n    static List<Integer> primeList;\n    static {\n        int length = (int) Math.sqrt(500000000) + 1;\n        primes = new int[length];\n        int max = (int) Math.sqrt(length) + 1;\n        for (int i = 2; i < max; i++) {\n            if (primes[i] == 1) {\n                continue;\n            }\n            int cur = i * i;\n            while (cur < length) {\n                primes[cur] = 1;\n                cur += i;\n            }\n        }\n        primeList = new ArrayList<>();\n        for (int i = 2; i < length; i++) {\n            if (primes[i] == 0) {\n                primeList.add(i);\n            }\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int N = in.nextInt();\n        int K = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = in.nextInt();\n        }\n        int sum = 0;\n        for (int a : A) {\n            sum += a;\n        }\n        SortedSet<Integer> factors = new TreeSet<>(Comparator.reverseOrder());\n        List<Integer> tmpPrimes = new ArrayList<>(primeList);\n        while (sum > 1 && tmpPrimes.size() > 0) {\n            if (sum % tmpPrimes.get(0) == 0) {\n                sum /= tmpPrimes.get(0);\n                factors.addAll(factors.stream().map(i -> i*tmpPrimes.get(0)).collect(Collectors.toList()));\n                factors.add(tmpPrimes.get(0));\n            } else {\n                tmpPrimes.remove(0);\n            }\n        }\n        factors.add(sum);\n        boolean hasResult = false;\n        for (int i : factors) {\n            if (helper(i, K, A)) {\n                System.out.println(i);\n                hasResult = true;\n                break;\n            }\n        }\n        if (!hasResult) {\n            System.out.println(1);\n        }\n    }\n    private static boolean helper(int i, int k, int[] A) {\n        int max = 0, sum = 0;\n        for (int a : A) {\n            int tmp = a % i;\n            max = Math.max(max, tmp);\n            sum += tmp;\n        }\n        return sum - max <= k;\n    }\n}",
        "submission_id": "s423623218",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 16,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03721",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        try (InputReader reader = new InputReader(System.in)) {\n            solve(reader);\n        }\n    }\n    private static void solve(InputReader reader) throws IOException {\n        int[] input = reader.readIntsSplitByDelimiter(\" \");\n        Map<Integer, Long> map = new TreeMap<>();\n        for (int i = 0; i < input[0]; i++) {\n            long[] longs = reader.readLongsSplitByDelimiter(\" \");\n            Long value = map.getOrDefault((int)longs[0], 0L) + longs[1];\n            map.put((int)longs[0], value);\n        }\n        long sum = 0;\n        for (Map.Entry<Integer, Long> e : map.entrySet()) {\n            sum += e.getValue();\n            if (sum >= input[1]) {\n                System.out.println(e.getKey());\n                return;\n            }\n        }\n    }\n}\nclass Util {\n    static int gcd(int m, int n) {\n        int min = Math.min(m, n);\n        int max = Math.max(m, n);\n        while (min != 0) {\n            int tmp = min;\n            min = max % tmp;\n            max = tmp;\n        }\n        return max;\n    }\n}\nclass InputReader implements Closeable, AutoCloseable {\n    private final BufferedReader br;\n    InputReader(InputStream inputStream) {\n        this.br = new BufferedReader(new InputStreamReader(inputStream));\n    }\n    String readLine() throws IOException {\n        return this.br.readLine();\n    }\n    int readInt() throws IOException {\n        return Integer.parseInt(this.readLine());\n    }\n    long readLong() throws IOException {\n        return Long.parseLong(this.readLine());\n    }\n    double readDouble() throws IOException {\n        return Double.parseDouble(this.readLine());\n    }\n    String[] readStringsSplitByDelimiter(String delimiter) throws IOException {\n        return this.readLine().split(delimiter);\n    }\n    int[] readIntsSplitByDelimiter(String delimiter) throws IOException {\n        String[] strings = this.readStringsSplitByDelimiter(delimiter);\n        int stringsLength = strings.length;\n        int[] ints = new int[stringsLength];\n        for (int i = 0; i < stringsLength; i++) {\n            ints[i] = Integer.parseInt(strings[i]);\n        }\n        return ints;\n    }\n    long[] readLongsSplitByDelimiter(String delimiter) throws IOException {\n        String[] strings = this.readStringsSplitByDelimiter(delimiter);\n        int stringsLength = strings.length;\n        long[] longs = new long[stringsLength];\n        for (int i = 0; i < stringsLength; i++) {\n            longs[i] = Long.parseLong(strings[i]);\n        }\n        return longs;\n    }\n    double[] readDoublesSplitByDelimiter(String delimiter) throws IOException {\n        String[] strings = this.readStringsSplitByDelimiter(delimiter);\n        int stringsLength = strings.length;\n        double[] doubles = new double[stringsLength];\n        for (int i = 0; i < stringsLength; i++) {\n            doubles[i] = Double.parseDouble(strings[i]);\n        }\n        return doubles;\n    }\n    @Override\n    public void close() throws IOException {\n        this.br.close();\n    }\n}",
        "submission_id": "s429306480",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 97,
        "cyclomatic_complexity": 20,
        "branch_factor": 7
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02576",
        "code_tokens": "package com.codeforces.round654;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nclass Main {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static ArrayList<Integer> primes = new ArrayList<>();\n    static long lcm(long n){\n        long ans = 1;\n        for (int i=0; i<primes.size() && primes.get(i)<=n; i++)\n        {\n            int pp = primes.get(i);\n            while (pp*primes.get(i) <= n)\n                pp = pp *primes.get(i);\n            ans *= pp;\n        }\n        return ans;\n    }\n    public static void main(String[] args) throws Exception {\n        FastReader fr = new FastReader();\n        int n = fr.nextInt();\n        int x = fr.nextInt();\n        int xx = x;\n        int t = fr.nextInt();\n        int tt = t;\n        if(n<x){\n            System.out.println(t);\n        }\n        else{\n            while(x<n){\n                x+=xx;\n                t+=tt;\n            }\n            System.out.println(t);\n        }\n    }\n}",
        "submission_id": "s484797434",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 76,
        "cyclomatic_complexity": 17,
        "branch_factor": 9
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03313",
        "code_tokens": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        final int[] a = new int[1 << n];\n        for (int i = 0; i < 1 << n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int[][] dp = new int[1 << n][2];\n        dp[1][0] = 0;\n        dp[1][1] = -1;\n        for (int i = 1; i < 1 << n; i++) {\n            dp[i][0] = i;\n            dp[i][1] = -1;\n            System.err.println(i);\n            System.err.println(Arrays.toString(dp[i]));\n            for (int j = n - 1; j >= 0; j--) {\n                if (((1 << j) & i) != 0) {\n                    int[] collect = dp[i ^ (1 << j)];\n                    Integer[] wild = new Integer[4];\n                    wild[0] = dp[i][0];\n                    wild[1] = dp[i][1];\n                    wild[2] = collect[0];\n                    wild[3] = collect[1];\n                    Arrays.sort(wild, new Comparator<Integer>() {\n                        @Override\n                        public int compare(Integer i1, Integer i2) {\n                            if (i1.equals(i2)) {\n                                return 0;\n                            }\n                            if (i1 == -1) return 1;\n                            if (i2 == -1) return -1;\n                            return Integer.compare(a[i1], a[i2]);\n                        }\n                    });\n                    int idx = 0;\n                    int pv = -2;\n                    for (int k = 3; k >= 0; k--) {\n                        if (wild[k] == -1) throw new RuntimeException(Arrays.toString(wild));\n                        if (wild[k] == pv) continue;\n                        pv = dp[i][idx++] = wild[k];\n                        if (idx == 2) break;\n                    }\n                    System.err.println(Arrays.toString(dp[i]));\n                }\n            }\n        }\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 1; i < 1 << n; i++) {\n            pw.println(a[dp[i][0]] + a[dp[i][1]]);\n        }\n        pw.close();\n    }\n    public static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n        public int nextInt() throws IOException{\n            return Integer.parseInt(next());\n        }\n    }\n}",
        "submission_id": "s542839099",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 72,
        "cyclomatic_complexity": 18,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03385",
        "code_tokens": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint a = sc.nextInt();\n\t\tint b = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tif (a > b || a < 0 || b < 0 || a > 1000000000 || b > 1000000000 || k < 0 || k > 100) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tint x = a + k - 1;\n\t\tif (x > b) {\n\t\t\tx = b;\n\t\t}\n\t\tif(x<a){\n\t\t\tx=a;\n\t\t}\n\t\tint y = b - k + 1;\n\t\tif (y < a) {\n\t\t\ty = a;\n\t\t}\n\t\tif(y>b){\n\t\t\ty=b;\n\t\t}\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tfor (int i = a; i <= x; i++) {\n\t\t\tset.add(i);\n\t\t}\n\t\tfor (int i = y; i <= b; i++) {\n\t\t\tset.add(i);\n\t\t}\n\t\tfor (Integer j : set) {\n\t\t\tSystem.out.println(j);\n\t\t}\n\t}\n}",
        "submission_id": "s549438911",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 15,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03607",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n  static int N = 0, M = 0, R = 0;\n  static int[][] d;\n  static int[] r;\n  static int A = 0, B = 0, C = 0;\n  static int res = 0;\n  static boolean used [];\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    N = sc.nextInt();\n    M = sc.nextInt();\n    R = sc.nextInt();\n    d = new int[201][201];\n    r = new int[9];\n    used = new boolean[9];\n    for(int i = 1; i <= N; i++) {\n      for(int j = 1; j <= N; j++) {\n        if (i != j) {\n          d[i][j] = Integer.MAX_VALUE;\n        }\n      }\n    }\n    for(int i = 1; i <= R; i++) {\n      r[i] = sc.nextInt();\n    }\n    for(int i = 1; i <= M; i++) {\n      A = sc.nextInt();\n      B = sc.nextInt();\n      C = sc.nextInt();\n      if(d[A][B] > C) {\n        d[A][B] = d[B][A] = C;\n      }\n    }\n    for(int k = 1; k <= N; k++) {\n      for(int i = 1; i <= N; i++) {\n        for(int j = 1; j <= N; j++) {\n          if(d[i][j] > d[i][k] + d[k][j]) {\n            d[i][j] = d[i][k] + d[k][j];\n          }\n        }\n      }\n    }\n    res = Integer.MAX_VALUE;\n    dfs(1, -1, 0);\n    System.out.println(res);\n  }\n  private static void dfs(int c, int las, int dist) {\n    if(c == R + 1) {\n      if(res > dist) {\n        res = dist;\n      }\n      return;\n    }\n    for(int i = 1; i <= R; i++) {\n      if(!used[i]){\n        used[i] = true;\n        if(las == -1) dfs(c+1, i, 0);\n        else dfs(c+1, i, dist+d[r[las]][r[i]]);\n        used[i] = false;\n      }\n    }\n  }\n}",
        "submission_id": "s651866169",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 64,
        "cyclomatic_complexity": 17,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00606",
        "code_tokens": "import java.math.BigDecimal;\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\nclass Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n;\n\tstatic char s, t, b;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};\n\tpublic static void main(String[] args) {\n\t\twhile (read()) {\n\t\t\tsolve();\n\t\t}\n\t}\n\tstatic boolean read() {\n\t\tn = sc.nextInt();\n\t\tif (n == 0) return false;\n\t\ts = sc.next().charAt(0);\n\t\tt = sc.next().charAt(0);\n\t\tb = sc.next().charAt(0);\n\t\treturn true;\n\t}\n\tstatic void solve() {\n\t\tBigDecimal[][][] dp = new BigDecimal[n + 1][5][5];\n\t\tfor (int i = 0; i <= n; i++) { \n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tdp[i][j][k] = new BigDecimal(0.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint pos_s = s - 'A', pos_t = t - 'A', pos_b = b - 'A';\n\t\tint sx = pos_s % 3 + 1, sy = pos_s / 3 + 1;\n\t\tint gx = pos_t % 3 + 1, gy = pos_t / 3 + 1;\n\t\tint bx = pos_b % 3 + 1, by = pos_b / 3 + 1;\n\t\tdp[0][sy][sx] = new BigDecimal(1.0);\n\t\tBigDecimal bf = new BigDecimal(0.25);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int y = 1; y <= 3; y++) {\n\t\t\t\tfor (int x = 1; x <= 3; x++) {\n\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\tint ty = y + dy[l], tx = x + dx[l];\n\t\t\t\t\t\tif ((y == by) && (x == bx)){\n\t\t\t\t\t\t\tty = y; tx = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][ty][tx] = dp[i][ty][tx].add(dp[i - 1][y][x].multiply(bf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.8f\", dp[n][gy][gx]);\n\t\tSystem.out.println();\n\t}\n}",
        "submission_id": "s657908154",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 14,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03112",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        final Scanner scanner = new Scanner(System.in);\n        final int shrine = scanner.nextInt();\n        final int temple = scanner.nextInt();\n        final int startPoint = scanner.nextInt();\n        final List<Long> shrines = new ArrayList<>();\n        final List<Long> temples = new ArrayList<>();\n        for (int i = 0; i < shrine; i++) {\n            shrines.add(scanner.nextLong());\n        }\n        for (int i = 0; i < temple; i++) {\n            temples.add(scanner.nextLong());\n        }\n        for (int i = 0; i < startPoint; i++) {\n            final long point = scanner.nextLong();\n            int sp = Collections.binarySearch(shrines, point);\n            final List<Long> candidateShrines = new ArrayList<>();\n            if (sp != 0) {\n                candidateShrines.add(0L);\n            } else {\n                sp = -(sp + 1);\n                if (sp != 0) {\n                    candidateShrines.add(shrines.get(sp - 1) - point);\n                }\n                if (sp != shrines.size()) {\n                    candidateShrines.add(shrines.get(sp) - point);\n                }\n            }\n            int tp = Collections.binarySearch(temples, point);\n            final List<Long> candidateTemples = new ArrayList<>();\n            if (tp != 0) {\n                candidateShrines.add(0L);\n            } else {\n                tp = -(tp + 1);\n                if (tp != 0) {\n                    candidateTemples.add(temples.get(tp - 1) - point);\n                }\n                if (tp != temples.size()) {\n                    candidateTemples.add(temples.get(tp) - point);\n                }\n            }\n            final List<Long> candidateAnswers = new ArrayList<>();\n            for (final Long candidateShrine : candidateShrines) {\n                for (final Long candidateTemple : candidateTemples) {\n                    candidateAnswers.add(calc(candidateShrine, candidateTemple));\n                }\n            }\n            Collections.sort(candidateAnswers);\n            System.out.println(candidateAnswers.get(0));\n        }\n    }\n    private static long calc(final long a, final long b) {\n        if (a * b < 0) {\n            final long aa = Math.abs(a);\n            final long ab = Math.abs(b);\n            return Math.min(aa, ab) * 2 + Math.max(aa, ab);\n        } else {\n            return Math.max(Math.abs(a), Math.abs(b));\n        }\n    }\n}",
        "submission_id": "s670341402",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 66,
        "cyclomatic_complexity": 14,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02684",
        "code_tokens": "import java.util.*;\npublic class Main{\n    Scanner sc = new Scanner(System.in);\n    public static void main(String[] args){\n        new Main().run();\n    }\n    void run() {\n        int n = sc.nextInt();\n        long k = sc.nextLong();\n        int[] arr = new int[n];\n        for (int i=0; i<n; i++) arr[i] = sc.nextInt() - 1;\n        int[] cnt = new int[n];\n        cnt[0] = 1;\n        int start = Integer.MAX_VALUE;\n        int idx = arr[0];\n        cnt[idx]++;\n        outer:\n        for (int i=1; i<n; i++) {\n            int tmp = arr[idx];\n            cnt[tmp]++;\n            if (cnt[tmp] == 2) {\n                start = tmp;\n                break outer;\n            }\n            idx = tmp;\n        }\n        int before = 0;\n        idx = arr[0];\n        if (start != 0) {\n            before++;\n            out:\n            for (int i=1; i<n; i++) {\n                int tmp = arr[idx];\n                before++;\n                idx = tmp;\n                if (tmp == start) break out;\n            }\n        }\n        int circle = 0;\n        idx = arr[0];\n        if (start == 0) {\n            circle++;\n            for (int i=1; i<n; i++) {\n                int tmp = arr[idx];\n                circle++;\n                if (tmp == start) break;\n                idx = tmp;\n            }\n        } else {\n            for (int i=1; i<n; i++) {\n                int tmp = arr[idx];\n                idx = tmp;\n                if (tmp == start) {\n                    circle++;\n                    tmp = arr[tmp];\n                    while (tmp != start) {\n                        circle++;\n                        tmp = arr[tmp];\n                    }\n                    break;\n                }\n            }\n        }\n        long remain = (k - before) % circle;\n        int ans = Integer.MAX_VALUE;\n        idx = arr[start];\n        if (remain == 0) {\n            System.out.println(start + 1);\n        } else {\n            for (int i=0; i<remain-1; i++) {\n                int tmp = arr[idx];\n                idx = tmp;\n                System.out.println(idx + 1);\n            }\n        }\n    }\n}",
        "submission_id": "s681820022",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 16,
        "branch_factor": 14
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03165",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\npublic class Main {\n  public static void main(String[] args) throws IOException {\n    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    String a = in.next();\n    String b = in.next();\n    new Solver().solve(a, b, a.length(), b.length());\n  }\n}\nclass Solver {\n  public void solve(String a, String b, int m, int n) {\n    int[][] dp = new int[m + 1][n + 1];\n    int[][] res = new int[m + 1][n + 1];\n    for (int i = 0; i <= m; ++i) {\n      for (int j = 0; j <= n; ++j) {\n        dp[i][j] = -3100;\n      }\n    }\n    dp[0][0] = 0;\n    for (int i = 0; i <= m; ++i) {\n      for (int j = 0; j <= n; ++j) {\n        if (i + 1 <= m) {\n          if (dp[i + 1][j] < dp[i][j]) {\n            dp[i + 1][j] = dp[i][j];\n            res[i + 1][j] = 0;\n          }\n        }\n        if (j + 1 <= m) {\n          if (dp[i][j + 1] < dp[i][j]) {\n            dp[i][j + 1] = dp[i][j];\n            res[i][j + 1] = 1;\n          }\n        }\n        if (i + 1 <= m && j + 1 <= n && a.charAt(i) == b.charAt(j)) {\n          if (dp[i + 1][j + 1] < dp[i][j] + 1) {\n            dp[i + 1][j + 1] = dp[i][j] + 1;\n            res[i + 1][j + 1] = 2;\n          }\n        }\n      }\n    }\n    int na = m;\n    int nb = n;\n    StringBuilder sb = new StringBuilder();\n    while (na > 0 || nb > 0) {\n      if (res[na][nb] == 2) {\n        na--;\n        nb--;\n        sb.append(a.charAt(na));\n      } else if (res[na][nb] == 0) {\n        na--;\n      } else {\n        nb--;\n      }\n    }\n    if (sb.length() == 0) {\n      String out = \"\";\n      System.out.println(out);\n    } else {\n      System.out.println(sb.reverse().toString());\n    }\n  }\n}",
        "submission_id": "s702743016",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 66,
        "cyclomatic_complexity": 19,
        "branch_factor": 17
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02408",
        "code_tokens": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            String type = sc.next();\n            if (type.equals(\"S\")) {\n                a[i] = sc.nextInt() + 100;\n            } else if (type.equals(\"H\")) {\n                a[i] = sc.nextInt() + 200;\n            } else if (type.equals(\"C\")) {\n                a[i] = sc.nextInt() + 300;\n            } else if (type.equals(\"D\")) {\n                a[i] = sc.nextInt() + 400;\n            }\n        }\n        Arrays.sort(a);\n        for (int i = 1, j = 0; i <= 52; i++) {\n            if (i <= 13) { \n                if (a[j] == 100 + i) {\n                    j++;\n                } else {\n                    System.out.println(\"S \" + i);\n                }\n            } else if (i <= 26) { \n                if (a[j] == 200 + i - 13) {\n                    j++;\n                } else {\n                    System.out.println(\"H \" + (i - 13));\n                }\n            } else if (i <= 39) { \n                if (a[j] == 300 + i - 26) {\n                    j++;\n                } else {\n                    System.out.println(\"C \" + (i - 26));\n                }\n            } else { \n                if (a[j] == 400 + i - 39) {\n                    j++;\n                } else {\n                    System.out.println(\"D \" + (i - 39));\n                }\n            }\n        }\n    }\n}",
        "submission_id": "s741249232",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 49,
        "cyclomatic_complexity": 14,
        "branch_factor": 13
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p04015",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint N = in.nextInt(), A = in.nextInt();\n\t\t\tint[] xn = in.nextIntArray(N);\n\t\t\tint X = A;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tX = Math.max(X, xn[i]);\n\t\t\t}\n\t\t\tint[][][] dp = new int[N+1][N+1][N*X+1];\n\t\t\tdp[0][0][0] = 1;\n\t\t\tfor (int i = 0; i <= N; i++) {\n\t\t\t\tfor (int j = 0; j <= N; j++) {\n\t\t\t\t\tfor (int k = 0; k <= N*X; k++) {\n\t\t\t\t\t\tif (j-1 < 0 && k-xn[i-1]<0) {\n\t\t\t\t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k-xn[i-1]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tans += dp[N][k][k*A];\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n}",
        "submission_id": "s742778919",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 90,
        "cyclomatic_complexity": 20,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02759",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nclass Main{\n    public static void main(String[] args){\n        Scanner scanner = new Scanner(System.in);\n        int[][] bingo = new int[3][3];\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                bingo[i][j] = Integer.parseInt(scanner.next());\n            }\n        }\n        int count = scanner.nextInt();\n        List<Integer> list = new ArrayList<>();\n        for(int i=0; i<count; i++){\n            list.add(scanner.nextInt());\n        }\n        scanner.close();\n        int[][] result = new int[9][9];\n        int count0 = 0;\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                if(list.contains(bingo[i][j])){\n                    result[i][j] = 1;\n                    count0 += 1;\n                }else{\n                    result[i][j] = 0;\n                }\n            }\n        }\n        if(count0 < 3){\n            System.out.println(\"No\");\n            return;\n        }\n        int count1 = 0;\n        int count2 = 0;\n        int count3 = 0;\n        int count4 = 0;\n        for(int i=0; i<3; i++){\n            for(int j=0; j<3; j++){\n                if(result[i][j]==1){\n                    count1 += 1;\n                }\n                if(count1==3){\n                    System.out.println(\"Yes\");\n                    return;\n                }\n                if(result[j][i]==1){\n                    count2 += 1;\n                }\n                if(count2==3){\n                    System.out.println(\"Yes\");\n                    return;\n                }\n                if(result[i][i]==1){\n                    count3 += 1;\n                }\n                if(count3==3){\n                    System.out.println(\"Yes;\");\n                    return;\n                }\n                if(result[0][2]==1 && result[1][1]==1 && result[2][0]==1){\n                    count4 += 1;\n                }\n                if(count4==3){\n                    System.out.println(\"Yes\");\n                    return;\n                }\n            }\n            count1 = 0;\n            count2 = 0;\n            count3 = 0;\n            count4 = 0;\n        }\n    }\n}",
        "submission_id": "s782466454",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 76,
        "cyclomatic_complexity": 20,
        "branch_factor": 19
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02264",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Main {\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str[] = r.readLine().split(\" \");\n\t\tint max = Integer.parseInt(str[0]);\n\t\tQueue q = new Queue(max);\n\t\tint qtime = Integer.parseInt(str[1]);\n\t\tfor(int i = 0 ; i < max ; i++ ){\n\t\t\tstr = r.readLine().split(\" \");\n\t\t\tq.enqueue(new Process(str[0], Integer.parseInt(str[1])));\n\t\t}\n\t\tint elapsedTime = 0;\n\t\tint count = 0;\n\t\twhile(true){\n\t\t\tif(max <= count) break;\n\t\t\tProcess p = q.dequeue();\n\t\t\tint time = p.getTime();\n\t\t\tif(time <= qtime){\n\t\t\t\telapsedTime+= time;\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(p.getName() +\" \"+elapsedTime);\n\t\t\t}else{\n\t\t\t\tp.setTime(time - qtime);\n\t\t\t\telapsedTime += qtime;\n\t\t\t\tq.enqueue(p);\n\t\t\t}\n\t\t}\n\t}\n}\nclass Queue{\n\tProcess[] processAry;\n\tint top;\n\tint tail;\n\tint max;\n\tpublic Queue(int max){\n\t\ttop = tail = 0;\n\t\tprocessAry = new Process[max];\n\t\tthis.max = max;\n\t}\n\tpublic void enqueue(Process process) throws Exception{\n\t\tif(isFull()){\n\t\t\tthrow new Exception(\"FULL\");\n\t\t}else{\n\t\t\tprocessAry[top] = process;\n\t\t\ttop = (top + 1) % max;\n\t\t}\n\t}\n\tpublic Process dequeue() throws Exception{\n\t\t\tProcess p = processAry[tail];\n\t\t\ttail = (tail + 1) % max;\n\t\t\treturn p;\n\t}\n\tpublic boolean isFull(){\n\t\treturn tail == top + 1 % max;\n\t}\n\tpublic boolean isEmpty(){\n\t\treturn top == tail;\n\t}\n}\nclass Process{\n\tprivate String name;\n\tprivate int time;\n\tpublic Process(String name,int time) {\n\t\tthis.name = name;\n\t\tthis.time = time;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic int getTime() {\n\t\treturn time;\n\t}\n\tpublic void setTime(int time) {\n\t\tthis.time = time;\n\t}\n}",
        "submission_id": "s800314634",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 78,
        "cyclomatic_complexity": 15,
        "branch_factor": 5
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p04015",
        "code_tokens": "import java.util.*;\n\tpublic class Main{\n\t\tpublic static void main(String[] args){\n            Scanner sc = new Scanner(System.in);\n            int n = Integer.parseInt(sc.next());\n            int a = Integer.parseInt(sc.next());\n            int[] nums = new int[n];\n            int max = 1;\n            for(int i=0; i<n; i++){\n            \tnums[i] = Integer.parseInt(sc.next());\n            \tif(max<nums[i]){\n            \t\tmax = nums[i];\n            \t}\n            }\n            long[][][] dp = new long[n+1][n+1][n*max+1];\n            for(int i=0; i<n+1; i++){\n            \tfor(int j=0; j<n*max+1; j++){\n            \t\tdp[0][i][j] = 0;\n            \t\tdp[i][0][j] = 0;\n            \t}\n            }\n            for(int i=0; i<n+1; i++){\n            \tdp[i][0][0] = 1;\n            }\n            for(int k=0; k<n*max+1; k++){\n            \tfor(int j=1; j<n+1; j++){\n            \t\tfor(int i=1; i<n+1; i++){\n            \t\t\tif(i<j){\n            \t\t\t\tdp[i][j][k] = 0;\n            \t\t\t}else{\n            \t\t\t\tdp[i][j][k] = dp[i-1][j][k];\n            \t\t\t\tif(k-nums[i-1] >= 0){\n            \t\t\t\t\tdp[i][j][k] += dp[i-1][j-1][k-nums[i-1]];\n            \t\t\t\t}\n            \t\t\t}\n            \t\t}\n            \t}\n            }\n            long ret = 0;\n            for(int i=1; i*a<n*max+1; i++){\n            \tret += dp[n][i][i*a];\n            }\n            System.out.println(ret);\n            sc.close();\n        }\n    }",
        "submission_id": "s820572542",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 46,
        "cyclomatic_complexity": 12,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02309",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\npublic class Main {\n\tArrayList<P> calc(Circle c1, Circle c2) {\n\t\tArrayList<P> ret = new ArrayList<>();\n\t\tP midP = new P((c2.center.x * c1.r + c1.center.x * c2.r) / (c1.r + c2.r),\n\t\t\t\t(c2.center.y * c1.r + c1.center.y * c2.r) / (c1.r + c2.r));\n\t\tdouble d = c1.center.dist(c2.center);\n\t\tdouble cos = (c1.r * c1.r + d * d - c2.r * c2.r) / (2 * d * c1.r);\n\t\tdouble h = c1.r * Math.sqrt(1 - cos * cos);\n\t\tret.add(midP.add(c2.center.sub(c1.center).normalize().rot(Math.PI / 2).mul(h)));\n\t\tif (h > 0)\n\t\t\tret.add(midP.add(c2.center.sub(c1.center).normalize().rot(Math.PI / 2).mul(-h)));\n\t\treturn ret;\n\t}\n\tvoid run(double c1x, double c1y, double c1r, double c2x, double c2y, double c2r) {\n\t\tP center1 = new P(c1x, c1y);\n\t\tP center2 = new P(c2x, c2y);\n\t\tCircle c1 = new Circle(center1, c1r);\n\t\tCircle c2 = new Circle(center2, c2r);\n\t\tArrayList<P> ret = calc(c1, c2);\n\t\tCollections.sort(ret);\n\t\tif (ret.size() == 2)\n\t\t\tfor (int i = 0; i < ret.size(); ++i) {\n\t\t\t\tSystem.out.printf(\"%.10f %.10f\", ret.get(i).x, ret.get(i).y);\n\t\t\t\tSystem.out.print(i == ret.size() - 1 ? \"\\n\" : \" \");\n\t\t\t}\n\t\telse {\n\t\t\tSystem.out.printf(\"%.10f %.10f %10.f %10.f\", ret.get(0).x, ret.get(0).y, ret.get(0).x, ret.get(0).y);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tdouble c1x, c1y, c1r, c2x, c2y, c2r;\n\t\tc1x = sc.nextDouble();\n\t\tc1y = sc.nextDouble();\n\t\tc1r = sc.nextDouble();\n\t\tc2x = sc.nextDouble();\n\t\tc2y = sc.nextDouble();\n\t\tc2r = sc.nextDouble();\n\t\tnew Main().run(c1x, c1y, c1r, c2x, c2y, c2r);\n\t}\n\tclass Circle {\n\t\tP center;\n\t\tdouble r;\n\t\tpublic Circle(P center, double r) {\n\t\t\tthis.center = center;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\tclass P implements Comparable<P> {\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tdouble norm() {\n\t\t\treturn Math.sqrt(x * x + y * y);\n\t\t}\n\t\tP normalize() {\n\t\t\treturn this.mul(1 / this.norm());\n\t\t}\n\t\tP add(P p) {\n\t\t\treturn new P(x + p.x, y + p.y);\n\t\t}\n\t\tP sub(P p) {\n\t\t\treturn this.add(p.mul(-1));\n\t\t}\n\t\tP mul(double coe) {\n\t\t\treturn new P(x * coe, y * coe);\n\t\t}\n\t\tdouble dist(P p) {\n\t\t\treturn Math.sqrt((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));\n\t\t}\n\t\tP rot(double ang) {\n\t\t\tdouble c = Math.cos(ang);\n\t\t\tdouble s = Math.sin(ang);\n\t\t\treturn new P(c * x - s * y, s * x + c * y);\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (Math.abs(x - o.x) > 1e-6)\n\t\t\t\treturn Double.compare(x, o.x);\n\t\t\telse {\n\t\t\t\treturn Double.compare(y, o.y);\n\t\t\t}\n\t\t}\n\t}\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}",
        "submission_id": "s834542709",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 94,
        "cyclomatic_complexity": 19,
        "branch_factor": 5
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00221",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int m = sc.nextInt(), n = sc.nextInt();\n            if ((m | n) == 0)\n                break;\n            List<Integer> l = new ArrayList<>();\n            for (int i = 1; i <= m; i++) {\n                l.add(i);\n            }\n            int p = 0;\n            for (int i = 1; i <= n; i++) {\n                String s = sc.next();\n                String a = \"\";\n                if (i % 3 == 0) {\n                    a = \"Fizz\";\n                }\n                if (i % 5 == 0) {\n                    a += \"Buzz\";\n                }\n                if (a.equals(\"\")) {\n                    a = String.valueOf(i);\n                }\n                if (s.equals(a)) {\n                    p = (p + 1) % l.size();\n                } else if (l.size() > 1) {\n                    l.remove(p);\n                }\n            }\n            for (int i = 0; i < l.size(); i++) {\n                System.out.print(l.get(i) + (i < l.size() - 1 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}",
        "submission_id": "s841534302",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 39,
        "cyclomatic_complexity": 12,
        "branch_factor": 11
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03013",
        "code_tokens": "import java.util.*;\npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int mod = (int)1e9 + 7;\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int block[] = new int[m];\n        for (int i=0; i<m; i++){\n            block[i] = sc.nextInt();\n        }\n        int sums[] = new int[n+1];\n        boolean stone[] = new boolean[n+1];\n        for (int i=0; i<m; i++) {\n            stone[block[i]] = true;\n        }\n        if (block[0]==0) {System.out.println(0);}\n        else if (block[0]==1) {\n            sums[0] = 1;\n            sums[1] = 0;\n            for (int i = 0; i < n - 1; i++) {\n                if (stone[i + 2] == false) {\n                    sums[i + 2] = (sums[i + 1] + sums[i]) % mod;\n                } else if (stone[i + 2] == true) {\n                    sums[i + 2] = 0;\n                }\n            }\n            System.out.println(sums[n] % mod);\n        }\n        else{\n            sums[0] = 1;\n            sums[1] = 1;\n            for (int i = 0; i < n - 1; i++) {\n                if (stone[i + 2] == false) {\n                    sums[i + 2] = (sums[i + 1] + sums[i]) % mod;\n                } else if (stone[i + 2] == true) {\n                    sums[i + 2] = 0;\n                }\n            }\n            System.out.println(sums[n] % mod);\n        }\n    }\n}",
        "submission_id": "s858273878",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 43,
        "cyclomatic_complexity": 11,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03105",
        "code_tokens": "import java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.HashSet;\nimport java.util.Scanner;\npublic class Main {\n  static int mod = 1000000007;\n  public static void main(String[] args) throws FileNotFoundException {\n    Scanner cin = new Scanner(System.in);\n    int island = cin.nextInt();\n    int bridge = cin.nextInt();\n    UnionFind UF = new UnionFind(island);\n    int[][] connect = new int[bridge][2];\n    for (int i=0;i<bridge;i++) {\n      int a = cin.nextInt();\n      int b = cin.nextInt();\n      connect[i][0] = a-1;\n      connect[i][1] = b-1;\n    }\n    long[] res = new long[bridge+1];\n    res[bridge] = (long)island*(island-1)/2;\n    for (int i=bridge - 1;i>=0;i--) {\n      if (UF.find(connect[i][0])==UF.find(connect[i][1]))\n        res[i] = res[i+1];\n      else {\n        res[i] = res[i+1] - (long)UF.size(connect[i][0])*UF.size(connect[i][1]);\n        UF.union(connect[i][0], connect[i][1]);\n      }\n    }\n    for (int i=1;i<res.length;i++ ) {\n      System.out.println(res[i]);\n    }\n  }\n  public static class UnionFind {\n    int[] par;\n    int[] rank;\n    int[] size;\n    UnionFind(int n) {\n      par = new int[n];\n      rank = new int[n];\n      size = new int[n];\n      for (int i = 0; i < n; i++) {\n        par[i] = i;\n        rank[i] = 0;\n        size[i] = 1;\n      }\n    }\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(par[x]);\n    }\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      if (rank[x] < rank[y]) {\n        par[x] = y;\n        size[y] += size[x];\n      } else {\n        par[y] = x;\n        size[x] += size[y];\n        if (rank[x] == rank[y]) {\n          rank[x]++;\n        }\n      }\n    }\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n    int size(int x) {\n      return size[find(x)];\n    }\n  }\n}",
        "submission_id": "s871636926",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 15,
        "branch_factor": 9
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03067",
        "code_tokens": "import java.util.* ;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in) ;\n\t\tint len = in.nextInt() ;\n\t\tString line = in.next() ;\n\t\tint min = 0 ;\n\t\tchar[] cs = line.toCharArray() ;\n\t\tint zt1,zt2 ;\n\t\tfor(int i=0;i<len;i++) {\n\t\t\tzt1 = zt2 = -1 ;\n\t\t\tif(i+1==len)\n\t\t\t\tbreak ;\n\t\t\tif(cs[i]=='#'&&cs[i+1]=='.') {\n\t\t\t\tif(i-1>=0) { \n\t\t\t\t\tif(cs[i-1]=='#') {\n\t\t\t\t\t\tzt1 = 0 ;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tzt1 = 1 ;\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tzt1 = 1 ;\n\t\t\t\t}\n\t\t\t\tif(i+2!=len) {\n\t\t\t\t\tif(cs[i+2]=='.') { \n\t\t\t\t\t\tzt2 = 0 ;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tzt2 = 1 ;\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tzt2 = 1 ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(zt1==0&&zt2==1) {\n\t\t\t\tcs[i+1]='#' ;\n\t\t\t\tmin++ ;\n\t\t\t}\n\t\t\tif(zt1==1&&zt2==0) {\n\t\t\t\tcs[i]='.' ;\n\t\t\t\tmin++ ;\n\t\t\t}\n\t\t\tif(zt1==1&&zt2==1) {\n\t\t\t\tcs[i]='.' ;\n\t\t\t\tmin++ ;\n\t\t\t}\n\t\t\tif(zt1==0&&zt2==0) {\n\t\t\t\tcs[i+1]='#' ;\n\t\t\t\tmin++ ;\n\t\t\t\ti-- ;\n\t\t\t}\n\t\t} \n\t\tSystem.out.println(min) ;\n\t}\n}",
        "submission_id": "s962701834",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 17,
        "branch_factor": 16
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03219",
        "code_tokens": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint[][] input = new int[M][2];\n\t\tfor(int i = 0;i < M;++i) {\n\t\t\tinput[i][0] = sc.nextInt();\n\t\t\tinput[i][1] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\t\tMap<Integer, ArrayList<Integer>> map = new HashMap<>();\n\t\tfor(int i = 0;i < M;++i) {\n\t\t\tif(!map.containsKey(input[i][0])) {\n\t\t\t\tArrayList<Integer> cap = new ArrayList<>();\n\t\t\t\tcap.add(i);\n\t\t\t\tmap.put(input[i][0], cap);\n\t\t\t}else {\n\t\t\t\tArrayList<Integer> list = map.get(input[i][0]);\n\t\t\t\tfor(int j = 0;j < list.size();++j) {\n\t\t\t\t\tif(j == 0) {\n\t\t\t\t\t\tif(input[list.get(0)][1] > input[i][1])\n\t\t\t\t\t\t\tlist.add(0, i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t\tmap.remove(input[i][0]);\n\t\t\t\t\t\tmap.put(input[i][0], list);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(j == list.size()-1) {\n\t\t\t\t\t\tlist.add(i);\n\t\t\t\t\t\tmap.remove(input[i][0]);\n\t\t\t\t\t\tmap.put(input[i][0], list);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(input[list.get(j)][1] < input[i][1] && input[i][1] < input[list.get(j+1)][1]) {\n\t\t\t\t\t\t\tlist.add(j+1, i);\n\t\t\t\t\t\t\tmap.remove(input[i][0]);\n\t\t\t\t\t\t\tmap.put(input[i][0], list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(Integer i : map.keySet()) {\n\t\t\tArrayList<Integer> list = map.get(i);\n\t\t\tfor(int j = 0;j < list.size();++j) {\n\t\t\t\tinput[list.get(j)][1] = j;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < M;++i)\n\t\t\tSystem.out.println(String.format(\"%06d%06d\", input[i][0], input[i][1]+1));\n\t}\n}",
        "submission_id": "s985231098",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 58,
        "cyclomatic_complexity": 13,
        "branch_factor": 12
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03423",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nclass Main{\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader sc = new FastReader();\n\t\tSet<Character> set = new HashSet<>();\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\tset.add(ch[0]);\n\t\t}\n\t\tSystem.out.println(set.size()==3?\"Three\":\"Four\");\n}\n}",
        "submission_id": "s798613825",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 13,
        "branch_factor": 6
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02408",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n\tvoid find(){\n\t\tboolean cards[][] = new boolean[4][13];\n\t\tString markList[] = new String [4];\n\t\tmarkList[0] = \"S\";\n\t\tmarkList[1] = \"H\";\n\t\tmarkList[2] = \"C\";\n\t\tmarkList[3] = \"D\";\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tfor(int i = 0;i<13;i++){\n\t\t\t\tcards[j][i] = false;\n\t\t\t}\n\t\t}\n\t\tScanner s = new Scanner(System.in);\n\t\tint cnt = s.nextInt();\n\t\tfor(int i = 0;i < cnt;i++){\n\t\t\tString mark = s.next();\n\t\t\tint num = s.nextInt();\n\t\t\tSystem.out.println(\"#\" + mark);\n\t\t\tswitch(mark){\n\t\t\tcase \"S\":\n\t\t\t\tcards[0][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\tcards[1][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tcards[2][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tcards[3][num] = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tfor(int i = 0;i<13;i++){\n\t\t\t\tif(!cards[j][i]){\n\t\t\t\t\tSystem.out.println(markList[j] + \" \" + (i+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tMain m = new Main();\n\t\tm.find();\n\t}\n}",
        "submission_id": "s284602278",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 50,
        "cyclomatic_complexity": 12,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03721",
        "code_tokens": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            TreeMap<Long, Long> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                long a = in.nextInt();\n                long b = in.nextInt();\n                if (map.containsKey(a)) {\n                    map.put(a, map.get(a) + b);\n                } else {\n                    map.put(a, b);\n                }\n            }\n            Set<Long> set = map.keySet();\n            int sum = 0;\n            for (long x : set) {\n                sum += map.get(x);\n                if (sum >= k) {\n                    out.println(x);\n                    return;\n                }\n            }\n        }\n    }\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n    }\n}",
        "submission_id": "s069878307",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 69,
        "cyclomatic_complexity": 11,
        "branch_factor": 6
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00201",
        "code_tokens": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static int[] price;\n\tpublic static int[] opt;\n\tpublic static Map<String, Integer> ref;\n\tpublic static int[][] list;\n\tpublic static boolean[] mark;\n\tpublic static int get(int k){\n\t\tif(opt[k]!=Integer.MAX_VALUE){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k];\n\t\t}\n\t\tif(mark[k]){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k] = price[k];\n\t\t}\n\t\tmark[k] = true;\n\t\tif(list[k].length==0){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k] = price[k];\n\t\t}\n\t\tint p = 0;\n\t\tfor(int i=0;i<list[k].length;i++){\n\t\t\tp += get(list[k][i]);\n\t\t}\n\t\tmark[k] = false;\n\t\treturn opt[k] = p;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tprice = new int[n];\n\t\t\topt = new int[n];\n\t\t\tlist = new int[n][0];\n\t\t\tmark = new boolean[n];\n\t\t\tArrays.fill(opt, Integer.MAX_VALUE);\n\t\t\tint id = 0;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tref.put(sc.next(), id);\n\t\t\t\tprice[id++] = sc.nextInt();\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tint i = ref.get(sc.next());\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tlist[i] = new int[k];\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tlist[i][j] = ref.get(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)opt[i]=price[i];\n\t\t\tboolean f = true;\n\t\t\twhile(f){\n\t\t\t\tf = false;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(list[i].length!=0){\n\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\tfor(int k=0;k<list[i].length;k++){\n\t\t\t\t\t\t\tp += opt[list[i][k]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(p < opt[i]){\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\topt[i] = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(get(ref.get(sc.next())));\n\t\t}\n\t}\n}",
        "submission_id": "s512799132",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 17,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00118",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.Point;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString str;\nwhile(!(str=br.readLine()).equals(\"0 0\")){\nString[] value=str.split(\" \");\nint h=Integer.parseInt(value[0]);\nint w=Integer.parseInt(value[1]);\nchar[][] fruit=new char[h][w];\nfor(int i=0;i<h;i++){\nfruit[i]=br.readLine().toCharArray();\n}\nDeque<Point> que=new ArrayDeque<Point>();\nint ans=0;\nfor(int m=0;m<h;m++){\nfor(int n=0;n<w;n++){\nif(fruit[m][n]!=','){\nans++;\nPoint p=new Point(n,m);\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint x=p.x;\nint y=p.y;\nchar rem=fruit[y][x];\nfruit[x][y]=',';\nint[] dx={-1,0,1,0};\nint[] dy={0,-1,0,1};\nfor(int i=0;i<dx.length;i++){\nint nx=x+dx[i];\nint ny=y+dy[i];\nif(fruit[ny][nx]==rem&&fruit[ny][nx]!=','&&nx>=0&&nx<w&&ny>=0&&ny<h){\nPoint np=new Point();\nnp.x=nx;\nnp.y=ny;\nque.offerLast(np);\n}\n}\n}\n}\n}\n}\nSystem.out.println(ans);\n}\n}\n}",
        "submission_id": "s323197552",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 52,
        "cyclomatic_complexity": 14,
        "branch_factor": 13
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00741",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\nprivate static int[][]daoyu;\n    public static void main(String[] args) {\n        int count = 0;\n        Scanner input = new Scanner(System.in);\n        while (true) {\n            int x = input.nextInt();\n            int y = input.nextInt();\n            if (x == 0 && y == 0) break;\n            for(int judge_x = 0;judge_x<x;judge_x++) {\n            \tfor(int judge_y = 0;judge_y<y;judge_y++) {\n            \t\tdaoyu[judge_x][judge_y]=input.nextInt();\n            \t\t}\n            }\n        for (int i = 0; i < daoyu.length; i++)\n            for (int j = 0; j < daoyu[i].length; j++)\n                if (daoyu[i][j] == 1) {\n                    count++;\n                    lj(i, j);\n                }\n        System.out.println(count);\n    }\n    }\n    static void lj(int i, int j) {\n        daoyu[i][j] = 2;\n        if (i - 1 >= 0 && daoyu[i - 1][j] == 1)\n            lj(i - 1, j);\n        if (i + 1 < daoyu.length && daoyu[i + 1][j] == 1)\n            lj(i + 1, j);\n        if (j - 1 >= 0 && daoyu[i][j - 1] == 1)\n            lj(i, j - 1);\n        if (j + 1 < daoyu[i].length && daoyu[i][j + 1] == 1)\n            lj(i - 1, j + 1);\n    }\n}",
        "submission_id": "s870244624",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 18,
        "branch_factor": 16
    },{
        "source": "source",
        "lang": "java",
        "problem_id": "p03423",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nclass Main{\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException {\n\t\tFastReader sc = new FastReader();\n\t\tSet<Character> set = new HashSet<>();\n\t\tint n=sc.nextInt();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\tset.add(ch[0]);\n\t\t}\n\t\tSystem.out.println(set.size()==3?\"Three\":\"Four\");\n}\n}",
        "submission_id": "s798613825",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 13,
        "branch_factor": 6
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p02408",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\n\tvoid find(){\n\t\tboolean cards[][] = new boolean[4][13];\n\t\tString markList[] = new String [4];\n\t\tmarkList[0] = \"S\";\n\t\tmarkList[1] = \"H\";\n\t\tmarkList[2] = \"C\";\n\t\tmarkList[3] = \"D\";\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tfor(int i = 0;i<13;i++){\n\t\t\t\tcards[j][i] = false;\n\t\t\t}\n\t\t}\n\t\tScanner s = new Scanner(System.in);\n\t\tint cnt = s.nextInt();\n\t\tfor(int i = 0;i < cnt;i++){\n\t\t\tString mark = s.next();\n\t\t\tint num = s.nextInt();\n\t\t\tSystem.out.println(\"#\" + mark);\n\t\t\tswitch(mark){\n\t\t\tcase \"S\":\n\t\t\t\tcards[0][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"H\":\n\t\t\t\tcards[1][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"C\":\n\t\t\t\tcards[2][num] = true;\n\t\t\t\tbreak;\n\t\t\tcase \"D\":\n\t\t\t\tcards[3][num] = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0;j<4;j++){\n\t\t\tfor(int i = 0;i<13;i++){\n\t\t\t\tif(!cards[j][i]){\n\t\t\t\t\tSystem.out.println(markList[j] + \" \" + (i+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tMain m = new Main();\n\t\tm.find();\n\t}\n}",
        "submission_id": "s284602278",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 50,
        "cyclomatic_complexity": 12,
        "branch_factor": 10
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p03721",
        "code_tokens": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Set;\nimport java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskC {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            TreeMap<Long, Long> map = new TreeMap<>();\n            for (int i = 0; i < n; i++) {\n                long a = in.nextInt();\n                long b = in.nextInt();\n                if (map.containsKey(a)) {\n                    map.put(a, map.get(a) + b);\n                } else {\n                    map.put(a, b);\n                }\n            }\n            Set<Long> set = map.keySet();\n            int sum = 0;\n            for (long x : set) {\n                sum += map.get(x);\n                if (sum >= k) {\n                    out.println(x);\n                    return;\n                }\n            }\n        }\n    }\n    static class InputReader {\n        BufferedReader in;\n        StringTokenizer tok;\n        public String nextString() {\n            while (!tok.hasMoreTokens()) {\n                try {\n                    tok = new StringTokenizer(in.readLine(), \" \");\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n            }\n            return tok.nextToken();\n        }\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n        public InputReader(InputStream inputStream) {\n            in = new BufferedReader(new InputStreamReader(inputStream));\n            tok = new StringTokenizer(\"\");\n        }\n    }\n}",
        "submission_id": "s069878307",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 69,
        "cyclomatic_complexity": 11,
        "branch_factor": 6
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00201",
        "code_tokens": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static int[] price;\n\tpublic static int[] opt;\n\tpublic static Map<String, Integer> ref;\n\tpublic static int[][] list;\n\tpublic static boolean[] mark;\n\tpublic static int get(int k){\n\t\tif(opt[k]!=Integer.MAX_VALUE){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k];\n\t\t}\n\t\tif(mark[k]){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k] = price[k];\n\t\t}\n\t\tmark[k] = true;\n\t\tif(list[k].length==0){\n\t\t\tmark[k] = false;\n\t\t\treturn opt[k] = price[k];\n\t\t}\n\t\tint p = 0;\n\t\tfor(int i=0;i<list[k].length;i++){\n\t\t\tp += get(list[k][i]);\n\t\t}\n\t\tmark[k] = false;\n\t\treturn opt[k] = p;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tprice = new int[n];\n\t\t\topt = new int[n];\n\t\t\tlist = new int[n][0];\n\t\t\tmark = new boolean[n];\n\t\t\tArrays.fill(opt, Integer.MAX_VALUE);\n\t\t\tint id = 0;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tref.put(sc.next(), id);\n\t\t\t\tprice[id++] = sc.nextInt();\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\twhile(m--!=0){\n\t\t\t\tint i = ref.get(sc.next());\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tlist[i] = new int[k];\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tlist[i][j] = ref.get(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)opt[i]=price[i];\n\t\t\tboolean f = true;\n\t\t\twhile(f){\n\t\t\t\tf = false;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(list[i].length!=0){\n\t\t\t\t\t\tint p = 0;\n\t\t\t\t\t\tfor(int k=0;k<list[i].length;k++){\n\t\t\t\t\t\t\tp += opt[list[i][k]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(p < opt[i]){\n\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\topt[i] = p;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(get(ref.get(sc.next())));\n\t\t}\n\t}\n}",
        "submission_id": "s512799132",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 77,
        "cyclomatic_complexity": 17,
        "branch_factor": 15
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00118",
        "code_tokens": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.awt.Point;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\nclass Main{\npublic static void main(String[] args) throws IOException{\nBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\nString str;\nwhile(!(str=br.readLine()).equals(\"0 0\")){\nString[] value=str.split(\" \");\nint h=Integer.parseInt(value[0]);\nint w=Integer.parseInt(value[1]);\nchar[][] fruit=new char[h][w];\nfor(int i=0;i<h;i++){\nfruit[i]=br.readLine().toCharArray();\n}\nDeque<Point> que=new ArrayDeque<Point>();\nint ans=0;\nfor(int m=0;m<h;m++){\nfor(int n=0;n<w;n++){\nif(fruit[m][n]!=','){\nans++;\nPoint p=new Point(n,m);\nque.offerLast(p);\nwhile(que.peekFirst()!=null){\np=que.pollFirst();\nint x=p.x;\nint y=p.y;\nchar rem=fruit[y][x];\nfruit[x][y]=',';\nint[] dx={-1,0,1,0};\nint[] dy={0,-1,0,1};\nfor(int i=0;i<dx.length;i++){\nint nx=x+dx[i];\nint ny=y+dy[i];\nif(fruit[ny][nx]==rem&&fruit[ny][nx]!=','&&nx>=0&&nx<w&&ny>=0&&ny<h){\nPoint np=new Point();\nnp.x=nx;\nnp.y=ny;\nque.offerLast(np);\n}\n}\n}\n}\n}\n}\nSystem.out.println(ans);\n}\n}\n}",
        "submission_id": "s323197552",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 52,
        "cyclomatic_complexity": 14,
        "branch_factor": 13
    },
    {
        "source": "source",
        "lang": "java",
        "problem_id": "p00741",
        "code_tokens": "import java.util.Scanner;\npublic class Main {\nprivate static int[][]daoyu;\n    public static void main(String[] args) {\n        int count = 0;\n        Scanner input = new Scanner(System.in);\n        while (true) {\n            int x = input.nextInt();\n            int y = input.nextInt();\n            if (x == 0 && y == 0) break;\n            for(int judge_x = 0;judge_x<x;judge_x++) {\n            \tfor(int judge_y = 0;judge_y<y;judge_y++) {\n            \t\tdaoyu[judge_x][judge_y]=input.nextInt();\n            \t\t}\n            }\n        for (int i = 0; i < daoyu.length; i++)\n            for (int j = 0; j < daoyu[i].length; j++)\n                if (daoyu[i][j] == 1) {\n                    count++;\n                    lj(i, j);\n                }\n        System.out.println(count);\n    }\n    }\n    static void lj(int i, int j) {\n        daoyu[i][j] = 2;\n        if (i - 1 >= 0 && daoyu[i - 1][j] == 1)\n            lj(i - 1, j);\n        if (i + 1 < daoyu.length && daoyu[i + 1][j] == 1)\n            lj(i + 1, j);\n        if (j - 1 >= 0 && daoyu[i][j - 1] == 1)\n            lj(i, j - 1);\n        if (j + 1 < daoyu[i].length && daoyu[i][j + 1] == 1)\n            lj(i - 1, j + 1);\n    }\n}",
        "submission_id": "s870244624",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 18,
        "branch_factor": 16
    }
]
