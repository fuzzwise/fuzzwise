[
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02762",
        "code_tokens": "import queue\nimport sys\nimport numpy\ninput = sys.stdin.readline\ndef main():\n    n,m,k=map(int,input().split())\n    root=numpy.array([numpy.zeros(n) for i in range(n)])\n    for i in range(n):\n        root[i][i]=2\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    for i in range(k):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=-100\n        root[b-1][a-1]=-100\n    toVis=queue.Queue()\n    Visted=[]\n    checkOK=numpy.zeros(n)\n    OK={}\n    checkVis=numpy.zeros(n)\n    checkVinit=numpy.zeros(n)\n    for i in range(n):\n        if checkOK[i]==5:\n            continue\n        checkVis=checkVinit\n        Visted=[i]\n        checkVis[i]=5\n        toVis=queue.Queue()\n        for j in range(len(root[i])):\n            nex=root[i][j]          \n            if checkVis[j]!=5 and nex==1:\n                toVis.put(j)\n        while toVis.empty()==False:\n            now=toVis.get()\n            if checkVis[now]==5:\n                continue\n            Visted.append(now)\n            checkVis[now]=5\n            for j in range(n):\n                nex=root[now][j]\n                if nex==1 and checkVis[j]!=5:\n                    toVis.put(j)\n        for j in Visted:\n            OK[j]=Visted\n            checkOK[j]=5\n    ans=[]\n    for i in range(n):\n        num=0\n        for value in OK[i]:\n            if root[i][value]==0:\n                num+=1\n        ans.append(num)\n    print(\" \".join(map(str,ans)))\nif __name__==\"__main__\":\n    main()",
        "submission_id": "s439788579",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 57,
        "cyclomatic_complexity": 19,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02735",
        "code_tokens": "def resolve():\n  H, W = map(int, input().split(\" \"))\n  s = []\n  dp = [[0] * W for i in range(H)]\n  for _ in range(W):\n    s.append([x == \".\" for x in list(input())])\n  for h in range(H):\n    for w in range(W):\n      if h == 0 and w == 0:\n        if not s[0][0]:\n          dp[0][0] = 1\n      elif h == 0:\n        dp[0][w] = dp[0][w-1]\n        if s[0][w-1] and not s[0][w]:\n          dp[0][w] += 1\n      elif w == 0:\n        dp[h][0] = dp[h-1][0]\n        if s[h-1][0] and not s[h][0]:\n          dp[h][0] += 1\n      else:\n        temp_up = dp[h-1][w]\n        if s[h-1][w] and not s[h][w]:\n          temp_up += 1\n        temp_left = dp[h][w-1]\n        if s[h][w-1] and not s[h][w]:\n          temp_left += 1\n        dp[h][w] = min(temp_up, temp_left)\n  print(dp[H-1][W-1])\nif __name__ == \"__main__\":\n  resolve()",
        "submission_id": "s788094789",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 30,
        "cyclomatic_complexity": 19,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02616",
        "code_tokens": "import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\ndef resolve():\n    n, k = map(int, input().split())\n    A = list(map(int, input().split()))\n    minus = []\n    plus = []\n    for a in A:\n        if a < 0:\n            minus.append(a)\n        else:\n            plus.append(a)\n    if len(minus) == 0:\n        A.sort(reverse=True)\n        res = 1\n        for i in range(k):\n            res = (res * A[i]) % mod\n        print(res)\n    elif len(plus) == 0:\n        res = 1\n        if k % 2 != 0:\n            A.sort(reverse=True)\n            for i in range(k):\n                res = (res * A[i]) % mod\n        else:\n            A.sort()\n            for i in range(k):\n                res = (res * A[i]) % mod\n        print(res)\n    else:\n        minus.sort()\n        plus.sort(reverse=True)\n        if len(plus) > 1 and len(minus) > 1:\n            dp = [0 for _ in range(k + 1)]\n            dp[0] = 1\n            dp[1] = plus[0] % mod\n            dp[2] = max(minus[0] * minus[1] % mod, plus[0] * plus[1] % mod)\n            for i in range(3, k + 1):\n                if i % 2 != 0:\n                    dp[i] = dp[i - 1] * plus[i] % mod\n                else:\n                    dp[i] = max(dp[i - 1] * plus[i] % mod, dp[i - 2] * minus[i - 1] * minus[i] % mod)\n            print(dp[-1])\n        else:\n            if len(plus) == 1:\n                dp = [0 for _ in range(k + 1)]\n                dp[0] = 1\n                for i in range(1, k + 1):\n                    if i % 2 != 0:\n                        dp[i] = dp[i - 1] * plus[0] % mod\n                    else:\n                        dp[i] = max(dp[i - 2] * minus[i - 1] * minus[i] % mod)\n                print(dp[-1])\n            else:\n                res = 1\n                for i in range(k):\n                    res = (res * plus[i]) % mod\n                print(res)\nif __name__ == '__main__':\n    resolve()",
        "submission_id": "s788901852",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 63,
        "cyclomatic_complexity": 19,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02761",
        "code_tokens": "N, M = map(int, input().split())\ns = []\nc = []\nnum = [0] * N\ndef judge():\n    for i in range(M):\n        s1, c1 = map(int, input().split())\n        s.append(s1)\n        c.append(c1)\n    for i in range(M):\n        for j in range(M):\n            if s[i] == s[j] and i != j and c[i] != c[j]:\n                print(-1)\n                return\n    if N == 3:        \n        for i in range(M):\n            if s[i] - 1 < 0 or s[i] - 1 > 2:\n                print(-1)\n                return\n            num[s[i] - 1] = c[i]\n    elif N == 2:\n        for i in range(M):\n            if s[i] < 1 or s[i] > 2:\n                print(-1)\n                return\n            num[s[i] - 1 + 1] = c[i]\n    else:\n        if s[i] != 2:\n                print(-1)\n                return\n        num[s[i] - 1 + 2] = c[i] \n    if num[0] == 0:\n        if num[1] == 0:\n            if num[2] == 0:\n                print(-1)\n                return\n            print(num[2])\n        print(\"{0}{1}\".format(num[1], num[2]))\n        return\n    else:\n        print(\"{0}{1}{2}\".format(num[0], num[1], num[2]))\n        return\njudge()",
        "submission_id": "s478944179",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 43,
        "cyclomatic_complexity": 19,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03704",
        "code_tokens": "def solve(D):\n  leading_zeros = 0\n  while D[-1] == 0:\n    D.pop()\n    leading_zeros += 1\n  r = 1\n  if len(D) >= 2:\n    h,t = D.popleft(), D.pop()\n    c = h + t\n    if not D:\n      r = t - (leading_zeros == 0) if c == 9 else 0\n    elif 9 <= c <= 10:\n      r = t - (leading_zeros == 0)\n      c -= 10\n      D[0] += c*10\n      D[-1] += 1\n      i = len(D)-1\n      while i > 0 and D[i] == 10:\n        D[i] = 0\n        D[i-1] += 1\n        i -= 1\n  while len(D) > 2:\n    h,t = D.popleft(), D.pop()\n    c = h + t\n    if -1 <= c <= 0:\n      r *= 10-t\n      D[0] += c*10\n    elif 9 <= c <= 10:\n      r *= t\n      c -= 10\n      D[0] += c*10\n      D[-1] += 1\n      i = len(D)-1\n      while i > 0 and D[i] == 10:\n        D[i] = 0\n        D[i-1] += 1\n        i -= 1\n    else:\n      r = 0\n      D.clear()\n  if len(D) == 2:\n    h,t = D.popleft(), D.pop()\n    c = h + t\n    if c == 0:\n      r *= 10 - t\n    elif c == 9:\n      r *= t\n    else:\n      r = 0\n  if len(D) == 1:\n    r *= 10 if D[0] == 0 else 0\n  if r != 0 and leading_zeros > 0:\n    r *= 9\n    r *= 10**(leading_zeros-1)\n  return r\nfrom collections import deque\nfrom random import randint\nD = deque(map(int,input()))\nr = solve(D.copy())\nQ = D.copy()\nfor d in D:\n  Q.appendleft(0)\n  temp = solve(Q.copy())\n  r += temp\nif r == 0:\n  Q = D.copy()\n  for d in D:\n    Q.append(0)\n    r = solve(Q.copy())\n    if r != 0:\n      break\nprint(r)",
        "submission_id": "s675518128",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 72,
        "cyclomatic_complexity": 20,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02586",
        "code_tokens": "import sys\ninput=sys.stdin.readline\ndef main():\n    r,c,k=map(int,input().split())\n    v=dict()\n    for _ in range(k):\n        ri,ci,a=map(int,input().split())\n        ri-=1\n        ci-=1\n        v[(ri,ci)]=a\n    dp=[[[0]*c for _ in range(r)] for i in range(4)]\n    if (0,0) in v:\n        if v[(0,0)]>0:\n            dp[0][0][1]=v[(0,0)]\n    for i in range(r):\n        for j in range(c):\n            if i>0:\n                if (i,j) in v:\n                    if v[(i,j)]>0:\n                        for k in range(min(3,j+1)+1):\n                            dp[1][i][j]=max(dp[1][i][j],dp[k][i-1][j]+v[(i,j)])\n                for k in range(4):\n                    dp[k][i][j]=max(dp[k][i][j],dp[k][i-1][j])\n            if j>0:\n                if (i,j) in v:\n                    if v[(i,j)]>0:\n                        for k in range(min(3,j+1)+1):\n                            if k>0:\n                                dp[k][i][j]=max(dp[k][i][j],dp[k-1][i][j-1]+v[(i,j)])\n                for k in range(4):\n                    dp[k][i][j]=max(dp[k][i][j],dp[k][i][j-1])\n    ans=0\n    for i in range(4):\n        ans=max(dp[i][r-1][c-1],ans)\n    return print(ans)\nif __name__==\"__main__\":\n    main()",
        "submission_id": "s463376387",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 37,
        "cyclomatic_complexity": 20,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03074",
        "code_tokens": "def resolve():\n    N, K = list(map(int, input().split()))\n    S = input()\n    S_small = \"\"\n    cnt = 0\n    for c in S:\n        if c == \"1\":\n            cnt += 1\n        else:\n            if cnt > 0:\n                S_small += str(cnt)\n                cnt = 0\n            S_small += \"0\"\n    if cnt > 0:\n        S_small += str(cnt)\n    S_small = list(S_small)\n    sizes = []\n    opn = False\n    cnt = 0\n    idx = 0\n    start = 0\n    for end, c in enumerate(S_small):\n        if c == \"0\":\n            opn = True\n            cnt += 1\n        else:\n            if opn:\n                cnt += int(c)\n                sizes.append((idx, cnt, start, end))\n                idx += 1\n                cnt = int(c)\n                start = end\n                opn = False\n            else:\n                cnt += int(c)\n    if start != end:\n        sizes.append((idx, cnt, start, None))\n    if sizes == []:\n        print(N)\n        return\n    maxidx, maxcnt, _, __ = max(sizes, key=lambda x: x[1])\n    leftidx = maxidx - 1 if maxidx > 0 else None\n    rightidx = maxidx + 1 if maxidx < len(sizes)-1 else None\n    ans = maxcnt\n    for j in range(K-1):\n        if leftidx is not None and leftidx >= 0:\n            _, leftcnt, left_leftidx, left_rightidx = sizes[leftidx]\n            left_leftedge, left_rightedge = int(S_small[left_leftidx]), int(S_small[left_rightidx])\n            leftdiff = leftcnt - left_rightedge\n        else:\n            leftdiff = 0\n        if rightidx is not None and rightidx <= len(sizes)-1:\n            _, rightcnt, right_leftidx, right_rightidx = sizes[leftidx]\n            right_leftedge, right_rightedge = int(S_small[right_leftidx]), int(S_small(right_rightidx))\n            rightdiff = rightcnt - right_leftedge\n        else:\n            rightdiff = 0\n        if leftidx < 0 and rightidx > len(sizes)-1:\n            break\n        if rightdiff < leftdiff:\n            ans += leftdiff\n            leftidx -= 1\n        else:\n            ans += rightdiff\n            rightidx += 1\n    print(ans)\nif '__main__' == __name__:\n    resolve()",
        "submission_id": "s838255404",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 68,
        "cyclomatic_complexity": 20,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p04045",
        "code_tokens": "n, k = map( int, input().split())\nhate = set( input().split())\nusable = sorted( list( {str(i) for i in range(10)} - hate))\nl = len(str(n))\ndef check(l):\n    num = []\n    if l == 1:\n        for i in usable:\n            num.append(i)\n    if l == 2:\n        for ii in usable:\n            for i in usable:\n                num.append(int( str(ii) + str(i)))\n    elif l == 3:\n        for iii in usable:\n            for ii in usable:\n                for i in usable:\n                    num.append(int( str(iii) + str(ii) + str(i)))\n    elif l == 4:\n        for iv in usable:\n            for iii in usable:\n                for ii in usable:\n                    for i in usable:\n                        num.append(int( str(iv) + str(iii) + str(ii) + str(i)))\n    else:\n        for v in usable:\n            for iv in usable:\n                for iii in usable:\n                    for ii in usable:\n                        for i in usable:\n                            num.append(int( str(v) + str(iv) + str(iii) + str(ii) + str(i)))\n    return num\ntruf = False\nnum = check(l)\nfor i in num:\n    if n <= i:\n        print(i)\n        truf = True\n        break\nif not truf:\n    num = check(l+1)\n    for i in num:\n        if n <= i:\n            print(i)\n            break",
        "submission_id": "s523848461",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 45,
        "cyclomatic_complexity": 20,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02585",
        "code_tokens": "import sys\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nsys.setrecursionlimit(10**7)\nINF = 1 << 100\ndef run():\n    N, K = map(int, sysread().split())\n    P = list(map(int, sysread().split()))\n    C = list(map(int, sysread().split()))\n    P = [p-1 for p in P]\n    loops = []\n    checked = [0] * N\n    loop = [0]\n    for i in range(N):\n        current = i\n        while True:\n            if not checked[current]:\n                checked[current] = 1\n                loop.append(C[current])\n                current = P[current]\n            else:\n                if len(loop) == 1:break\n                loops.append(loop)\n                loop = [0]\n                break\n    loopSums = []\n    for loop in loops:\n        val = 0\n        tmp = []\n        for l in loop:\n            val += l\n            tmp.append(val)\n        loopSums.append(tmp)\n    ans = -INF\n    for loop, loopSum in zip(loops, loopSums):\n        for i in range(1, len(loop)):\n            val = 0\n            if loopSum[-1] <= 0 or len(loop)-1 > K:\n                j = i\n                max_val = -INF\n                iter = 0\n                done = False\n                while iter <= K:\n                    if j >= len(loop):j=0\n                    if (i != j and j) or done:\n                        val += loop[j]\n                        max_val = max(val, max_val)\n                    j += 1\n                    if not j ==1:\n                        iter += 1\n                    if done : break\n                    if i == j: done = True\n                ans = max(ans, max_val)\n                continue\n            rest = K\n            rest -= len(loop) - i - 1\n            val += loopSum[-1] - loopSum[i]\n            val += (rest // (len(loop)-1)) * loopSum[-1]\n            rest = rest % (len(loop) - 1)\n            val += max(loopSum[1:rest+1])\n            ans = max(ans, val)\n    print(ans)\nif __name__ == \"__main__\":\n    run()",
        "submission_id": "s542091988",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 64,
        "cyclomatic_complexity": 20,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03575",
        "code_tokens": "line = input().split(\" \")\nN = int(line[0])\nM = int(line[1])\ng = {}\nE = []\nfor _ in range(N):\n    line = input().split(\" \")\n    a = line[0]\n    b = line[1]\n    E.append((a,b))\n    if not a in g:\n        g[a] = []\n    g[a].append(b)\n    if not b in g:\n        g[b] = []\n    g[b].append(a)\ndef judge(a, b):\n    flags = {}\n    for v in g:\n        flags[v] = False\n    q = [a]\n    flags[a] = True\n    while len(q)>0:\n        v = q.pop(0)\n        for u in g[v]:\n            if (v==a and u==b) or (v==b and u==a):\n                continue\n            elif not flags[u]:\n                flags[u] = True\n                q.append(u)\n    ret = True\n    for v in flags:\n        ret = ret and flags[v]\n    return not ret\ncnt = 0\nfor e in E:\n    if judge(e[0],e[1]):\n        cnt += 1\nprint(cnt)",
        "submission_id": "s862944246",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 39,
        "cyclomatic_complexity": 11,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03031",
        "code_tokens": "import sys\ndef dfs(A):\n    global cnt\n    if len(A) == n:\n        ans = [0 for i in range(m)]\n        print(A)\n        for i, a in enumerate(A):\n            if a:\n                for j in range(m):\n                    if i+1 in s[j]:\n                        ans[j] += 1\n        print(ans)\n        for x, y in zip(p, ans):\n            if x != y%2:\n                break\n        else:\n            cnt += 1\n        return\n    for v in range(2):\n        A.append(v)\n        dfs(A)\n        A.pop()\nn, m = map(int, input().split())\ns = [list(map(int, x.split()))[1:]  for x in sys.stdin.readlines()]\np = list(map(int, input().split()))\ncnt = 0\ndfs([])\nprint(cnt)",
        "submission_id": "s388386481",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 28,
        "cyclomatic_complexity": 11,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02703",
        "code_tokens": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nfrom heapq import heappush, heappop\nN,M,S = map(int,readline().split())\nABC = [list(map(int,readline().split())) for _ in range(M)]\nm = map(int,read().split())\nCD = list(zip(m,m))\ngraph = [[] for _ in range(N)]\nfor u,v,a,b in ABC:\n    graph[u-1].append((v-1,a,b))\n    graph[v-1].append((u-1,a,b))\ndef f():\n  INF = 10 ** 18\n  arrive = [False]*n\n  ans = []\n  qq = 2500\n  dist = [[INF] * qq for _ in range(N)]\n  dist[0][min(qq-1,S)] = 0\n  q = [(0,min(qq-1,S),0)]\n  while q:\n      st,ss,v = heappop(q) \n      if dist[v][ss] < st:\n        continue\n      if not arrive[v]:\n        arrive[v] = True\n        ans.append((v,st))\n        if all(arrive):\n          break\n      c,d = CD[v]\n      if ss < qq-1:\n          ns = min(ss + c, qq-1)\n          nt = st + d\n          if dist[v][ns] > nt:\n              dist[v][ns] = nt\n              heappush(q,(nt,ns,v))\n      for nex,g,tt in graph[v]:\n          if ss-g < 0:\n              continue\n          dt = st + tt\n          if dist[nex][ss-g] <= dt:\n              continue\n          dist[nex][ss-g] = dt\n          heappush(q,(dt,ss-g,nex))\n  return ans\nab = f()\nfrom operator import itemgetter\nab = sorted(ab,key=itemgetter(0))\nfor i in range(N-1):\n  print(ab[i][1])",
        "submission_id": "s383353538",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 51,
        "cyclomatic_complexity": 11,
        "number_of_functions": 1
    },
    
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02941",
        "code_tokens": "def main():\n  import sys\n  from heapq import heappush, heappop, heapify\n  _int = int\n  n = _int(input())\n  a = [_int(e) for e in input().split()]\n  b = [_int(e) for e in input().split()]\n  result = 0\n  finished = 0\n  hq = [(-b[i], i) for i in range(n)]\n  heapify(hq)\n  while True:\n    _, i = heappop(hq)\n    if a[i] == b[i]:\n      finished += 1\n      continue\n    if i == 0:\n      j = b[n - 1] + b[1]\n    elif i == n - 1:\n      j = b[n - 2] + b[0]\n    else:\n      j = b[i - 1] + b[i + 1]\n    k = max((hq[0] - b[i]) // j, 1)\n    b[i] -= j * k\n    if a[i] > b[i]:\n      print(-1)\n      sys.exit()\n    result += k\n    if a[i] == b[i]:\n      finished += 1\n      if finished == n:\n        print(result)\n        sys.exit()\n    else:\n      heappush(hq, (-b[i], i))\nmain()",
        "submission_id": "s064244523",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 11,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02610",
        "code_tokens": "import sys\nfrom heapq import heappush, heappop\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef main(N, K, L, R):\n    left = [[] for _ in range(N)]\n    right = [[] for _ in range(N)]\n    score = 0\n    for k, l, r in zip(K, L, R):\n        k -= 1\n        if l < r:\n            score += l\n            right[k].append(r - l)\n        else:\n            score += r\n            left[k].append(l - r)\n    q = []\n    for n, xs in enumerate(left, 1):\n        for x in xs:\n            if len(q) < n:\n                heappush(q, x)\n            else:\n                heappushpop(q, x)\n    score += sum(q)\n    q = []\n    for n, xs in enumerate(right[::-1][1:], 1):\n        for x in xs:\n            if len(q) < n:\n                heappush(q, x)\n            else:\n                heappushpop(q, x)\n    score += sum(q)\n    return score\nT = int(readline())\nfor _ in range(T):\n    N = int(readline())\n    K, L, R = [], [], []\n    for _ in range(N):\n        k, l, r = map(int, readline().split())\n        K.append(k)\n        L.append(l)\n        R.append(r)\n    print(main(N, K, L, R))",
        "submission_id": "s467992560",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 44,
        "cyclomatic_complexity": 11,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03051",
        "code_tokens": "def main():\n    import sys\n    input = sys.stdin.readline\n    mod = 10**9+7\n    N = int(input())\n    A = [int(i) for i in input().split()]\n    cum_xor = [0]\n    for a in A:\n        cum_xor.append(cum_xor[-1] ^ a)\n    print(cum_xor)\n    if cum_xor[-1] != 0:\n        dp = [[0]*2 for i in range(N+1)]\n        X = cum_xor[-1]\n        dp[0][0] = 1\n        for i in range(1, N + 1):  \n            dp[i][0] = dp[i - 1][0] % mod\n            dp[i][1] = dp[i - 1][1] % mod\n            if cum_xor[i] == 0:\n                dp[i][0] += dp[i - 1][1]\n            elif cum_xor[i] == X:\n                dp[i][1] += dp[i-1][0]\n        print(dp[N-1][0] % mod)\n    else:\n        dp = [[1, 0] for i in range(N + 1)]\n        cnt_zero_prev_cumXOR_i = [0] * (1 << 20)\n        cnt_zero_now = 0\n        for i in range(1, N + 1):\n            if cum_xor[i] == 0:\n                cnt_zero_now += 1\n            else:\n                dp[cum_xor[i]][0] += dp[cum_xor[i]][1] * \\\n                    (cnt_zero_now - cnt_zero_prev_cumXOR_i[cum_xor[i]])\n                dp[cum_xor[i]][0] %= mod\n                dp[cum_xor[i]][1] += dp[cum_xor[i]][0]\n                dp[cum_xor[i]][1] %= mod\n                cnt_zero_prev_cumXOR_i[cum_xor[i]] = cnt_zero_now\n        ans = 0\n        for c in set(cum_xor):\n            ans += dp[c][1]\n            ans %= mod\n        ans += 2 ** (cnt_zero_now - 1)\n        print(ans % mod)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s550456406",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 44,
        "cyclomatic_complexity": 12,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03388",
        "code_tokens": "def compute(n1, n2):\n    threshold = n1*n2-1\n    count = 0\n    if n1 == 1:\n        index1 = 2\n    else:\n        index1 = 1\n    index2 = threshold\n    list1, list2 = [], []\n    while index1 < index2:\n        index2 = int(threshold/index1)\n        while index2 in list2 or index2 == n2:\n            index2 -= 1\n        count+=1\n        index1 += 1\n        if index1 == n1:\n            index1+=1\n    while not (index2 == 1 or (n2 == 1 and index2==2)):\n        index1 = int(threshold)/index2\n        while index1 in list1 or index1 == n1:\n            index1 += 1\n        count+=1\n        index2 -=1\n        if index2 == n2:\n            index2 -=1\n    print(count)\n    return\nN = int(input().strip())\ngrid = []\nfor i in range(N):\n    array = list(map(int, input().strip().split(' ')))\n    grid.append(array)\nfor i in grid:\n    compute(i[0],i[1])",
        "submission_id": "s992658572",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 34,
        "cyclomatic_complexity": 12,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03722",
        "code_tokens": "def main():\n    [N, M] = [int(i) for i in input().split()]\n    E = []\n    for i in range(M):\n        E.append([int(i) for i in input().split()])\n    dist = [-1*10**100 for i in range(N)]\n    dist[0] = 0\n    for i in range(N):\n        for [a, b, c] in E:\n            newLen = dist[a-1] + c\n            if newLen > dist[b-1]:\n                dist[b-1] = newLen\n    dist2 = dist.copy()\n    for i in range(N):\n        for [a, b, c] in E:\n            newLen = dist[a-1] + c\n            if newLen > dist[b-1]:\n                dist2[b-1] = newLen\n    if dist != dist2:\n        print('inf')\n    else:\n        print(dist[N-1])\nif __name__ == '__main__':\n    main()",
        "submission_id": "s772523439",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 24,
        "cyclomatic_complexity": 12,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03263",
        "code_tokens": "import sys\nimport numpy as np\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nin_n = lambda: int(readline())\nin_nn = lambda: map(int, readline().split())\nin_nl = lambda: list(map(int, readline().split()))\nin_na = lambda: map(int, read().split())\nin_s = lambda: readline().rstrip().decode('utf-8')\ndef main():\n    H, W = in_nn()\n    a = np.array(read().split(), np.int32).reshape((H, W))\n    odd_count = np.count_nonzero(a % 2 == 1)\n    if odd_count % 2 == 1:\n        odd_count -= 1\n    count = 0\n    x, y = 0, 0\n    px, py = -1, -1\n    odd_f = False\n    ans = []\n    while True:\n        if odd_f:\n            ans.append((py + 1, px + 1, y + 1, x + 1))\n            if a[y][x] % 2 == 1:\n                odd_f = False\n        else:\n            if a[y][x] % 2 == 1:\n                odd_f = True\n        px, py = x, y\n        if a[y][x] % 2 == 1:\n            count += 1\n            if count >= odd_count:\n                break\n        if y % 2 == 0:\n            if x == W - 1:\n                y += 1\n            else:\n                x += 1\n        else:\n            if x == 0:\n                y += 1\n            else:\n                x -= 1\n    print(len(ans))\n    for a in ans:\n        print(*a)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s147365651",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 48,
        "cyclomatic_complexity": 12,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03007",
        "code_tokens": "import itertools\nfrom collections import Counter\nfrom collections import defaultdict\nimport bisect\nfrom heapq import heappush, heappop\nfrom collections import deque\ndef main():\n    N = int(input())\n    A = list(map(int, input().split()))\n    A.sort()\n    index = bisect.bisect_left(A, 0)\n    minus = deque(A[:index])\n    plus = deque(A[index:])\n    progres = []\n    ans = 0\n    while True:\n        if len(plus) == 1 and len(minus) == 1:\n            p = plus.pop()\n            m = minus.pop()\n            progres.append((p, m))\n            ans = p - m\n            break\n        if len(plus) == 1 and len(minus) == 0:\n            ans = plus.pop()\n            break\n        if len(plus) == 0 and len(minus) == 1:\n            ans = minus.pop()\n            break\n        if len(plus) == 0:\n            val1 = minus.popleft()\n            val2 = minus.pop()\n            new_val = val1 - val2\n            plus.append(new_val)\n            progres.append((val1, val2))\n            continue\n        if len(minus) == 0:\n            val1 = plus.popleft()\n            val2 = plus.pop()\n            new_val = val1 - val2\n            minus.append(new_val)\n            progres.append((val1, val2))\n            continue\n        if len(plus) > len(minus):\n            val1 = plus.pop()\n            val2 = minus.popleft()\n            new_val = val2 - val1\n            progres.append((val2, val1))\n            index = bisect.bisect_left(minus, new_val)\n            minus.insert(index, new_val)\n        else:\n            print('b')\n            val1 = plus.pop()\n            val2 = minus.popleft()\n            new_val = val1 - val2\n            progres.append((val1, val2))\n            index = bisect.bisect_left(plus, new_val)\n            plus.insert(index, new_val)\n    print(ans)\n    for p, q in progres:\n        print('{} {}'.format(p, q))\nif __name__ == '__main__':\n    main()",
        "submission_id": "s971067295",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 62,
        "cyclomatic_complexity": 12,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03013",
        "code_tokens": "import sys\nsys.stdin.readline\ndef fibo(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        if n not in stars and n-1 not in stars and n-2 not in stars:\n            return fibo(n-1) + fibo(n-2)\n        elif n not in stars and n-1 not in stars and n-2 in stars:\n            return fibo(n-1)\n        elif n not in stars and n-1 in stars and n-2 not in stars:\n            return fibo(n-2)\n        elif n in stars:\n            return 0\n        else:\n            print(0)\n            sys.exit()\nN, M = map(int, input().split())\nstars = []\nfor i in range(M):\n    a = int(input())\n    stars.append(a)\nprint(fibo(N) % 1000000007)",
        "submission_id": "s156175159",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 25,
        "cyclomatic_complexity": 13,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02835",
        "code_tokens": "def main():\n    h,w=map(int,input().split())\n    L=80*(h+w)+1\n    a=[list(map(int,input().split())) for i in range(h)]\n    b=[list(map(int,input().split())) for i in range(h)]\n    x=[[abs(a[i][j]-b[i][j]) for j in range(w)] for i in range(h)]\n    L=12800\n    state=[[0 for j in range(w)] for i in range(h)]\n    delta=x[0][0]\n    state[0][0]=(2**L>>delta)|(2**L<<delta)\n    for j in range(1,w):\n        delta=x[0][j-1]\n        state[0][j]=(state[0][j-1]>>delta)|(state[0][j-1]<<delta)\n    for i in range(1,h):\n        delta=x[i-1][0]\n        state[i][0]=(state[i-1][0]>>delta)|(state[i-1][0]<<delta)\n    for i in range(1,h):\n        for j in range(1,w):\n            delta=x[i][j]\n            state[i][j]=(state[i][j-1]>>delta)|(state[i][j-1]<<delta)\n            state[i][j]=(state[i-1][j]>>delta)|(state[i-1][j]<<delta)\n    ans = 10**9\n    for i in range(L*2):\n        if state[h-1][w-1] & 1:\n            ans = min(ans,abs(i-L))\n        state[h-1][w-1]>>=1\n    print(ans-1)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s701618293",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 29,
        "cyclomatic_complexity": 13,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03525",
        "code_tokens": "from itertools import product, combinations\nfrom collections import Counter\ndef solve():\n    N = int(input())\n    *D, = map(int, input().split())\n    l, m = [], []\n    for i, j in Counter(D).items():\n        if j>=3 or (i==12 and j>=2) or i==0:\n            print(0)\n        elif j==2:\n            l += [i]\n        elif j==1:\n            m += [i]\n    size = len(m)\n    ans = 0\n    g = lambda x: min(x, 24-x)\n    for i in product(range(2), repeat=size):\n        c = [m[j] if k else 24-m[j] for j, k in enumerate(i)]\n        f = lambda x, y: g(abs(c[x]-c[y]))\n        for j in l:\n            c.append(j)\n            c.append(24-j)\n        a = min(map(g, c))\n        b = min(f(j, k) for j, k in combinations(range(N), 2))\n        ans = max(ans, min(a, b))\n    print(ans)\nif __name__ == \"__main__\":\n    solve()",
        "submission_id": "s317812647",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 28,
        "cyclomatic_complexity": 13,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03128",
        "code_tokens": "import sys\ninput = sys.stdin.readline\nMATCH_NUM = [-1, 2, 5, 5, 4, 5, 6, 3, 7, 6]\ndef main():\n    N, M = [int(e) for e in input().split()]\n    A = [int(e) for e in input().split()]\n    dp = [-1 for _ in range(N+1)]\n    dp[0] = 0\n    dp[1] = 0\n    for i in range(N+1):\n        for a in A:\n            dp[i] = max(dp[i], dp[i-MATCH_NUM[a]] + 1)\n    max_digit_num = dp[N]\n    A.sort(reverse=True)\n    min_cost = 10\n    for a in A:\n        if MATCH_NUM[a] < min_cost:\n            min_cost = MATCH_NUM[a]\n    res = ''\n    for _ in range(max_digit_num):\n        for a in A:\n            if dp[N-MATCH_NUM[a]] == dp[N]-1:\n                if N-MATCH_NUM[a] <= min_cost and N-MATCH_NUM[a] != 0:\n                    continue\n                res += str(a)\n                N -= MATCH_NUM[a]\n                break\n    print(res)\nmain()",
        "submission_id": "s247573767",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 29,
        "cyclomatic_complexity": 13,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03436",
        "code_tokens": "import sys\nsys.setrecursionlimit(50)\nh,w=map(int,input().split())\ndef go_next(I,J):\n    global dp,w,h\n    if 0<=I<h-1:\n        if x[I+1][J]==\".\" and dp[I+1][J]>dp[I][J]+1:\n            dp[I+1][J]=dp[I][J]+1\n            go_next(I+1,J)\n    if 0<I<=h-1:\n        if x[I-1][J]==\".\" and dp[I-1][J]>dp[I][J]+1:\n            dp[I-1][J]=dp[I][J]+1\n            go_next(I-1,J)\n    if 0<=J<w-1:\n        if x[I][J+1]==\".\" and dp[I][J+1]>dp[I][J]+1:\n            dp[I][J+1]=dp[I][J]+1\n            go_next(I,J+1)\n    if 0<J<=w-1:\n        if x[I][J-1]==\".\" and dp[I][J-1]>dp[I][J]+1:\n            dp[I][J-1]=dp[I][J]+1\n            go_next(I,J-1)\nx=[]\nfor i in range(h):\n    x.append(list(input()))\nc=0\nfor i in range(h):\n    for j in range(w):\n        if x[i][j]==\".\":\n            c+=1\ndp=[[10000000000 for i in range(w)]for j in range(h)]\ndp[0][0]=1\ngo_next(0,0)\nif dp[h-1][w-1]==10000000000:\n    print(-1)\nelse:\n    print(c-dp[h-1][w-1])",
        "submission_id": "s647831267",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 13,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02610",
        "code_tokens": "import sys\niim = lambda: map(int, sys.stdin.readline().rstrip().split())\nfrom heapq import heappush, heappushpop\ndef resolve():\n    rl = sys.stdin.readline\n    T = int(rl())\n    if T == 3: raise 1\n    ans = []\n    for t in range(T):\n        N = int(rl())\n        val = 0\n        a1 = [[] for i in range(N)]\n        a2 = [[] for i in range(N)]\n        for _ in range(N):\n            i, v1, v2 = map(int, rl().split())\n            i -= 1\n            diff = v1 - v2\n            if diff == 0 or i == N-1:\n                val += v1\n            elif diff > 0:\n                a1[i].append(diff)\n                val += v2\n            else:\n                i = N-1-i-1\n                a2[i].append(-diff)\n                val += v1\n        for ax in (a1, a2):\n            dq = []\n            ld = 0\n            for i, aa in enumerate(ax):\n                if not aa: continue\n                for diff in aa:\n                    if ld <= i:\n                        heappush(dq, diff)\n                        ld += 1\n                    else:\n                        heappushpop(dq, diff)\n            val += sum(dq)\n        ans.append(val)\n    print(*ans, sep=\"\\n\")\nif __name__ == \"__main__\":\n    resolve()",
        "submission_id": "s544407776",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 42,
        "cyclomatic_complexity": 14,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03854",
        "code_tokens": "def rec(s):\n  if s == '':\n    return True\n  else:\n    res = False\n    res = res or rec(s[7:]) if len(s) > 6 and s[0:7] == 'dreamer' else res\n    res = res or rec(s[5:]) if len(s) > 4 and s[0:5] == 'dream' else res\n    res = res or rec(s[5:]) if len(s) > 4 and s[0:5] == 'erase' else res\n    res = res or rec(s[6:]) if len(s) > 5 and s[0:6] == 'eraser' else res\n    return res\nprint('YES' if rec(input()) else 'NO')",
        "submission_id": "s745066369",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 11,
        "cyclomatic_complexity": 14,
        "number_of_functions": 1
    },
    
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02761",
        "code_tokens": "import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom functools import reduce\nfrom bisect import bisect_left, insort_left\nfrom heapq import heapify, heappush, heappop\nINPUT = lambda: sys.stdin.readline().rstrip()\nINT = lambda: int(INPUT())\nMAP = lambda: map(int, INPUT().split())\nS_MAP = lambda: map(str, INPUT().split())\nLIST = lambda: list(map(int, INPUT().split()))\nS_LIST = lambda: list(map(str, INPUT().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\ndef main():\n    N, M = MAP()\n    m = N\n    l = [10] * N\n    for i in range(M):\n        s, c = MAP()\n        if l[s-1] == 10:\n            l[s-1] = c\n            m = s - 1 if s-1 < m else m\n        else:\n            if c != l[s-1]:\n                print(-1)\n                sys.exit()\n    if N == 1 and l[0] == 0:\n        print(0)\n        sys.exit()\n    ans = \"\"\n    if not len(l) == N-m and l[m] == 0: ans += \"1\"\n    for i in range(N-m):\n        ans += str(l[i+m] % 10)\n    print(ans)\n    flag = False\n    for i in range(N-m):\n        if not int(ans[i]) == 0:\n            flag = True\n        if not flag and int(ans[i]) == 0:\n            print(-1)\n            sys.exit()\n    print(ans)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s033494930",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 50,
        "cyclomatic_complexity": 14,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02610",
        "code_tokens": "import sys\niim = lambda: map(int, sys.stdin.readline().rstrip().split())\nfrom heapq import heappush, heappushpop\ndef resolve():\n    rl = sys.stdin.readline\n    T = int(rl())\n    if T == 3: raise 1\n    ans = [0] * T\n    for t in range(T):\n        N = int(rl())\n        val = 0\n        a1 = [[] for i in range(N)]\n        a2 = [[] for i in range(N)]\n        for _ in range(N):\n            i, v1, v2 = map(int, rl().split())\n            i -= 1\n            diff = v1 - v2\n            if diff == 0 or i == N-1:\n                val += v1\n            elif diff > 0:\n                a1[i].append(diff)\n                val += v2\n            else:\n                i = N-1-i-1\n                a2[i].append(-diff)\n                val += v1\n        for ax in (a1, a2):\n            dq = []\n            for i, aa in enumerate(ax):\n                if not aa: continue\n                for diff in aa:\n                    ld = len(dq)\n                    if ld <= i:\n                        heappush(dq, diff)\n                        val += diff\n                    else:\n                        df = heappushpop(dq, diff)\n                        val += diff - df\n        ans[t] = val\n    print(*ans, sep=\"\\n\")\nif __name__ == \"__main__\":\n    resolve()",
        "submission_id": "s991347191",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 42,
        "cyclomatic_complexity": 14,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02527",
        "code_tokens": "import random\ndef qui(l):\n    num = len(l)\n    if num <= 1:\n        return l\n    piv = random.randrange(0,len(l))\n    piv2 = random.randrange(0,len(l))\n    piv3 = random.randrange(0,len(l))\n    if (l[piv] > l[piv2]) and (l[piv2] > l[piv3]):\n        piv = piv2\n    elif (l[piv] > l[piv3]) and (l[piv3] > l[piv2]):\n        piv = piv3\n    elif (l[piv] < l[piv2]) and (l[piv2] < l[piv3]):\n        piv = piv2\n    elif (l[piv] < l[piv3]) and (l[piv3] < l[piv2]):\n        piv = piv3\n    else:\n        pass\n    mini = []\n    maxi = []\n    for i in range(0,len(l)):\n        if i == piv:\n            continue\n        elif l[piv] > l[i]:\n            mini.append(l[i])\n        elif l[piv] <= l[i]:\n            maxi.append(l[i])\n    maxi = qui(maxi)\n    return mini+maxi\ninput()\nlist1 = input().split(\" \")\nfor i in range(0, len(list1)):\n    list1[i] = int(list1[i])\nresult = qui(list1)\nprint(' '.join(map(str, result)))",
        "submission_id": "s213434024",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 35,
        "cyclomatic_complexity": 14,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02623",
        "code_tokens": "def main():\n    n, m, k = [int(e) for e in input().split()]\n    A = [int(e) for e in input().split()]\n    B = [int(e) for e in input().split()]\n    t = 0\n    ca, cb = 0, 0\n    for a in A:\n        t += a\n        if t > k:\n            t -= a\n            break\n        ca += 1\n    while True:\n        t += B[cb]\n        cb += 1\n        if t > k:\n            cb -= 1\n            t -= B[cb]\n            break\n        if cb == len(B):\n            break\n    AA = [ca + cb]\n    while True:\n        if ca == 0 or cb == len(B):\n            break\n        ca -= 1\n        t -= A[ca]\n        while True:\n            t += B[cb]\n            if t > k or cb == len(B):\n                break\n            cb += 1\n        AA.append(ca + cb)\n    print(max(AA))\nif __name__ == '__main__':\n    main()",
        "submission_id": "s955600815",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 36,
        "cyclomatic_complexity": 15,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03242",
        "code_tokens": "def cal(n,v):\n    k=n//2\n    even=range(0,2*k,2)\n    odd=range(1,2*k+1,2)\n    el=[]\n    for i in even:\n        el.append(v[i])\n    ol=[]\n    for i in odd:\n        ol.append(v[i])\n    d={}\n    for i in el:\n        if((i in d) is False):\n            d[i]=0\n        else:\n            d[i]+=1\n    f={}\n    for i in ol:\n        if((i in f) is False):\n            f[i]=0\n        else:\n            f[i]+=1\n    while(True):\n        e = max(d, key=d.get)\n        o = max(f, key=f.get)\n        if(e==o):\n            if(d[e]>f[e]):\n                del f[e]\n            elif(d[e]<f[e]):\n                del d[e]\n            else:\n                return print(k)\n        else:\n            break\n    sum=0\n    for i in el:\n        if(i!=e):\n            sum+=1\n    for i in ol:\n        if(i!=o):\n            sum+=1\n    return print(sum)\nn=int(input())\nv=list(map(int,input().split()))\ncal(n,v)",
        "submission_id": "s000104816",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 45,
        "cyclomatic_complexity": 15,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02817",
        "code_tokens": "N,K=map(int, input().split()) \nR,S,P=map(int, input().split()) \nT=input()\nSC=0\ndef MaxScore(n,t):\n    SC = 0\n    if t[0]=='r':\n        SC+=P\n    elif t[0]=='s':\n        SC+=R\n    else:\n        SC+=S\n    NC=1\n    for i in range(1,n):\n        if t[i]=='r':\n            if t[i]!=t[i-1]:\n                SC+=P\n                NC=1\n            elif t[i]==t[i-1] and NC%2==0:\n                SC+=P\n                NC+=1\n            else:\n                NC+=1\n        elif t[i]=='s':\n            if t[i]!=t[i-1]:\n                SC+=R\n                NC=1\n            elif t[i]==t[i-1] and NC%2==0:\n                SC+=R\n                NC+=1\n            else:\n                NC+=1\n        else:\n            if t[i]!=t[i-1]:\n                SC+=S\n                NC=1\n            elif t[i]==t[i-1] and NC%2==0:\n                SC+=S\n                NC+=1\n            else:\n                NC+=1\n    return SC\nfor i in range(K):\n    Ti=[T[j] for j in range(N) if j%K==i]\n    Ti=''.join(Ti)\n    if (N-i)%K==0:\n        Ni=(N-i)//K\n    else:\n        Ni=(N-i)//K+1\n    SCi=MaxScore(Ni,Ti)\n    SC+=SCi\nprint(SC)         ",
        "submission_id": "s648958764",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 52,
        "cyclomatic_complexity": 15,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02675",
        "code_tokens": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
        "submission_id": "s567578812",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 39,
        "cyclomatic_complexity": 15,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03450",
        "code_tokens": "def sol():\n    n,m=map(int,input().split())\n    w={}\n    p,q=set(),set()\n    for i in range(m):\n        l,r,d=[int(i) for i in input().split()]\n        if l in w:\n            w[l].add((r,d))\n        else:\n            w[l]={(r,d)}\n        p.add(l)\n        q.add(r)\n    s=p-q\n    for i in s:\n        k={j for j in w[i]}\n        g=set()\n        cnt=0\n        while len(k):\n            x=k.pop()\n            cnt+=1\n            if cnt==5000:\n                print(p[100])\n            if x[0] not in w:\n                g.add(x)\n            else:\n                for j in w[x[0]]:\n                    k.add((j[0],j[1]+x[1]))\n        y=set()\n        for j in g:\n            if j[0] in y or j[0]==i:\n                print(\"No\")\n                exit()\n            else:\n                y.add(j[0])\n    print(\"Yes\" if len(s) or m==0 else \"No\")\nif __name__==\"__main__\":\n    sol()",
        "submission_id": "s446416521",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 37,
        "cyclomatic_complexity": 15,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03854",
        "code_tokens": "def checks(s) :\n\tret = 'NO'\n\tif len(s) < 5 :\n\t\treturn 'NO'\n\telif( s[0] == 'd' ) :\n\t\tif s[:5] == 'dream' :\n\t\t\tif len(s) != 5 :\n\t\t\t\tret = checks(s[5:])\n\t\t\telse :\n\t\t\t\treturn 'YES'\n\t\tif ( len(s) > 6 ) and ( ret != 'YES' ) and (s[:7] == 'dreamer') :\n\t\t\tif len(s) != 7 :\n\t\t\t\tret = checks(s[7:])\n\t\t\telse :\n\t\t\t\treturn 'YES'\n\telif( s[0] == 'e' ) :\n\t\tif s[:5] == 'erase' :\n\t\t\tif len(s) != 5 :\n\t\t\t\tret = checks(s[5:])\n\t\t\telse :\n\t\t\t\treturn 'YES'\n\t\tif ( len(s) > 5 ) and ( ret != 'YES' ) and ( s[:6] == 'eraser' ) :\n\t\t\tif len(s) != 6 :\n\t\t\t\tret = checks(s[6:])\n\t\t\telse :\n\t\t\t\treturn 'YES'\n\treturn ret\nS = input()\nprint(checks(S))",
        "submission_id": "s103406623",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 29,
        "cyclomatic_complexity": 16,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02975",
        "code_tokens": "import sys\ninput = sys.stdin.readline\ndef main():\n    n = int(input())\n    a_list = [int(i) for i in input().split()]\n    kind = set(a_list)\n    if len(kind) not in (1, 2, 3):\n        print(\"No\")\n        return\n    if len(kind) == 1 and 0 in kind:\n        print(\"Yes\")\n        return\n    elif len(kind) == 3:\n        if n % 3 != 0 or len(set([a_list.count(k) for k in kind])) != 1:\n            print(\"No\")\n            return\n        kind = list(kind)\n    else:\n        a, b = kind\n        a_c, b_c = a_list.count(a), a_list.count(b)\n        if 0 not in kind or abs(a_c - b_c) > 1:\n            print(\"No\")\n            return\n        if a == 0:\n            if a_c > b_c:\n                print(\"No\")\n                return\n            kind = [b, a, b]\n        else:\n            if b_c > a_c:\n                print(\"No\")\n                return\n            kind = [a, b, a]\n    kind.extend([kind[0], kind[-1]])\n    for i in range(3):\n        if kind[i] != kind[i - 1] ^ kind[i + 1]:\n            print(\"No\")\n            return\n    print(\"Yes\")\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s974277085",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 41,
        "cyclomatic_complexity": 16,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02721",
        "code_tokens": "common = []\ndef bool_work(s, n, k, c):\n    i = 0\n    while s[i] == 'o':\n        if i+c+1 < n:\n            j = 1\n            if s[j] == 'x':\n                while s[j] == 'x':\n                    j += 1\n            wo_i = bool_work(s[j:], n - j, k, c)\n            if j < i+c+1:\n                j = i+c+1\n                if s[j] == 'x':\n                    while s[j] == 'x':\n                        j += 1\n            w_i = bool_work(s[j:], n - j, k - 1, c)\n            if wo_i == 0 and w_i == 1:\n                common.append(i)\n                return 1\n            if wo_i + w_i >= 2:\n                return 2\n            else:\n                return wo_i + w_i\n        elif i+c+1 >= n:\n            if k > 1:\n                return 0\n            elif n == 1:\n                return 1\n            else:\n                for char in s[1:]:\n                    if char == 'o':\n                        return 2\n                return 1\nn, k, c = map(int, input().split())\ns = input()\nwhile s[-1] == 'x':\n    s.pop(-1)\nbool_work(s, n, k, c)\nfor com in common:\n    print(com)",
        "submission_id": "s651886210",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 40,
        "cyclomatic_complexity": 16,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02803",
        "code_tokens": "from collections import deque\nH, W = map(int, input().split())\nS = [input() for _ in range(H)]\nfor i in range(H):\n    j = S[i].find(\".\")\n    if j >= 0:\n        break\ndef bfs(s, t):\n    dist = [[None] * W for _ in range(H)]\n    que = deque([(s, t)])\n    dist[s][t] = 0\n    while que:\n        u, v = que.popleft()\n        d = dist[u][v]\n        G = []\n        if u > 0 and S[u-1][v] == \".\":\n            G.append((u-1, v))\n        if u < H - 1 and S[u+1][v] == \".\":\n            G.append((u+1, v))\n        if v > 0 and S[u][v-1] == \".\":\n            G.append((u, v-1))\n        if v < W - 1 and S[u][v+1] == \".\":\n            G.append((u, v+1))\n        for w, x in G:\n            if dist[w][x] is not None:\n                continue\n            dist[w][x] = d + 1\n            que.append((w, x))\n    return max(max((d, (i, j)) for j, d in enumerate(di) if d is not None) for i, di in enumerate(dist))\n_, (u, v) = bfs(i, j)\nd, _ = bfs(u, v)\nprint(d)",
        "submission_id": "s080332941",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 32,
        "cyclomatic_complexity": 16,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02692",
        "code_tokens": "N,A,B,C = map(int,input().split())\nimport sys\ns = []\nfor i in range(N):\n    S = input()\n    s.append(S)\ndef dfs(dep,A,B,C):\n    if dep == N:\n        return []\n    if s[dep] == \"AB\":\n        if A == B == 0:\n            return None\n        elif A > B:\n            cat = dfs(dep+1,A-1,B+1,C)\n            if cat != None:\n                cat.append(\"B\")\n                return cat\n        else:\n            cat = dfs(dep+1,A+1,B-1,C)\n            if cat != None:\n                cat.append(\"A\")\n                return cat\n    elif s[dep] == \"BC\":\n        if B == C == 0:\n            return None\n        elif B > C:\n            cat = dfs(dep+1,A,B-1,C+1)\n            if cat != None:\n                cat.append(\"C\")\n                return cat\n        else:\n            cat = dfs(dep+1,A,B+1,C-1)\n            if cat != None:\n                cat.append(\"B\")\n                return cat\n    else:\n        if A == C == 0:\n            return None\n        elif A > C:\n            cat = dfs(dep+1,A-1,B,C+1)\n            if cat != None:\n                cat.append(\"C\")\n                return cat\n        else:\n            cat = dfs(dep+1,A+1,B+1,C-1)\n            if cat != None:\n                cat.append(\"A\")\n                return cat\n    return None\nrev = dfs(0,A,B,C)\nif rev == None:\n    print (\"No\")\nelse:\n    print (\"Yes\")\n    for i in range(N-1,-1,-1):\n        print (rev[i])",
        "submission_id": "s889576817",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 56,
        "cyclomatic_complexity": 16,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02961",
        "code_tokens": "def solve(x,y,k):\n    if x==y==0: return []\n    if x+y>=2*k and x>=k: return [(k,0)]+solve(x-k,y,k)\n    if x+y>=2*k and y>=k: return [(0,k)]+solve(x,y-k,k)\n    if x<0: return [(-x,y) for x,y in solve(-x,y,k)]\n    if y<0: return [(x,-y) for x,y in solve(x,-y,k)]\n    if x>y: return [(x,y) for y,x in solve(y,x,k)]\n    if x+y<K and (x+y)%2==1: return solve(x,y+k,k)+[(0,-k)]\n    if K&1 and x+y>k and (x+y)%k%2==0: return solve(x,y-k,k)+[(0,k)]\n    z=(x+y)//2\n    return [(k-z+x,z-x),(z-k,z)]\nK,X,Y=map(int, open(0).read().split())\nif K%2==0 and (X+Y)%2==1:\n    print(-1)\nelse:\n    ans=solve(X,Y,K)\n    print(len(ans))\n    ax,ay=0,0\n    for x,y in ans:\n        ax+=x\n        ay+=y\n        print(ax,ay)",
        "submission_id": "s313470538",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 22,
        "cyclomatic_complexity": 17,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03491",
        "code_tokens": "def main():\n    import sys\n    from collections import defaultdict\n    input = sys.stdin.readline\n    mod = 10**10+7\n    mod2 = 10**10+9\n    mod3 = 998244353\n    N, L = map(int, input().split())\n    dic = defaultdict(int)\n    dic2 = defaultdict(int)\n    dic3 = defaultdict(int)\n    h_list = []\n    h2_list = []\n    h3_list = []\n    pair = {}\n    pair2 = {}\n    pair3 = {}\n    M = 0\n    for _ in range(N):\n        s = input().rstrip('\\n')\n        h = 0\n        h2 = 0\n        h3 = 0\n        for i in range(len(s)):\n            M += 1\n            h = (h*1007 + int(s[i]) + 1) % mod\n            pair[h] = (h + 1)%mod if s[i] == '0' else (h-1)%mod\n            h2 = (h2 * 2009 + int(s[i]) + 1) % mod2\n            pair2[h2] = (h2 + 1)%mod2 if s[i] == '0' else (h2-1)%mod2\n            h3 = (h3 * 3001 + int(s[i]) + 1) % mod3\n            pair3[h3] = (h3 + 1) % mod3 if s[i] == '0' else (h3 - 1) % mod3\n            if dic[h]:\n                assert dic[h] == i+1\n            dic[h] = i+1\n            dic2[h2] = i+1\n            dic[h3] = i+1\n            h_list.append(h)\n            h2_list.append(h2)\n            h3_list.append(h3)\n    g = 0\n    seen = defaultdict(int)\n    seen2 = defaultdict(int)\n    seen3 = defaultdict(int)\n    for i in range(M):\n        s, s2, s3 = h_list[i], h2_list[i], h3_list[i]\n        if seen[s] and seen2[s2] and seen3[s3]:\n            continue\n        t = pair[s]\n        t2 = pair2[s2]\n        t3 = pair3[s3]\n        if dic[t] == 0 or dic2[t2] == 0 or dic3[t3] == 0:\n            p = [dic[s], dic2[s2], dic3[s3]]\n            p.sort()\n            tmp = L - p[1] + 1\n            cnt = 0\n            while tmp % 2 == 0:\n                tmp //= 2\n                cnt += 1\n            g ^= (2**cnt)\n        seen[s] = 1\n        seen2[s2] = 1\n        seen3[s3] = 1\n    if g:\n        print('Alice')\n    else:\n        print('Bob')\nif __name__ == '__main__':\n    main()",
        "submission_id": "s458976358",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 68,
        "cyclomatic_complexity": 17,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02762",
        "code_tokens": "import queue\nimport numpy\ndef main():\n    n,m,k=map(int,input().split())\n    root=numpy.array([[0]*n for i in range(n)])\n    for i in range(n):\n        root[i][i]=2\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    for i in range(k):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=-100\n        root[b-1][a-1]=-100\n    toVis=queue.Queue()\n    Visted=[]\n    checkOK=numpy.zeros(n)\n    OK={}\n    checkVis=numpy.zeros(n)\n    checkVinit=numpy.zeros(n)\n    for i in range(n):\n        if checkOK[i]==5:\n            continue\n        checkVis=checkVinit\n        Visted=[i]\n        checkVis[i]=5\n        toVis=queue.Queue()\n        for j in range(len(root[i])):\n            nex=root[i][j]\n            if checkVis[j]!=5 and nex==1:\n                toVis.put(j)\n        while toVis.empty()==False:\n            now=toVis.get()\n            if checkVis[now]==5:\n                continue\n            Visted.append(now)\n            checkVis[now]=5\n            for j in range(n):\n                nex=root[now][j]\n                if nex==1 and checkVis[j]!=5:\n                    toVis.put(j)\n        for j in Visted:\n            OK[j]=Visted\n            checkOK[j]=5\n    ans=[]\n    for i in range(n):\n        num=0\n    print(\" \".join(map(str,ans)))\nif __name__==\"__main__\":\n    main()",
        "submission_id": "s995759534",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 51,
        "cyclomatic_complexity": 17,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02626",
        "code_tokens": "import sys\ndef solve(n, aaa):\n    if n == 2:\n        h, m = divmod(sum(aaa), 2)\n        if m == 1 or h > aaa[0]:\n            return -1\n        return aaa[0] - h\n    x = 0\n    for a in aaa[2:]:\n        x ^= a\n    a0, a1 = aaa[:2]\n    s = a0 + a1\n    if s & 1 != x & 1:\n        return -1\n    p, q = 0, 0\n    b = 1 << 40\n    while b:\n        bx = x & b\n        if bx == 0:\n            if s >= 2 * b:\n                if p + b <= a0:\n                    p |= b\n                    q |= b\n                    s -= 2 * b\n                else:\n                    raise RuntimeError\n        else:\n            if s < b:\n                return -1\n            if p + b <= a0 and q + b > a1:\n                p |= b\n            else:\n                q |= b\n            s -= b\n        b >>= 1\n    if p == 0:\n        return -1\n    assert s == 0\n    assert p ^ q == x\n    assert a0 - p == q - a1\n    return a0 - p\nn, *aaa = map(int, sys.stdin.buffer.read().split())\nprint(solve(n, aaa))",
        "submission_id": "s722575510",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 43,
        "cyclomatic_complexity": 17,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02680",
        "code_tokens": "def main():\n    import sys\n    readline = sys.stdin.readline\n    from collections import deque\n    from bisect import bisect_left\n    N, M = map(int, input().split())\n    tate = []\n    yoko = []\n    X = set()\n    Y = set()\n    for _ in range(N):\n        A, B, C = map(int, readline().split())\n        X.add(A)\n        X.add(B)\n        Y.add(C)\n        tate.append((C, A, B))\n    for _ in range(M):\n        D, E, F = map(int, readline().split())\n        X.add(D)\n        Y.add(E)\n        Y.add(F)\n        yoko.append((D, E, F))\n    X = sorted(list(X))\n    Y = sorted(list(Y))\n    H = len(X)\n    W = len(Y)\n    ix = {}\n    for i, x in enumerate(X):\n        ix[x] = i\n    jy = {}\n    for j, y in enumerate(Y):\n        jy[y] = j\n    grid = [[15] * W for _ in range(H)]\n    for c, a, b in tate:\n        ia = ix[a]\n        ib = ix[b]\n        jc = jy[c]\n        for i in range(ia, ib):\n            grid[i][jc - 1] &= 15 - (1 << 1)\n            grid[i][jc] &= 15 - (1 << 3)\n    for d, e, f in yoko:\n        i_d = ix[d]\n        je = jy[e]\n        jf = jy[f]\n        for j in range(je, jf):\n            grid[i_d - 1][j] &= 15 - (1 << 2)\n            grid[i_d][j] &= 15 - (1 << 0)\n    q = deque()\n    x0 = bisect_left(X, 0) - (0 not in ix)\n    y0 = bisect_left(Y, 0) - (0 not in jy)\n    path = [[True] * W for _ in range(H)]\n    path[x0][y0] = False\n    q.append((x0, y0))\n    direction = ((-1, 0), (0, 1), (1, 0), (0, -1))\n    cnt = 0\n    while q:\n        x, y = q.popleft()\n        cnt += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        for i, (dx, dy) in enumerate(direction):\n            if grid[x][y] & (1 << i):\n                nx = x + dx\n                ny = y + dy\n                if 0 <= nx < H - 1 and 0 <= ny < W - 1:\n                    if path[nx][ny]:\n                        path[nx][ny] = False\n                        q.append((nx, ny))\n                else:\n                    print('INF')\n                    exit()\n    print(cnt)\nif __name__ == \"__main__\":\n    main()",
        "submission_id": "s841493826",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 72,
        "cyclomatic_complexity": 17,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02616",
        "code_tokens": "mod = 10 ** 9 + 7\ndef main():\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    if N == K:\n        ans = 1\n        for a in A:\n            ans *= a\n            ans %= mod\n        return ans\n    neg = []\n    pos = []\n    for a in A:\n        if a > 0:\n            pos.append(a)\n        elif a < 0:\n            neg.append(a)\n    if K > len(pos) + len(neg):\n        return 0\n    pos.sort()\n    neg.sort(reverse=True)\n    if len(neg) == N:\n        res = 1\n        for i in range(K):\n            res *= neg[i]\n            res %= mod\n        return res\n    ans = 1\n    if K & 1:\n        ans *= pos.pop()\n        K -= 1\n    while K > 1 and len(pos) > 1 and len(neg) > 1:\n        K -= 2\n        if pos[-1] * pos[-2] > neg[-1] * neg[-2]:\n            ans *= pos.pop()\n            ans *= pos.pop()\n            ans %= mod\n        else:\n            ans *= neg.pop()\n            ans *= neg.pop()\n            ans %= mod\n    while K > 1 and len(pos) > 1:\n        K -= 2\n        ans *= pos.pop()\n        ans %= mod\n        ans *= pos.pop()\n        ans %= mod\n    while K > 1 and len(neg) > 1:\n        K -= 2\n        ans *= neg.pop()\n        ans %= mod\n        ans *= neg.pop()\n        ans %= mod\n    return ans\nif __name__ == \"__main__\":\n    print(main())",
        "submission_id": "s597340247",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 56,
        "cyclomatic_complexity": 18,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02616",
        "code_tokens": "def main():\n    M=10**9+7\n    n,k,*a=map(int,open(0).read().split())\n    x,y=[],[]\n    for i in a:\n        if i>0:x+=i,\n        if i<0:y+=i,\n    if len(x)+len(y)<k or k%2 and not x and len(y)<n:\n        print(0)\n        exit()\n    if k%2 and not x:\n        c=1\n        for i in sorted(y)[-k:]:\n            c=c*i%M\n        print(c)\n        exit()\n    x=sorted(x)[::-1][:k]\n    i=len(x)\n    y.sort()\n    m=len(y)\n    j=0\n    if i<k:\n        j=k-i\n        if j%2:\n            x=x[:-1]\n            i-=1\n            j+=1\n        x+=y[:j]\n        j+=1\n    if len(x)!=k:1/0\n    while i>1 and j+1<m and x[i-1]*x[i-2]<y[j]*y[j+1]:\n        x[i-1],x[i-2]=y[j],y[j+1]\n        i-=2\n        j+=2\n    c=1\n    for i in x:\n        c=c*i%M\n    print(c)\nmain()",
        "submission_id": "s106938524",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 39,
        "cyclomatic_complexity": 18,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02586",
        "code_tokens": "def main():\n  import sys\n  input=sys.stdin.readline\n  h,w,k=map(int,input().split())\n  H=range(h)\n  W=range(w)\n  dp=[[[0]*w for j in H] for i in range(4)]\n  for _ in range(k):\n    r,c,v=map(int,input().split())\n    dp[r-1][c-1][0]=v\n  if dp[0][0][0]!=0:\n    dp[1][0][0]=dp[0][0][0]\n    dp[0][0][0]=0\n  for y in H:\n    for x in W:\n      v=dp[0][y][x]\n      dp[0][y][x]=0\n      for i in range(4):\n        if 0<x:\n          if dp[i][y][x]<dp[i][y][x-1]:\n            dp[i][y][x]=dp[i][y][x-1]\n          if 0<i and v!=0 and dp[i][y][x]<dp[i-1][y][x-1]+v:\n            dp[i][y][x]=dp[i-1][y][x-1]+v\n        if 0<y:\n          if dp[0][y][x]<dp[i][y-1][x]:\n            dp[0][y][x]=dp[i][y-1][x]\n          if v!=0 and dp[1][y][x]<dp[i][y-1][x]+v:\n            dp[1][y][x]=dp[i][y-1][x]+v\n  print(max([dp[i][h-1][w-1] for i in range(4)]))\nmain()",
        "submission_id": "s760278588",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 30,
        "cyclomatic_complexity": 18,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03247",
        "code_tokens": "import array\nfrom bisect import *\nfrom collections import *\nimport fractions\nimport heapq\nfrom itertools import *\nimport math\nimport random\nimport re\nimport string\nimport sys\ndef solve(N, XYs):\n    mod2 = [(x + y) % 2 for x, y in XYs]\n    if min(mod2) != max(mod2):\n        print(-1)\n        return\n    UVs = [(x + y, x - y) for x, y in XYs]\n    arms = [2 ** x for x in range(2)]\n    if mod2[0] == 0:\n        arms = [1] + arms\n    arms.reverse()\n    ans_list = []\n    for u, v in UVs:\n        ans = ''\n        for arm in arms:\n            ch = None\n            if u > 0 and v > 0:\n                ch = 'R'\n            elif u > 0 and v < 0:\n                ch = 'U'\n            elif u < 0 and v > 0:\n                ch = 'D'\n            else:\n                ch = 'L'\n            ans += ch\n            if u > 0:\n                u -= arm\n            else:\n                u += arm\n            if v > 0:\n                v -= arm\n            else:\n                v += arm\n        assert u == 0 and v == 0\n        ans_list.append(ans)\n    print(len(arms))\n    print(*arms)\n    for ans in ans_list:\n        print(ans)\nN = int(input())\nXYs = []\nfor n in range(N):\n    x, y = map(int, input().split())\n    XYs.append((x, y))\nsolve(N, XYs)",
        "submission_id": "s902610917",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 55,
        "cyclomatic_complexity": 18,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02365",
        "code_tokens": "import heapq\nnv, ne, r = map(int, input().split())\nin_edges = {v: set() for v in range(nv)}\nout_edges = {v: set() for v in range(nv)}\nwhile ne:\n    s, t, w = map(int, input().split())\n    in_edges[t].add((w, s))\n    out_edges[s].add((w, t))\n    ne -= 1\ndef chu_liu_edmond(vertices):\n    global in_edges, out_edges, nv, r\n    total_cost = 0\n    prev_v = {v: None for v in vertices}\n    next_vs = {v: set() for v in vertices}\n    for t in vertices:\n        if t == r:\n            continue\n        min_in_w, min_in_s = min(in_edges[t])\n        total_cost += min_in_w\n        prev_v[t] = min_in_s\n        next_vs[min_in_s].add(t)\n    visited = {r}\n    queue = set(next_vs[r])\n    while queue:\n        t = queue.pop()\n        visited.add(t)\n        queue.update(next_vs[t])\n    cycles = []\n    for i in vertices:\n        if i in visited:\n            continue\n        cycle_vertices = set()\n        while i not in visited:\n            visited.add(i)\n            cycle_vertices.add(i)\n            i = prev_v[i]\n        if i not in cycle_vertices:\n            continue\n        cycle_vertices, j = {i}, i\n        while prev_v[j] != i:\n            cycle_vertices.add(j)\n            j = prev_v[j]\n        cycles.append(cycle_vertices)\n    if not cycles:\n        return total_cost\n    for cycle in cycles:\n        vertices.add(nv)\n        vertices -= cycle\n        for v in cycle:\n            for w, t in out_edges[v]:\n                if t not in cycle:\n                    out_edges[nv].add((w, t))\n                    in_edges[t].remove((w, v))\n                    in_edges[t].add((w, nv))\n            for w, s in in_edges[v]:\n                if s not in cycle:\n                    new_w = w - min(in_edges[v])[0]\n                    in_edges[nv].add((new_w, s))\n                    out_edges[s].remove((w, v))\n                    out_edges[s].add((new_w, v))\n        nv += 1\n    return chu_liu_edmond(vertices)\nprint(chu_liu_edmond(set(range(nv))))",
        "submission_id": "s021693790",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 63,
        "cyclomatic_complexity": 18,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03685",
        "code_tokens": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
        "submission_id": "s631603326",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 53,
        "cyclomatic_complexity": 19,
        "number_of_functions": 1
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03165",
        "code_tokens": "A = input()\nB = input()\ndp = [[None] * (len(B) + 1) for _ in range(len(A) + 1)]\ndef dfs(a=0, b=0):\n    if a >= len(A) or b >= len(B):\n        return 0\n    if dp[a][b] is not None:\n        return dp[a][b]\n    match = A[a] == B[b]\n    if match:\n        r = dfs(a + 1, b + 1) + 1\n    else:\n        r = max(dfs(a + 1, b), dfs(a, b + 1))\n    dp[a][b] = r\n    return r\ndfs()\ndef or_inf(v):\n    return float('inf') if v is None else v\ndef reconst(a=0, b=0):\n    if a >= len(A) or b >= len(B):\n        return ''\n    match = A[a] == B[b]\n    if match:\n        return reconst(a + 1, b + 1) + A[a]\n    else:\n        if or_inf(dp[a + 1][b]) >= or_inf(dp[a][b + 1]):\n            return reconst(a + 1, b)\n        else:\n            return reconst(a, b + 1)\nprint(reconst()[::-1])",
        "submission_id": "s808906428",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 30,
        "cyclomatic_complexity": 12,
        "number_of_functions": 3
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02599",
        "code_tokens": "mod = 1000000007\neps = 10**-9\nBsize = 700\ndef main():\n    import sys\n    input = sys.stdin.readline\n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    query_list = [[] for _ in range(N // Bsize + 1)]\n    for q in range(Q):\n        l, r = map(int, input().split())\n        query_list[(l-1) // Bsize].append((l - 1, r - 1, q))\n    for i in range(N // Bsize + 1):\n        if query_list[i]:\n            query_list[i].sort(key=lambda x: x[1])\n    query = []\n    for ql in query_list:\n        query.extend(ql)\n    cnt = [0] * (10**6 + 1)\n    val = 0\n    def add(i):\n        nonlocal val\n        cnt[A[i]] += 1\n        if cnt[A[i]] == 1:\n            val += 1\n    def rem(i):\n        nonlocal val\n        cnt[A[i]] -= 1\n        if cnt[A[i]] == 0:\n            val -= 1\n    l, r, _ = query[0]\n    for i in range(l, r + 1):\n        add(i)\n    ans = [0] * Q\n    for l_new, r_new, q in query:\n        if r < r_new:\n            for i in range(r + 1, r_new + 1):\n                add(i)\n        elif r > r_new:\n            for i in range(r, r_new, -1):\n                rem(i)\n        if l < l_new:\n            for i in range(l, l_new):\n                rem(i)\n        elif l > l_new:\n            for i in range(l - 1, l_new - 1, -1):\n                add(i)\n        l = l_new\n        r = r_new\n        ans[q] = val\n    for a in ans:\n        print(a)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s501842700",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 54,
        "cyclomatic_complexity": 17,
        "number_of_functions": 3
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p02722",
        "code_tokens": "def make_divisors(n):\n    divisors = []\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n//i)\n    divisors.sort()\n    divisors.append(n)\n    return divisors\ndef check(N,K):\n    if N == K:\n        return True\n    if N % K ==1:\n        return True\n    if N<K:\n        return False\n    if N % K ==0:\n        return check(N//K,K)\n    else:\n        return False\ndef resolve():\n    N = int(input())\n    ys= set(make_divisors(N))\n    ys2= set(make_divisors(N-1))\n    x =set([i for i in ys|ys2 if check(N,i)])\n    print(len(x))\nif __name__ == \"__main__\":\n    resolve()",
        "submission_id": "s614465599",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 29,
        "cyclomatic_complexity": 12,
        "number_of_functions": 3
    },
    {
        "source": "source",
        "lang": "python",
        "problem_id": "p03108",
        "code_tokens": "import array\nimport time\nclass UnionFind :\n    def __init__(self, n):\n        self.par = array.array('i', range(n))\n        self.sizes = array.array('i', [1]*n)\n    def root(self, i):\n        if i == self.par[i]:\n            return i\n        else:\n            r = self.root(self.par[i])\n            self.par[i] = r\n            return r\n    def unite(self, x, y):\n        rx = self.root(x)\n        ry = self.root(y)\n        if rx != ry:\n            srx = self.sized(x)\n            sry = self.sized(y)\n            self.par[rx] = ry\n            self.sizes[ry] = srx + sry\n    def same(self, x, y) :\n        try:\n            px = self.root(x)\n            py = self.root(y)\n        except:\n            return False\n        if px == py :\n            return True\n        else:\n            return False\n    def sized(self, x):\n        return self.sizes[self.root(x)]\n    def debug(self):\n        print(self.par)\n        print(self.sizes)\ndef calsc(x):\n    return (x * (x-1)) // 2\ndef main():\n    (n,m) = map(int, input().split())\n    ab = []\n    for _ in range(m):\n        (p,q) = map(int, input().split())\n        ab.append((p-1,q-1))\n    uf = UnionFind(n)\n    res = []\n    prev = 0\n    while len(ab) > 0:\n        (a,b) = ab.pop()\n        res.append(prev)\n        score = prev\n        if not uf.same(a,b):\n            score = score - calsc(uf.sized(a)) - calsc(uf.sized(b))\n            uf.unite(a,b)\n            score = score + calsc(uf.sized(a))\n        prev = score\n    for i in range(len(res)):\n        res[i] = calsc(n) - res[i]\n    res = res[::-1]\n    for r in res:\n        print(r)\nif __name__ == '__main__':\n    main()",
        "submission_id": "s976644739",
        "functions_standalone": [],
        "functions_class": [],
        "verdict": "Runtime Error",
        "lines_of_code": 63,
        "cyclomatic_complexity": 19,
        "number_of_functions": 8
    }
]
