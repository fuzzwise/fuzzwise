{
  "submission_id": "s109776224",
  "cycles": [
    {
      "test_case": "Test Case Input:\n3\n2\n1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n5\n2\n-3\n1\n-2\n4",
        "Test Case Input:\n3\n2\n1\n-2\n3",
        "Test Case Input:\n3\n2\n-1\n0\n2",
        "Test Case Input:\n5\n3\n1\n2\n3\n4\n5",
        "Test Case Input:\n5\n3\n-2\n4\n-6\n8\n-10",
        "Test Case Input:\n3\n2\n1\n-2\n3",
        "Test Case Input:\n4\n2\n1\n2\n3\n4",
        "Test Case Input:\n5\n3\n1\n-2\n3\n-4\n5",
        "Test Case Input:\n2\n1\n-5\n6",
        "Test Case Input:\n3\n2\n1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered. \n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\" are covered. \n4. Array Declaration and Input : always executed. Statement \"int[] A = new int[n];\" is covered. \n5. For loop Execution : Since n is 3, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n6. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed. \n7. List Declaration and Iteration : always executed. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered. \n8. If - Else condition : Since i is not less than 0, the if condition 'i >= 0' is not satisfied. The else condition is satisfied so statements 'else {' and \"neg.add(i);\" are covered. \n9. Sorting Lists : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered. \n10. Array Declaration and Calculation : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered. \n11. Array Initialization : always executed. Statements \"posMul[0] = 1;\" and \"negMul[0] = 1;\" are covered. \n12. For loop Execution : Since i is 1 and less than posMul.length, the for loop condition (i < posMul.length) is true, and the loop block will be executed. Statement \"for (int i = 1; i < posMul.length; i++) {\" will be covered. \n13. Array Calculation : always executed. Statement \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" is covered. \n14. Array Calculation with Modulus : always executed. Statement \"posMul[i] %= mod;\" is covered. \n15. For loop Execution : Since i is 1 and less than negMul.length, the for loop condition (i < negMul.length) is true, and the loop block will be executed. Statement \"for (int i = 1; i < negMul.length; i++) {\" will be covered. \n16. Array Calculation : always executed. Statement \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" is covered. \n17. Array Calculation with Modulus : always executed. Statement \"negMul[i] %= mod;\" is covered. \n18. Variable Declaration and Initialization : always executed. Statement \"long res = Integer.MIN_VALUE;\" is covered. \n19. If condition : Since neg.size() is not equal to 0, the if condition 'neg.size() == 0' is not satisfied. The else if condition is also not satisfied. The else condition is satisfied so statements 'else {' and \"res = negMul[k];\" are covered. \n20. Calculation and Output : always executed. Statements \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered. \n21. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n3\n-2\n1\n2\n3",
        "Test Case Input:\n-3\n0\n0\n0\n0",
        "Test Case Input:\n-3\n2\n-1\n-2\n-3",
        "Test Case Input:\n-3\n0\n-1\n-2\n-3",
        "Test Case Input:\n-3\n0\n-1\n-2\n-3",
        "Test Case Input:\n\"3\"\n\"2\"\n\"1\"\n\"2\"\n\"3\"",
        "Test Case Input:\n-5\n3\n-2\n0\n1\n-3",
        "Test Case Input:\n5\n-2\n0\n-3\n1\n-4",
        "Test Case Input:\n-3\n2\n1\n-2\n-3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n3. User Input and Program Output: Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\" are covered.\n\n4. Array Declaration and Input: Statements \"int[] A = new int[n];\", \"for (int i = 0; i < n; i++) {\" are covered.\n\n5. Array element comparison: The loop block will be executed for each element in the array. Statement \"A[i] = scanner.nextInt();\" will be covered.\n\n6. List Declaration and Element Addition: The loop block will be executed for each element in the array. Statements \"if (i >= 0) {\" and \"pos.add(i);\" will be covered if element is greater than or equal to 0. Statements \"else {\" and \"neg.add(i);\" will be covered if element is less than 0.\n\n7. List Sorting: Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" will be covered.\n\n8. Array Multiplication: The loop block will be executed for each element in the positive list. Statements \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" and \"posMul[i] %= mod;\" will be covered.\n\n9. Array Multiplication: The loop block will be executed for each element in the negative list. Statements \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" and \"negMul[i] %= mod;\" will be covered.\n\n10. Maximum Calculation: The loop block will be executed for each element from 1 to the minimum of k and the length of positive list. Statements \"res = Math.max(res, posMul[k] * negMul[k - i]);\" will be covered.\n\n11. Program Output: Statements \"System.out.println(res < 0 ? res + mod : res % mod);\" will be covered.\n\n12. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3\n2\n1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n-2\n4\n-3\n-1\n-2\n-3",
        "Test Case Input:\n1\n2\n-3\nTest Case Input:\n0\n3\n1\n2\n3\nTest Case Input:\n4\n-1\n0\n2\n4\nTest Case Input:\n5\n3\n10\n20\n30\n40\n50\nTest Case Input:\n2\n1\n1\n-1",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n0\n2\n1\n2\n3",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n0\n2\n-3\n5\n-2\n4",
        "Test Case Input:\n-3\n3\n-2\n-1\n2\n-3",
        "Test Case Input:\n5\n-2\n-3\n4\n-1\n2",
        "Test Case Input:\n\"ABC\"\n2\n-1\n-2\n-3\n-4\n-5",
        "Test Case Input:\n\"3\"\n\"2\"\n\"1\"\n\"2\"\n\"3\""
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Variable Initialization : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" are covered.\n4. For loop for array initialization : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed.\n5. List Initialization and For Each Loop : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\" and \"for (int i : A) {\" are covered.\n6. If - Else condition inside For Each Loop: statements inside both if and else blocks will be executed depending on the value of i. Statements \"if (i >= 0) {\" and \"else {\" are covered.\n7. Sorting of Lists : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n8. Array Initialization and For Loop : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\", \"long[] negMul = new long[neg.size() + 1];\" and \"for (int i = 1; i < posMul.length; i++) {\" are covered.\n9. Array Element Calculation : always executed. Statements \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\", \"posMul[i] %= mod;\", \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" and \"negMul[i] %= mod;\" are covered.\n10. Variable Initialization and If - Else condition : always executed. Statements \"long res = Integer.MIN_VALUE;\", \"if (neg.size() == 0) {\" and \"if (pos.size() == 0) {\" are covered.\n11. For Loop for Maximum Calculation : always executed. Statements \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" and \"res = Math.max(res, posMul[k] * negMul[k - i]);\" are covered.\n12. Program Output : always executed. Statements \"System.out.println(res < 0 ? res + mod : res % mod);\" will be covered.\n13. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4\n-2\n1\n-3\n2\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n\"3\"\n\"2\"\n\"1\"\n\"2\"\n\"3\"",
        "Test Case Input:\nA\n2\n1\n2\n3",
        "Test Case Input:\n\"3\"  \n\"2\"  \n\"1\"  \n\"2\"  \n\"3\"",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n3\n2\n1\n2\n3\n0\nTest Case Input:\n-5\n3\n-2\n-1\n2\n3\nTest Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n\"3\"  \n\"2\"  \n\"1\"  \n\"2\"  \n\"3\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"\n\"1\"\n\"2\"\n\"3\"",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n\"3\n2\n1\n2\n3\"",
        "Test Case Input:\n4\n-2\n1\n-3\n2\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and tets case -\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered. \n2. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\" are covered. \n4. Array Initialization : always executed. Statement \"int[] A = new int[n];\" is covered. \n5. Array Population : always executed. Statements \"for (int i = 0; i < n; i++) {\" and \"A[i] = scanner.nextInt();\" are covered. \n6. ArrayList Declarations : always executed. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered.\n7. ArrayList Population : always executed. Statements \"for (int i : A) {\" and \"if (i >= 0) {\" and \"pos.add(i);\" and \"else {\" and \"neg.add(i);\" are covered. \n8. ArrayList Sort : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered. \n9. Long Array Declarations : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered. \n10. Long Array Population : always executed. Statements \"posMul[0] = 1;\" and \"negMul[0] = 1;\" are covered. \n11. Modulus value declaration : always executed. Statement \"int mod = 1000000007;\" is covered. \n12. Long Array Calculation : always executed. Statements \"for (int i = 1; i < posMul.length; i++) {\" and \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" and \"posMul[i] %= mod;\" are covered. Statements \"for (int i = 1; i < negMul.length; i++) {\" and \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" and \"negMul[i] %= mod;\" are covered. \n13. Result Calculation : always executed. Statements \"long res = Integer.MIN_VALUE;\" and \"if (neg.size() == 0) {\" and \"res = posMul[k];\" and \"System.out.println(res < 0 ? res + mod : res % mod);\" and \"return;\" are covered. Statements \"if (pos.size() == 0) {\" and \"res = negMul[k];\" and \"System.out.println(res < 0 ? res + mod : res % mod);\" and \"return;\" are covered. Statements \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" and \"res = Math.max(res, posMul[k] * negMul[k - i]);\" are covered. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered. \n14. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n2\n3\n-2\n5",
        "Test Case Input:\n-1\n0\n-2\n3\n4\n5",
        "Test Case Input:\n-2\n-3\n-4\n-5\n-6\n-7",
        "Test Case Input:\n-4\n2\n-1\n3\n-5",
        "Test Case Input:\n0\n2\n1\n2\n3",
        "Test Case Input:\nabc\n2\n1\n2\n3",
        "Test Case Input:\n0\n2\n1\n2\n3",
        "Test Case Input:\n0\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n3. User Input and Program Output: always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", and \"int[] A = new int[n];\" are covered.\n\n4. For loop to input array elements: always executed. Statement \"for (int i = 0; i < n; i++) {\" is covered.\n\n5. If-Else condition to separate positive and negative numbers: always executed. Statements \"if (i >= 0) {\" and \"else {\" are covered.\n\n6. Adding elements to pos and neg lists: always executed. Statements \"pos.add(i);\" and \"neg.add(i);\" are covered.\n\n7. Sorting pos and neg lists: always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n\n8. Initializing posMul and negMul arrays: always executed. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered.\n\n9. Calculating posMul values: always executed. For loop condition is true, so the loop block will be executed. Statement \"for (int i = 1; i < posMul.length; i++) {\" is covered.\n\n10. Calculating negMul values: always executed. For loop condition is true, so the loop block will be executed. Statement \"for (int i = 1; i < negMul.length; i++) {\" is covered.\n\n11. Calculating res value: always executed. Statements \"long res = Integer.MIN_VALUE;\" and \"if (neg.size() == 0) {\" are covered.\n\n12. If-Else condition to handle cases when neg or pos list is empty: always executed. Statements \"if (neg.size() == 0) {\" and \"if (pos.size() == 0) {\" are covered.\n\n13. For loop to calculate maximum value of res: always executed. For loop condition is true, so the loop block will be executed. Statement \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" is covered.\n\n14. Final output: always executed. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n\n15. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n2\n3\n4\n5",
      "test_mutations": [
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n2\n3\n-1\n4",
        "Test Case Input:\nabc\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n2\n-3\n1\n2",
        "Test Case Input:\n0\n2\n3\n1\n2\n3",
        "Test Case Input:\n-2\n3\n1\n-4\n2\n-6\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n4\n-2\n1\n-3\n2\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n1\n2\n3\n4\n5"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input : always executed. Statements \"int n = scanner.nextInt();\" and \"int k = scanner.nextInt();\" are covered.\n4. Array Initialization : always executed. Statement \"int[] A = new int[n];\" is covered.\n5. For loop to populate array : always executed since n is 5. Statement \"for (int i = 0; i < n; i++) {\" is covered.\n6. If-else condition : always executed. Statement \"if (i >= 0) {\" is covered and statement \"else {\" is covered.\n7. List add operation : always executed. Statements \"pos.add(i);\" and \"neg.add(i);\" are covered.\n8. List sorting : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n9. Array initialization and calculation : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\", \"long[] negMul = new long[neg.size() + 1];\", \"posMul[0] = 1;\", and \"negMul[0] = 1;\" are covered.\n10. For loop for multiplication and modulo operation : always executed. Statements \"for (int i = 1; i < posMul.length; i++) {\" and \"for (int i = 1; i < negMul.length; i++) {\" are covered.\n11. Calculation of res : always executed. Statements \"long res = Integer.MIN_VALUE;\", \"if (neg.size() == 0) {\", \"res = posMul[k];\", \"System.out.println(res < 0 ? res + mod : res % mod);\", and \"return;\" are covered.\n12. Calculation of res : always executed. Statements \"if (pos.size() == 0) {\", \"res = negMul[k];\", \"System.out.println(res < 0 ? res + mod : res % mod);\", and \"return;\" are covered.\n13. For loop to calculate maximum product : always executed. Statements \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" and \"res = Math.max(res, posMul[k] * negMul[k - i]);\" are covered.\n14. Print final result : always executed. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n15. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"\n\"1\"\n\"2\"\n\"3\"",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\na\nb\nc\nd\ne",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n-2\n5\n3\n2\n1\n2\n3",
        "Test Case Input:\n0\n0\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input: Since the test case inputs are -5 and 3, the following statements will be executed:\n   - int n = scanner.nextInt(); (covered)\n   - int k = scanner.nextInt(); (covered)\n4. Array Initialization: Since the value of n is -5, the array initialization will not be executed.\n5. For loop Execution: Since the value of n is -5, the for loop condition (i < n) is false, and the loop block will not be executed. Statement \"for (int i = 0; i < n; i++) {\" is not covered.\n6. List Initialization: Since the for loop was not executed, both lists pos and neg will be empty. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered.\n7. Sort Lists: Since the lists are empty, the sort operations will not be executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are not covered.\n8. Array Initialization: Since the lists are empty, the array initializations will contain only the default value 0. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered.\n9. Array Calculation: Since the lists are empty, the array calculations will not be executed. Statements \"posMul[0] = 1;\", \"negMul[0] = 1;\", \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\", and \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" are not covered.\n10. Calculation of res: Since both lists are empty, the conditions \"if (neg.size() == 0)\" and \"if (pos.size() == 0)\" are true. Statements \"res = posMul[k];\", \"System.out.println(res < 0 ? res + mod : res % mod);\", \"return;\", \"res = negMul[k];\", and \"System.out.println(res < 0 ? res + mod : res % mod);\" are covered.\n11. Calculation of res in for loop: Since both lists are empty, the for loop condition \"i <= Math.min(k, posMul.length)\" is false, and the loop block will not be executed. Statement \"res = Math.max(res, posMul[k] * negMul[k - i]);\" is not covered.\n12. System.out.println statement: The final output statement \"System.out.println(res < 0 ? res + mod : res % mod);\" will be executed. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n13. Closing Brackets: always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n2\n3\n4\n5\n6",
      "test_mutations": [
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n2\n3\n-1\n2",
        "Test Case Input:\n-2\n3\n-1\n2\n3",
        "Test Case Input:\n2\n3\n-1\n-2",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n0\n2\n1\n2\n3",
        "Test Case Input:\n1\n2\n3\n4\n5\n6",
        "Test Case Input:\n-10\n5\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10",
        "Test Case Input:\n2\n3\n4\n5\n6"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input: always executed. Statements \"int n = scanner.nextInt();\" and \"int k = scanner.nextInt();\" are covered.\n4. Array initialization and User Input: always executed. Statement \"int[] A = new int[n];\" and for loop \"for (int i = 0; i < n; i++) {\" are covered. \n5. List initialization and for loop: always executed. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered. Also, the for loop \"for (int i : A) {\" is executed.\n6. If-else condition: Since both pos and neg lists are empty, the if condition 'neg.size() == 0' and 'pos.size() == 0' are satisfied. Statements \"if (neg.size() == 0) {\" and \"if (pos.size() == 0) {\" are covered.\n7. Statements inside if-else condition: Statements inside both if conditions are covered. \n8. For loop execution: The for loop condition (i <= Math.min(k, posMul.length)) is true, and the loop block will be executed. Statement \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" is covered.\n9. Statements inside for loop: Statements inside the for loop are covered.\n10. Print statement: always covered. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n11. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n2\n3\n4\n5",
      "test_mutations": [
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n\"3\" \n\"2\" \n\"1\" \n\"2\" \n\"3\"",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n\"3\" \n\"2\"\n\"1\"\n\"2\"\n\"3\"",
        "Test Case Input:\n\"5\"\n\"2\"\n\"1\"\n\"2\"\n\"3\"\n\"4\"",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n0\n3\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n1\n0\n-1",
        "Test Case Input:\n1\n2\n3\n4\n5"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. Variable Declaration and User Input : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" are covered.\n4. For loop Execution : Since n is 1, the for loop condition (i < n) is false, and the loop block will not be executed. Statement \"for (int i = 0; i < n; i++) {\" is not covered.\n5. List Creation and List Modification : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\" are covered.\n6. For Each loop and If-Else condition : Since A is empty, the for-each loop iteration will not occur. The if-else condition is not executed. Statements \"for (int i : A) {\" and \"if (i >= 0) {\" are not covered.\n7. List Sorting : always executed. Statements \"pos.sort(Comparator.reverseOrder());\", \"neg.sort(Comparator.reverseOrder());\" are covered.\n8. Array Creation and Array Modification : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\", \"long[] negMul = new long[neg.size() + 1];\" are covered.\n9. Array Initialization : always executed. Statements \"posMul[0] = 1;\", \"negMul[0] = 1;\" are covered.\n10. For loop Execution : Since posMul and negMul have a length of 1, the for loop condition (i < posMul.length) is false, and the loop block will not be executed. Statements \"for (int i = 1; i < posMul.length; i++) {\" and \"for (int i = 1; i < negMul.length; i++) {\" are not covered.\n11. Calculation and Modulus Operation : always executed. Statements \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\", \"posMul[i] %= mod;\", \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\", \"negMul[i] %= mod;\" are covered.\n12. Variable Declaration and Calculation : always executed. Statement \"long res = Integer.MIN_VALUE;\" is covered.\n13. If-Else condition : Since neg and pos are not empty, both if conditions are false and the else condition will be executed. Statements \"if (neg.size() == 0) {\" and \"if (pos.size() == 0) {\" are covered.\n14. For loop Execution : Since k is 2 and posMul has a length of 1, the for loop condition (i <= Math.min(k, posMul.length)) is false, and the loop block will not be executed. Statement \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" is not covered.\n15. Calculation and Output : always executed. Statements \"res = Math.max(res, posMul[k] * negMul[k - i]);\", \"System.out.println(res < 0 ? res + mod : res % mod);\" are covered.\n16. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n-4\n0\n-1\n-2\n-3\n\nTest Case Input:\n5\n3\n-1\n2\n-3\n4\n-5\n\nTest Case Input:\n0\n5\n1\n2\n3\n4\n5\n\nTest Case Input:\n2\n2\n1\n2\n\nTest Case Input:\n6\n4\n-1\n2\n-3\n4\n-5\n6",
        "Test Case Input:\n-2\n3\n-1\n2\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n5\n-2\n1\n-3\n2\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n2\n3\n-1\n4",
        "Test Case Input:\n5\n3\n4\n-2\n-1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\na\nb\nc\nd\ne",
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n3. User Input and Array Initialization: Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" are covered.\n\n4. For loop for array input: The for loop will execute n times. Each iteration will cover the statement \"A[i] = scanner.nextInt();\".\n\n5. List Initialization and loop: Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\" are covered. The loop \"for (int i : A) {\" will execute n times and cover the statements within it.\n\n6. If-Else condition: If the condition \"i >= 0\" is true, statement \"pos.add(i);\" will be covered. Otherwise, statement \"neg.add(i);\" will be covered.\n\n7. Sorting Lists: Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" will be covered.\n\n8. Array Initialization: Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" will be covered.\n\n9. Array Initialization with calculations: The for loop \"for (int i = 1; i < posMul.length; i++)\" will execute pos.size() times and cover the statements within it. The for loop \"for (int i = 1; i < negMul.length; i++)\" will execute neg.size() times and cover the statements within it.\n\n10. Calculation of res: If-Else conditions will be checked. The conditions \"neg.size() == 0\" and \"pos.size() == 0\" will be checked. If any condition is true, the corresponding statements will be covered.\n\n11. For loop for res calculation: The for loop \"for (int i = 1; i <= Math.min(k, posMul.length); i++)\" will execute Math.min(k, posMul.length) times and cover the statements within it.\n\n12. Output: Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" will be covered.\n\n13. Closing Braces: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n2\n3\n4\n5",
      "test_mutations": [
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n-1\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n2\n-3\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n5\n-2\n-1\n2\n3\n4",
        "Test Case Input:\n1\n2\n3\n4\n5"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered. \n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n3. User Input and Array Initialization: always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", and \"int[] A = new int[n];\" are covered.\n\n4. For loop to populate Array A: always executed. Statements \"for (int i = 0; i < n; i++) {\" and \"A[i] = scanner.nextInt();\" are covered.\n\n5. List initialization: always executed. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered.\n\n6. For-each loop to categorize elements: always executed. Statements \"for (int i : A) {\" and \"if (i >= 0) {\" are covered.\n\n7. Add elements to respective lists: always executed. Statements \"pos.add(i);\" and \"neg.add(i);\" are covered.\n\n8. Sort positive and negative lists: always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n\n9. Array initialization for multiplication: always executed. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered.\n\n10. Calculate multiplication values for positive list: always executed. Statements \"posMul[0] = 1;\" and \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" are covered.\n\n11. Calculate multiplication values for negative list: always executed. Statements \"negMul[0] = 1;\" and \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" are covered.\n\n12. Variable initialization and comparison: always executed. Statements \"long res = Integer.MIN_VALUE;\" and \"if (neg.size() == 0) {\" are covered.\n\n13. Check condition and calculate result for no negative numbers: executed based on test case input. Statements \"res = posMul[k];\", \"System.out.println(res < 0 ? res + mod : res % mod);\", and \"return;\" are covered.\n\n14. Check condition and calculate result for no positive numbers: executed based on test case input. Statements \"res = negMul[k];\", \"System.out.println(res < 0 ? res + mod : res % mod);\", and \"return;\" are covered.\n\n15. For loop to calculate maximum result: executed based on test case input. Statements \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" and \"res = Math.max(res, posMul[k] * negMul[k - i]);\" are covered.\n\n16. Print the final result: always executed. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n\n17. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3\n2\n1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n-3\n2\n-1\n0\n-2\n-3",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n3\n2\n1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input: always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\" are covered.\n4. Array Initialization: always executed. Statement \"int[] A = new int[n];\" is covered.\n5. For loop for array input: always executed. Statement \"for (int i = 0; i < n; i++) {\" is covered.\n6. Array element assignment: always executed. Statement \"A[i] = scanner.nextInt();\" is covered.\n7. List Initialization: always executed. Statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered.\n8. For loop for populating pos and neg Lists: always executed. Statement \"for (int i : A) {\" is covered.\n9. If-else condition: always executed. Statements \"if (i >= 0) {\" and \"neg.add(i);\" are covered.\n10. Else condition: always executed. Statement \"else {\" is covered.\n11. Sort Lists: always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n12. Array Initialization: always executed. Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered.\n13. Array element assignment: always executed. Statements \"posMul[0] = 1;\" and \"negMul[0] = 1;\" are covered.\n14. For loop for calculating posMul: always executed. Statement \"for (int i = 1; i < posMul.length; i++) {\" is covered.\n15. Multiplication and Modulo operation: always executed. Statements \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" and \"posMul[i] %= mod;\" are covered.\n16. For loop for calculating negMul: always executed. Statement \"for (int i = 1; i < negMul.length; i++) {\" is covered.\n17. Multiplication and Modulo operation: always executed. Statements \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" and \"negMul[i] %= mod;\" are covered.\n18. Variable Assignment: always executed. Statement \"long res = Integer.MIN_VALUE;\" is covered.\n19. If condition: always executed. Statement \"if (neg.size() == 0) {\" is covered.\n20. Variable Assignment and Modulo operation: always executed. Statements \"res = posMul[k];\" and \"System.out.println(res < 0 ? res + mod : res % mod);\" are covered.\n21. Return statement: always executed. Statement \"return;\" is covered.\n22. If condition: always executed. Statement \"if (pos.size() == 0) {\" is covered.\n23. Variable Assignment and Modulo operation: always executed. Statements \"res = negMul[k];\" and \"System.out.println(res < 0 ? res + mod : res % mod);\" are covered.\n24. Return statement: always executed. Statement \"return;\" is covered.\n25. For loop for calculating maximum product: always executed. Statement \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" is covered.\n26. Variable Assignment: always executed. Statement \"res = Math.max(res, posMul[k] * negMul[k - i]);\" is covered.\n27. Modulo operation: always executed. Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n28. Closing Brackets: always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n-2\n3\n-1\n2\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\na\n2\n1\n2\n3",
        "Test Case Input:\n2\n3\n-1\n2",
        "Test Case Input:\n1\n1\n-1",
        "Test Case Input:\n\"5\""
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output: always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" and \"A[i] = scanner.nextInt();\" are covered.\n4. For loop Execution: Since n is 5, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered.\n5. For loop contents: user input statement is always executed. Statement \"A[i] = scanner.nextInt();\" will be executed.\n6. If-else condition: Since the value of i is non-negative, the if condition 'i >= 0' is satisfied. Statements \"pos.add(i);\" and \"pos.add(i);\" will be covered.\n7. List Sorting: Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are always executed.\n8. Array Initialization: Statements \"long[] posMul = new long[pos.size() + 1];\" and \"long[] negMul = new long[neg.size() + 1];\" are covered.\n9. Array Element Assignment: Statements \"posMul[0] = 1;\" and \"negMul[0] = 1;\" are covered.\n10. For loop Execution: Since the length of posMul is greater than 1, the for loop condition (i < posMul.length) is true, and the loop block will be executed. Statement \"for (int i = 1; i < posMul.length; i++) {\" will be covered.\n11. For loop contents: Statements \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" and \"posMul[i] %= mod;\" are covered.\n12. For loop Execution: Since the length of negMul is greater than 1, the for loop condition (i < negMul.length) is true, and the loop block will be executed. Statement \"for (int i = 1; i < negMul.length; i++) {\" will be covered.\n13. For loop contents: Statements \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" and \"negMul[i] %= mod;\" are covered.\n14. If condition: Since neg.size() is not 0, the if condition 'neg.size() == 0' is not satisfied. Statement 'if (neg.size() == 0) {' is not covered.\n15. If condition: Since pos.size() is not 0, the if condition 'pos.size() == 0' is not satisfied. Statement 'if (pos.size() == 0) {' is not covered.\n16. For loop Execution: Since the length of posMul is greater than 1, the for loop condition (i <= Math.min(k, posMul.length)) is true, and the loop block will be executed. Statement \"for (int i = 1; i <= Math.min(k, posMul.length); i++) {\" will be covered.\n17. For loop contents: Statement \"res = Math.max(res, posMul[k] * negMul[k - i]);\" is covered.\n18. Program Output: Statement \"System.out.println(res < 0 ? res + mod : res % mod);\" is covered.\n19. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     for (int i : A) {\n>       if (i >= 0) {\n>         pos.add(i);\n>       } else {\n>         neg.add(i);\n>       }\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2\n-1\n2\n3",
      "test_mutations": [
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n\"3\"",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\na\n3\n2\n1\n2\n3",
        "Test Case Input:\n5\n-2\n1\n-3\n2\n-5\n3\n-2\n-1\n2\n3",
        "Test Case Input:\n\"3\n2\n1\n2\n3\"",
        "Test Case Input:\n\"abc\"\n2\n1\n2\n3",
        "Test Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2\n-1\n2\n3"
      ],
      "initial_code": "import java.util.*;\npublic class Main {\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    for (int i : A) {\n      if (i >= 0) {\n        pos.add(i);\n      } else {\n        neg.add(i);\n      }\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    long[] posMul = new long[pos.size() + 1];\n    long[] negMul = new long[neg.size() + 1];\n    posMul[0] = 1;\n    negMul[0] = 1;\n    int mod = 1000000007;\n    for (int i = 1; i < posMul.length; i++) {\n      posMul[i] = posMul[i - 1] * pos.get(i - 1);\n      posMul[i] %= mod;\n    }\n    for (int i = 1; i < negMul.length; i++) {\n      negMul[i] = negMul[i - 1] * neg.get(i - 1);\n      negMul[i] %= mod;\n    }\n    long res = Integer.MIN_VALUE;\n    if (neg.size() == 0) {\n      res = posMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    if (pos.size() == 0) {\n      res = negMul[k];\n      System.out.println(res < 0 ? res + mod : res % mod);\n      return;\n    }\n    for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n      res = Math.max(res, posMul[k] * negMul[k - i]);\n    }\n    System.out.println(res < 0 ? res + mod : res % mod);\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\" are covered.\n4. Array Creation and Input : always executed. Statement \"int[] A = new int[n];\" is covered. The for loop will execute 'n' times and statement \"A[i] = scanner.nextInt();\" will be covered 'n' times.\n5. List Creation and Sorting : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\" are covered. The for-each loop will iterate through each element of 'A' array. If condition is satisfied for an element, then \"pos.add(i);\" will be covered. If condition is not satisfied for an element, then \"neg.add(i);\" will be covered.\n6. Sorting Lists : always executed. Statements \"pos.sort(Comparator.reverseOrder());\", \"neg.sort(Comparator.reverseOrder());\" are covered.\n7. Array Creation and Calculation : always executed. Statements \"long[] posMul = new long[pos.size() + 1];\", \"long[] negMul = new long[neg.size() + 1];\" are covered. The for loop will execute 'pos.size()+1' times and statement \"posMul[i] = posMul[i - 1] * pos.get(i - 1);\" will be covered 'pos.size()+1' times.\n8. Array Calculation and Modulus : always executed. The for loop will execute 'neg.size()+1' times and statement \"negMul[i] = negMul[i - 1] * neg.get(i - 1);\" will be covered 'neg.size()+1' times. Statement \"posMul[i] %= mod;\" will be covered 'pos.size()+1' times. Statement \"negMul[i] %= mod;\" will be covered 'neg.size()+1' times.\n9. Maximum Calculation : always executed. The for loop will execute 'Math.min(k, posMul.length)' times and statement \"res = Math.max(res, posMul[k] * negMul[k - i]);\" will be covered 'Math.min(k, posMul.length)' times.\n10. Final Output : always executed. The if conditions will be checked and one of the two return statements will be executed. The final print statement \"System.out.println(res < 0 ? res + mod : res % mod);\" will be covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> public class Main {\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     long[] posMul = new long[pos.size() + 1];\n>     long[] negMul = new long[neg.size() + 1];\n>     posMul[0] = 1;\n>     negMul[0] = 1;\n>     int mod = 1000000007;\n>     for (int i = 1; i < posMul.length; i++) {\n>       posMul[i] = posMul[i - 1] * pos.get(i - 1);\n>       posMul[i] %= mod;\n>     }\n>     for (int i = 1; i < negMul.length; i++) {\n>       negMul[i] = negMul[i - 1] * neg.get(i - 1);\n>       negMul[i] %= mod;\n>     }\n>     long res = Integer.MIN_VALUE;\n>     if (neg.size() == 0) {\n>       res = posMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     if (pos.size() == 0) {\n>       res = negMul[k];\n>       System.out.println(res < 0 ? res + mod : res % mod);\n>       return;\n>     }\n>     for (int i = 1; i <= Math.min(k, posMul.length); i++) {\n>       res = Math.max(res, posMul[k] * negMul[k - i]);\n>     }\n>     System.out.println(res < 0 ? res + mod : res % mod);\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    }
  ]
}