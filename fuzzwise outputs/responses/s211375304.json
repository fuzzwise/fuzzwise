{
  "submission_id": "s211375304",
  "cycles": [
    {
      "test_case": "Test Case Input:\n3\n2\n-2\n0\n2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n1 -2 3 -4 5",
        "Test Case Input:\n5\n3\n1\n-2\n3\n-4\n5",
        "Test Case Input:\n5\n3\n-2\n-3\n1\n-5\n4",
        "Test Case Input:\n5\n3\n-2\n4\n0\n-3\n1",
        "Test Case Input:\n5\n3\n1 -2 3 -4 5",
        "Test Case Input:\n5\n3\n-2\n4\n0\n-1\n3",
        "Test Case Input:\n3\n2\n1 -2 3",
        "Test Case Input:\n3\n2\n-1\n2\n0",
        "Test Case Input:\n5\n3\n1\n-2\n3\n-4\n0",
        "Test Case Input:\n3\n2\n-2\n0\n2"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" and \"A[i] = scanner.nextInt();\" are covered. \n5. For loop Execution : Since n is 3, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n6. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed three times. \n7. List Initializations and Counting : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", \"int zero = 0;\" are covered. \n8. For each loop Execution : Since A[] contains 2, -2, and 0, the loop block will be executed. Statement \"for (int i : A) {\" will be covered. \n9. If - Else condition : Since none of the conditions in the if statement are satisfied, the else block will be executed. Statement \"else {\" is covered. \n10. Calculation and Program Output : always executed. Statements \"long res = 1;\", \"res = (res * i) % MOD;\", \"System.out.println(Math.floorMod(res, MOD));\" are covered. \n11. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>       int n = scanner.nextInt();\n>       int k = scanner.nextInt();\n>       int[] A = new int[n];\n>       for (int i = 0; i < n; i++) {\n>           A[i] = scanner.nextInt();\n>       }\n>       List<Integer> pos = new ArrayList<>();\n>       List<Integer> neg = new ArrayList<>();\n>       int zero = 0;\n>       for (int i : A) {\n>           if (i > 0) {\n>               pos.add(i);\n>           } else if (i < 0) {\n>               neg.add(i);\n>           } else {\n>               zero++;\n>           }\n>       }\n>       if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>           System.out.println(0);\n>           return;\n>       }\n>       if (n == k) {\n>           long res = 1;\n>           for (int i : A) {\n>               res = (res * i) % MOD;\n>           }\n>           System.out.println(Math.floorMod(res, MOD));\n>           return;\n>       }\n>       pos.sort(Comparator.reverseOrder());\n>       neg.sort(Comparator.reverseOrder());\n>       BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>       BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>       BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>       posMulLft[0] = BigInteger.ONE;\n>       negMulLft[0] = BigInteger.ONE;\n>       negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>       for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>           posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>       }\n>       for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>           negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>       }\n>       for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>           negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>       }\n>       BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>       for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>           if (k - i < negMulLft.length) {\n>               res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>           }\n>       }\n>       for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>           if (k - i < posMulLft.length) {\n>               res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>           }\n>       }\n>       System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-2\n4\n-3\n0\n5",
      "test_mutations": [
        "Test Case Input:\n-3\n0\n2\n-2\n4",
        "Test Case Input:\n3\n0\n-2\n0\n2",
        "Test Case Input:\n-3\n0\n1\n-2\n3",
        "Test Case Input:\n0\n2\n4\n6\n8",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n1\n0\n-1",
        "Test Case Input:\n\"3.5\"\n\"2\"\n\"-2\"\n\"0\"\n\"2\"",
        "Test Case Input:\n5\n3\n-2\n4\n0\n-3\n1",
        "Test Case Input:\n-2\n4\n-3\n0\n5"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered. \n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", and \"int[] A = new int[n];\" are covered. \n5. For loop Execution : The for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n6. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed. \n7. List Initialization : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", and \"int zero = 0;\" are covered. \n8. For each loop : The loop will iterate over all elements of array A. The if-else condition inside the loop will be executed accordingly. Statement \"for (int i : A) {\" will be covered. \n9. If - Else condition : Since the size of pos and neg lists are both zero, the first condition of the if statement is satisfied. Statement \"if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\" is covered. The return statement inside the if block is not executed. \n10. Nested If condition : Since n is not equal to k, the nested if condition is not satisfied. The block of code inside the nested if condition is not executed. \n11. Sorting Lists : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered. \n12. Array Initialization : always executed. Statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", and \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" are covered. \n13. Array Assignment : always executed. Statements \"posMulLft[0] = BigInteger.ONE;\", \"negMulLft[0] = BigInteger.ONE;\", and \"negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\" are covered. \n14. For loop Execution : The for loop condition (i < Math.min(k + 1, posMulLft.length)) is true, and the loop block will be executed. Statement \"for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\" will be covered. \n15. For loop contents : always executed. Statements \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", and \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\"\n16. BigInteger Comparison and Assignment : always executed. Statements \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" and \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" are covered. \n17. Program Output : always executed. Statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\" is covered. \n18. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2\n0\n4\n2",
      "test_mutations": [
        "Test Case Input:\n\"abc\"\n2\n-2\n0\n2",
        "Test Case Input:\n2\n2\n-1\n0",
        "Test Case Input:\n\"abc\"\n2\n-2\n0\n2",
        "Test Case Input:\n\"3\" \n\"2\"\n\"-2\"\n\"0\"\n\"2\"",
        "Test Case Input:\n\"abc\"\n2\n-2\n0\n2",
        "Test Case Input:\n\"abc\"\n2\n1\n-3\n0\n5",
        "Test Case Input:\n\"abc\"\n2\n-2\n0\n2",
        "Test Case Input:\n\"3\" \n2 \n-2 \n0 \n2",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"-2\"\n\"0\"\n\"4\"\n\"2\""
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case-\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", and \"int[] A = new int[n];\" are covered. \n5. For loop Execution : Since n is 5, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n6. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed 5 times. \n7. List Initialization : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", and \"int zero = 0;\" are covered. \n8. For loop on Array A : always executed. Statement \"for (int i : A) {\" is covered. \n9. If - Else condition : Since the size of pos and neg lists is 0, the if condition '(pos.size() + neg.size() < k)' is satisfied. Statement 'if (pos.size() + neg.size() < k || (n == k && zero > 0)) {' is covered. Since the condition is true, the if block will be executed. \n10. System.out.println Statement : always executed. Statement \"System.out.println(0);\" is covered. \n11. Return Statement : always executed. Statement \"return;\" is covered. \n12. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n1\na\n1",
      "test_mutations": [
        "Test Case Input:\n-2\n0\n-3\n0\n5",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n-3\n0\n-2\n5\n2",
        "Test Case Input:\n\"3\" (String)\n\"2\" (String)\n\"-2\" (String)\n\"0\" (String)\n\"2\" (String)",
        "Test Case Input:\n\"3\\n2\\n-2\\n0\\n2\"",
        "Test Case Input:\n\"3\" 2 -2 0 2",
        "Test Case Input:\na\n2\n-2\n0\n2",
        "Test Case Input:\n\"3\n2\n-2\n0\n2\"\n\nTest Case Input:\n\"-2\n4\n-3\n0\n5\"\n\nTest Case Input:\n\"5\n3\n-2\n0\n4\n2\"",
        "Test Case Input:\n-2\n4\n-3\n0\n5",
        "Test Case Input:\n1\n1\na\n1"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n1. Import statements: Import statements are always executed. The statement \"import java.math.BigInteger;\" will be covered.\n2. Main class declaration: Always executed. The statement \"public class Main {\" is covered.\n3. Main method declaration: Always executed. The statement \"public static void main(String[] args) {\" is covered.\n4. User input and program output: The first two input statements are always executed. The statements \"int n = scanner.nextInt();\" and \"int k = scanner.nextInt();\" are covered.\n5. Array initialization: The for loop will execute once since n=1. The statement \"int[] A = new int[n];\" is covered.\n6. Array input: The for loop will execute once and the value of A[0] will be assigned. The statement \"A[i] = scanner.nextInt();\" is covered.\n7. List initialization: The statements \"List<Integer> pos = new ArrayList<>();\" and \"List<Integer> neg = new ArrayList<>();\" are covered.\n8. Variable initialization: The statement \"int zero = 0;\" is covered.\n9. Array traversal and list population: The for-each loop will execute once and the value of i will be assigned. The statements within the loop \"if (i > 0) { pos.add(i); } else if (i < 0) { neg.add(i); } else { zero++; }\" are covered.\n10. If condition: Since n=1 and k=1, the condition \"(n == k && zero > 0)\" is false. The if block is not executed. The statement \"System.out.println(0);\" is not covered.\n11. Sort lists: The statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n12. Array initialization: The statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", and \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" are covered.\n13. Array initialization: The statements \"posMulLft[0] = BigInteger.ONE;\", \"negMulLft[0] = BigInteger.ONE;\", and \"negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\" are covered.\n14. Loop for array multiplication: The first for loop will execute once. The statements within the loop \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", and \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\"\n15. Variable initialization: The statement \"BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\" is covered.\n16. Loop for maximum product calculation: The first for loop will execute once. The statement \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" is covered.\n17. Loop for maximum product calculation: The second for loop will execute once. The statement \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" is covered.\n18. Program output: The statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\"\n19. Closing brackets: Always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n1\n0",
      "test_mutations": [
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n\"5\" \n\"3\" \n\"-2\" \n\"0\" \n\"4\" \n\"2\"",
        "Test Case Input:\n1\n1\na\n1",
        "Test Case Input:\n\"5\"\n\"3\"\n\"-2\"\n\"0\"\n\"4\"\n\"2\"",
        "Test Case Input:\n1\n1\na\n1",
        "Test Case Input:\n-2\n4\n0\n0\n5",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n0\n3\nTest Case Input:\n5\n0\n1\n2\n3\n4\nTest Case Input:\n3\n3\n1\n2\n3\nTest Case Input:\n3\n2\n1\n2\n-3\nTest Case Input:\n3\n2\n1\n2\n3",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n1\n1\n0"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.math.BigInteger;\" will be covered. \n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" are covered. \n4. For loop Execution : Since n is 1, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n5. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed. \n6. ArrayList Initialization and Counting : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", \"int zero = 0;\" are covered. \n7. For each loop and Arraylist population : always executed. Statements \"for (int i : A) {\" and \"if (i > 0) {\" will be covered. \n8. Else if condition : always executed. Statement \"else if (i < 0) {\" will be covered. \n9. Else condition : always executed. Statement \"else {\" will be covered. \n10. If condition 1 : always executed. Statement \"if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\" will be covered. \n11. If condition 2 : always executed. Statement \"if (n == k) {\" will be covered. \n12. For loop for multiplication : always executed. Statement \"for (int i : A) {\" will be covered. \n13. Math.floorMod() and System.out.println() : always executed. Statements \"System.out.println(Math.floorMod(res, MOD));\" and \"System.out.println(0);\" will be covered. \n14. Sort ArrayLists : always executed. Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" will be covered. \n15. Array Initialization : always executed. Statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" will be covered. \n16. Array Initialization and Loop : always executed. Statements \"posMulLft[0] = BigInteger.ONE;\", \"negMulLft[0] = BigInteger.ONE;\", \"negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\" will be covered. \n17. For loop for multiplication : always executed. Statements \"for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\" and \"for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\" will be covered. \n18. For loop for multiplication : always executed. Statement \"for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\" will be covered. \n19. BigInteger comparison : always executed. Statements \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" and \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" will be covered. \n20. System.out.println() : always executed. Statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));}\" will be covered. \n21. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3\n2\n-2\n0\n2",
      "test_mutations": [
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n\"a\"\n\"b\"\n\"c\"\n\"d\"\n\"e\"",
        "Test Case Input:\n\"abc\"\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n4\n6\n8",
        "Test Case Input:\n\"3\" 2 -2 0 2",
        "Test Case Input:\n\"3\\n2\\n-2\\n0\\n2\"",
        "Test Case Input:\na\n2\n-2\n0\n2",
        "Test Case Input:\na\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n-2\n0\n2"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" and \"A[i] = scanner.nextInt();\" are covered. \n5. For loop Execution : Since n is 3, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered. \n6. For loop contents : user input statements are always executed. Statement \"A[i] = scanner.nextInt();\" will be executed. \n7. List Initialization : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\" and \"int zero = 0;\" are covered. \n8. For each loop Execution : Since A is not empty, the loop block will be executed. Statement \"for (int i : A) {\" will be covered. \n9. If - Else condition : Since n is not equal to k, the if condition '(n == k && zero > 0)' is not satisfied. Statement 'if (n == k && zero > 0) {' is not covered. The condition '(pos.size() + neg.size() < k)' is satisfied so the if block will be executed. Statements 'if (pos.size() + neg.size() < k || (n == k && zero > 0)) {' and \"System.out.println(0);\" are covered. \n10. If condition is not satisfied : Since the if condition is not satisfied, the else block will be executed. Statement 'if (n == k) {' is not covered. \n11. For loop Execution : Since pos and neg are not empty, the for loop condition (i < Math.min(k + 1, posMulLft.length)) is true, and the loop block will be executed. Statement \"for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\" will be covered. \n12. For loop contents : always executed. Statements \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", and \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\"\nwill be executed. \n13. BigInteger Calculations : always executed. Statements \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", and \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\"\nwill be executed.\n14. BigInteger Result Calculation : always executed. Statements \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" and \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" will be executed. \n15. System Output : always executed. Statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\" is covered. \n16. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n\n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n1\nnull",
      "test_mutations": [
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n1\n1\n-5\n0\n3",
        "Test Case Input:\n5\n2\n-2\n0\n4\n2",
        "Test Case Input:\n1\n1\na\n1",
        "Test Case Input:\n4\n2\n-3\n0\n5",
        "Test Case Input:\n0\n0\n0\n0\n0",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n\"3\\n2\\n-2\\n0\\n2\"",
        "Test Case Input:\n0\n0\n0\n0\n0",
        "Test Case Input:\n1\n1\nnull"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" and \"import java.util.*;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\", \"for (int i = 0; i < n; i++) { A[i] = scanner.nextInt(); }\" are covered. \n5. List Initialization : always executed. Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", \"int zero = 0;\" are covered. \n6. For loop Execution : Statement \"for (int i : A) {\" is covered. \n7. If - Else condition : Since n != k, the if condition 'n == k' is not satisfied. Statement 'if (n == k) {' is not covered. The else condition is satisfied so statements 'else {' and \"long res = 1;\" are covered. \n8. For loop within else condition : Statement \"for (int i : A) {\" is covered. \n9. Arithmetic Operations : Statements within the for loop will be executed. Statements \"res = (res * i) % MOD;\", \"System.out.println(Math.floorMod(res, MOD));\" are covered. \n10. List Sorting : Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered. \n11. Array Initialization : Statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" are covered. \n12. Array Calculations : Statements within the for loops will be executed. Statements \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\", \"BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\" are covered. \n13. Nested For loops : Statements within the nested for loops will be executed. Statements \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\", \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" are covered. \n14. Final Output : Statements \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\", \"private static final Scanner scanner = new Scanner(System.in);\" are covered. \nClosing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n1\n2\n3\n4\n5",
      "test_mutations": [
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n2\n3\n-2\n0\n2",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n\"3\" (String)\n2\n-2\n0\n2",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n\"1\"\n\"2\"\n\"3\"\n\"4\"\n\"5\""
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "The plan for step by step execution of the given Java program and test case is as follows:\n\n1. Import statements: The import statements are always executed. The statement \"import java.math.BigInteger;\" will be covered.\n\n2. Main Class Declaration: The main class declaration is always executed. The statement \"public class Main {\" is covered.\n\n3. Main method declaration: The main method declaration is always executed. The statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output: The user input statements are always executed. The statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", and \"int[] A = new int[n];\" are covered.\n\n5. For loop Execution: The for loop condition (i < n) is true, and the loop block will be executed. The statement \"for (int i = 0; i < n; i++) {\" is covered.\n\n6. For loop contents: The user input statement is always executed. The statement \"A[i] = scanner.nextInt();\" will be executed.\n\n7. List Initialization: The list initialization statements are always executed. The statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", and \"int zero = 0;\" are covered.\n\n8. For each loop: The for each loop iterates over each element in the array A. The loop block will be executed for each iteration. The statement \"for (int i : A) {\" is covered.\n\n9. If-Else condition 1: The if condition '(pos.size() + neg.size() < k || (n == k && zero > 0))' is not satisfied. The else condition will be executed. The statements \"System.out.println(0);\" and \"return;\" are not covered.\n\n10. If condition 2: The if condition '(n == k)' is not satisfied. The else block will be executed. The statements \"long res = 1;\", \"for (int i : A) {\", and \"System.out.println(Math.floorMod(res, MOD));\" are not covered.\n\n11. List Sorting: The list sorting statements are always executed. The statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are covered.\n\n12. Array Initialization: The array initialization statements are always executed. The statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", and \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" are covered.\n\n13. Array Element Assignment: The array element assignment statements are always executed. The statements \"posMulLft[0] = BigInteger.ONE;\", \"negMulLft[0] = BigInteger.ONE;\", and \"negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\" are covered.\n\n14. For loop 1: The for loop condition (i < Math.min(k + 1, posMulLft.length)) is true, and the loop block will be executed. The statement \"for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\" is covered.\n\n15. For loop 1 contents: The for loop block will be executed for each iteration. The statement \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\"\nis covered.\n\n16. For loop 2: The for loop condition (i < Math.min(k + 1, negMulLft.length)) is true, and the loop block will be executed. The statement \"for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\" is covered.\n\n17. For loop 2 contents: The for loop block will be executed for each iteration. The statement \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\"\nis covered.\n\n18. For loop 3: The for loop condition (i >= 0 && j > 0) is not satisfied. The loop block will not be executed. The statement \"for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\" is not covered.\n\n19. BigInteger calculation: The BigInteger calculations are always executed. The statements \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" and \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\"\nare covered.\n\n20. Program output: The statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\" is covered.\n\n21. Closing Brackets: The closing brackets are always covered.\n\nFinal code coverage of the Java program based on its test case and given step-by-step reasoning for execution is:\n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3\n2\n-2\n0\n2",
      "test_mutations": [
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n-1\n2\n-3\n0\n5",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n1\n2\n3\n4\n5",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n1\n1\nnull",
        "Test Case Input:\n3\n2\n-2\n0\n2",
        "Test Case Input:\n2\n3\n-1\n0",
        "Test Case Input:\n3\n2\n-2\n0\n2"
      ],
      "initial_code": "import java.math.BigInteger;\nimport java.util.*;\npublic class Main {\n  private static final int MOD = 1_000_000_007;\n  public static void main(String[] args) {\n    int n = scanner.nextInt();\n    int k = scanner.nextInt();\n    int[] A = new int[n];\n    for (int i = 0; i < n; i++) {\n      A[i] = scanner.nextInt();\n    }\n    List<Integer> pos = new ArrayList<>();\n    List<Integer> neg = new ArrayList<>();\n    int zero = 0;\n    for (int i : A) {\n      if (i > 0) {\n        pos.add(i);\n      } else if (i < 0) {\n        neg.add(i);\n      } else {\n        zero++;\n      }\n    }\n    if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n      System.out.println(0);\n      return;\n    }\n    if (n == k) {\n      long res = 1;\n      for (int i : A) {\n        res = (res * i) % MOD;\n      }\n      System.out.println(Math.floorMod(res, MOD));\n      return;\n    }\n    pos.sort(Comparator.reverseOrder());\n    neg.sort(Comparator.reverseOrder());\n    BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n    BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n    BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n    posMulLft[0] = BigInteger.ONE;\n    negMulLft[0] = BigInteger.ONE;\n    negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n    for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n      posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n    }\n    for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n      negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n    }\n    for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n      negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n    }\n    BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n    for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n      if (k - i < negMulLft.length) {\n        res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n      }\n    }\n    for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n      if (k - i < posMulLft.length) {\n        res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n      }\n    }\n    System.out.println(res.mod(BigInteger.valueOf(MOD)));\n  }\n  private static final Scanner scanner = new Scanner(System.in);\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.math.BigInteger;\" and \"import java.util.*;\" will be covered.\n2. Main class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"int n = scanner.nextInt();\", \"int k = scanner.nextInt();\", \"int[] A = new int[n];\" will be covered.\n5. For loop Execution : Since n is 3, the for loop condition (i < n) is true, and the loop block will be executed. Statement \"for (int i = 0; i < n; i++) {\" will be covered.\n6. For loop contents : user input statement is always executed. Statement \"A[i] = scanner.nextInt();\" will be executed.\n7. List Initialization and Element Additions : Statements \"List<Integer> pos = new ArrayList<>();\", \"List<Integer> neg = new ArrayList<>();\", \"int zero = 0;\" are always executed.\n8. For Each loop : Since the array A has 3 elements, the for each loop will execute 3 times. Statements \"for (int i : A) {\" and \"}\" will be covered.\n9. If conditions : Since k=2, the if condition 'pos.size() + neg.size() < k' is false. Statements \"if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\" and \"System.out.println(0);\" will not be covered.\n10. Nested If condition : Since n != k, the nested if condition is not satisfied. Statements \"if (n == k) {\" and \"}\" will not be covered.\n11. Sorting Lists : Statements \"pos.sort(Comparator.reverseOrder());\" and \"neg.sort(Comparator.reverseOrder());\" are executed.\n12. Array Declaration and Initialization : Statements \"BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\", \"BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\", \"BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\" are executed.\n13. Array Assignments : Statements \"posMulLft[0] = BigInteger.ONE;\", \"negMulLft[0] = BigInteger.ONE;\", and \"negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\" are executed.\n14. For loop Execution : Since k=2, the for loop condition (i < Math.min(k + 1, posMulLft.length)) is true, and the loop block will be executed. Statement \"for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\" will be covered.\n15. Array Assignments : Statements \"posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\", \"negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\", and \"negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\"\" are executed.\n16. BigInteger Comparison and Maximum : Since k-i is always less than negMulLft.length, the if condition is satisfied. Statement \"res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\" is executed.\n17. For loop Execution : Since k=2, the for loop condition (i < Math.min(k + 1, negMulRgt.length)) is true, and the loop block will be executed. Statement \"for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\" will be covered.\n18. BigInteger Comparison and Maximum : Since k-i is always less than posMulLft.length, the if condition is satisfied. Statement \"res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\" is executed.\n19. Program Output : Statement \"System.out.println(res.mod(BigInteger.valueOf(MOD)));\" is executed.\n20. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.math.BigInteger;\n> import java.util.*;\n> public class Main {\n>   private static final int MOD = 1_000_000_007;\n>   public static void main(String[] args) {\n>     int n = scanner.nextInt();\n>     int k = scanner.nextInt();\n>     int[] A = new int[n];\n>     for (int i = 0; i < n; i++) {\n>       A[i] = scanner.nextInt();\n>     }\n>     List<Integer> pos = new ArrayList<>();\n>     List<Integer> neg = new ArrayList<>();\n>     int zero = 0;\n>     for (int i : A) {\n>       if (i > 0) {\n>         pos.add(i);\n>       } else if (i < 0) {\n>         neg.add(i);\n>       } else {\n>         zero++;\n>       }\n>     }\n>     if (pos.size() + neg.size() < k || (n == k && zero > 0)) {\n>       System.out.println(0);\n>       return;\n>     }\n>     if (n == k) {\n>       long res = 1;\n>       for (int i : A) {\n>         res = (res * i) % MOD;\n>       }\n>       System.out.println(Math.floorMod(res, MOD));\n>       return;\n>     }\n>     pos.sort(Comparator.reverseOrder());\n>     neg.sort(Comparator.reverseOrder());\n>     BigInteger[] posMulLft = new BigInteger[pos.size() + 1];\n>     BigInteger[] negMulLft = new BigInteger[neg.size() + 1];\n>     BigInteger[] negMulRgt = new BigInteger[neg.size() + 1];\n>     posMulLft[0] = BigInteger.ONE;\n>     negMulLft[0] = BigInteger.ONE;\n>     negMulRgt[negMulRgt.length - 1] = BigInteger.ONE;\n>     for (int i = 1; i < Math.min(k + 1, posMulLft.length); i++) {\n>       posMulLft[i] = posMulLft[i - 1].multiply(BigInteger.valueOf(pos.get(i - 1)));\n>     }\n>     for (int i = 1; i < Math.min(k + 1, negMulLft.length); i++) {\n>       negMulLft[i] = negMulLft[i - 1].multiply(BigInteger.valueOf(neg.get(i - 1)));\n>     }\n>     for (int i = negMulRgt.length - 2, j = k; i >= 0 && j > 0; i--, j--) {\n>       negMulRgt[i] = negMulRgt[i + 1].multiply(BigInteger.valueOf(neg.get(i)));\n>     }\n>     BigInteger res = BigInteger.valueOf(Long.MIN_VALUE);\n>     for (int i = 0; i < Math.min(k + 1, posMulLft.length); i++) {\n>       if (k - i < negMulLft.length) {\n>         res = posMulLft[i].multiply(negMulLft[k - i]).max(res);\n>       }\n>     }\n>     for (int i = 0; i < Math.min(k + 1, negMulRgt.length); i++) {\n>       if (k - i < posMulLft.length) {\n>         res = negMulRgt[negMulRgt.length - 1 - i].multiply(posMulLft[k - i]).max(res);\n>       }\n>     }\n>     System.out.println(res.mod(BigInteger.valueOf(MOD)));\n>   }\n>   private static final Scanner scanner = new Scanner(System.in);\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    }
  ]
}