{
    "submission_id": "s631603326",
    "cycles": [
        {
            "test_case": "Test Case Input:\n5 5 2\n1 1 3 3\n4 4 5 5",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To predict the code coverage for the provided Python program using the given test case, we will follow a step-by-step execution plan and mark each line of code based on whether it is executed (`>`) or not executed (`!`). If an exception occurs, we will specify the exception.\n\n### Test Case Input:\n```\n5 5 2\n1 1 3 3\n4 4 5 5\n```\n\n### Python Program:\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R, C, N = map(int, input().split())\n    P = []\n    X = {0, R}\n    Y = {0, C}\n    M = 0\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n            if y1 == 0:\n                L1 = x1\n            elif x1 == R:\n                L1 = R + y1\n            elif y1 == C:\n                L1 = 2 * R + C - x1\n            else:\n                L1 = 2 * (R + C) - y1\n            if y2 == 0:\n                L2 = x2\n            elif x2 == R:\n                L2 = R + y2\n            elif y2 == C:\n                L2 = 2 * R + C - x2\n            else:\n                L2 = 2 * (R + C) - y2\n            P.append([min(L1, L2), max(L1, L2)])\n    P = sorted(P, key=lambda a: a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1, x2 = P[i]\n        if Q == []:\n            Q.append([x1, x2])\n        else:\n            while Q[-1][1] < x1 and Q != []:\n                Q.pop()\n            if Q == []:\n                Q.append([x1, x2])\n            else:\n                y1, y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1, x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()\n```\n\n### Step-by-Step Execution and Code Coverage Plan:\n\n1. **Import Statements**: Always executed.\n    ```python\n    > def main():\n    >     import sys\n    ```\n\n2. **Input Reading**:\n    ```python\n    >     input = sys.stdin.readline\n    ```\n\n3. **Reading Initial Inputs**:\n    ```python\n    >     R, C, N = map(int, input().split())\n    ```\n\n4. **Variable Initializations**:\n    ```python\n    >     P = []\n    >     X = {0, R}\n    >     Y = {0, C}\n    >     M = 0\n    ```\n\n5. **For Loop Execution**: Since `N = 2`, the loop will run twice.\n    ```python\n    >     for i in range(N):\n    ```\n\n6. **First Loop Iteration** (`1 1 3 3`):\n    - **Reading Inputs**:\n        ```python\n        >         x1, y1, x2, y2 = map(int, input().split())\n        ```\n\n    - **Condition Check**: Neither `x1` nor `y1` is in `X` or `Y`, and neither `x2` nor `y2` is in `X` or `Y`. So, none of the nested if-statements are executed.\n        ```python\n        !         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n        ```\n\n7. **Second Loop Iteration** (`4 4 5 5`):\n    - **Reading Inputs**:\n        ```python\n        >         x1, y1, x2, y2 = map(int, input().split())\n        ```\n    \n    - **Condition Check**: Neither `x1` nor `y1` is in `X` or `Y`, and neither `x2` nor `y2` is in `X` or `Y`. So, none of the nested if-statements are executed.\n        ```python\n        !         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n        ```\n\n8. **Sorting and Reinitializing P**:\n    ```python\n    >     P = sorted(P, key=lambda a: a[0])\n    >     M = len(P)\n    ```\n\n9. **Flag Initialization**:\n    ```python\n    >     flag = 0\n    ```\n\n10. **Second For Loop Execution**: Since `M = 0`, the loop will not run.\n    ```python\n    !     for i in range(M):\n    ```\n\n11. **Flag Check and Output**:\n    ```python\n    >     if flag == 1:\n    !         print(\"NO\")\n    >     else:\n    >         print(\"YES\")\n    ```\n\n12. **Main Function Call**:\n    ```python\n    > main()\n    ```\n\n### Final Code Coverage:\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R, C, N = map(int, input().split())\n>     P = []\n>     X = {0, R}\n>     Y = {0, C}\n>     M = 0\n>     for i in range(N):\n>         x1, y1, x2, y2 = map(int, input().split())\n!         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n!             if y1 == 0:\n!                 L1 = x1\n!             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n!             if y2 == 0:\n!                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n!             P.append([min(L1, L2), max(L1, L2)])\n>     P = sorted(P, key=lambda a: a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n!     for i in range(M):\n!         x1, x2 = P[i]\n!         if Q == []:\n!             Q.append([x1, x2])\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n>     if flag == 1:\n!         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">","!",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">","!",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n0 0 0\n0 0 0 0\n0 0 0 0",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "### Plan for Step-by-Step Execution and Code Coverage:\n\n1. **Import Statements**: Import statements are always executed. \n   - `import sys` will be covered.\n   \n2. **Main Function Declaration**: The main function declaration is always executed.\n   - `def main():` will be covered.\n\n3. **Reading Input**: The input will be read using `sys.stdin.readline`.\n   - `input = sys.stdin.readline` will be covered.\n\n4. **Reading Initial Values**: The first line of input is parsed to get `R`, `C`, and `N`.\n   - `R,C,N = map(int,input().split())` will be covered.\n\n5. **Initialization**: Initialize lists and sets.\n   - `P = []` will be covered.\n   - `X = {0,R}` will be covered.\n   - `Y = {0,C}` will be covered.\n   - `M = 0` will be covered.\n\n6. **For Loop Execution**: The for loop runs `N` times.\n   - `for i in range(N):` will be executed `N` times, but since `N=0`, the loop body will not be executed.\n   - As a result, the inner statements within the for loop will not be covered in this case.\n\n7. **Sorting List `P` and Re-initializing `M`**: List `P` is sorted and `M` is set to its length.\n   - `P = sorted(P, key = lambda a:a[0])` will be covered.\n   - `M = len(P)` will be covered.\n\n8. **Initializing Other Variables**: Flags and other variables are initialized.\n   - `flag = 0` will be covered.\n   - `Q = []` will be covered.\n\n9. **Second For Loop Execution**: Loop through sorted list `P`.\n   - `for i in range(M):` will be executed `M` times, but since `M=0`, the loop body will not be executed.\n   - As a result, the inner statements within the second for loop will not be covered in this case.\n\n10. **Condition Check and Print Statements**: Check the flag and print the result.\n    - `if flag == 1:` will be covered.\n    - Given the flag is `0` (default value), `else:` will be covered.\n    - `print(\"YES\")` will be covered.\n\n11. **Closing Bracket of Main Function**: The closing bracket of the main function is always executed.\n    - `main()` will be covered.\n\n### Final Code Coverage Based on Test Case:\n\n```python\n> import sys\n> def main():\n>     input = sys.stdin.readline\n>     R,C,N = map(int,input().split())\n>     P = []\n>     X = {0,R}\n>     Y = {0,C}\n>     M = 0\n!     for i in range(N):\n!         x1,y1,x2,y2 = map(int,input().split())\n!         if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n!             if y1==0:\n!                 L1 = x1\n!             elif x1==R:\n!                 L1 = R+y1\n!             elif y1==C:\n!                 L1 = 2*R + C - x1\n!             else:\n!                 L1 = 2*(R+C) - y1\n!             if y2==0:\n!                 L2 = x2\n!             elif x2==R:\n!                 L2 = R+y2\n!             elif y2==C:\n!                 L2 = 2*R + C - x2\n!             else:\n!                 L2 = 2*(R+C) - y2\n!             P.append([min(L1,L2), max(L1,L2)])\n>     P = sorted(P, key = lambda a:a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n!     for i in range(M):\n!         x1,x2 = P[i]\n!         if Q == []:\n!             Q.append([x1,x2])\n!         else:\n!             while Q[-1][1] < x1 and Q!=[]:\n!                 Q.pop()\n!             if Q==[]:\n!                 Q.append([x1,x2])\n!             else:\n!                 y1,y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1,x2])\n>     if flag == 1:\n!         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```\n\n### Output:\n```\nYES\n```\n\nNote: The test case does not raise an exception because the input values result in `N=0`, which means the for loop that could potentially raise an exception isn't executed.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">","!",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">","!",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n1 0 1\n1 1 2 2",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "Let's break down the execution plan step by step for the given Python program with the provided test case inputs and then predict the code coverage.\n\n**Test Case Inputs:**\n```\n1 0 1\n1 1 2 2\n```\n\n**Python Program:**\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R, C, N = map(int, input().split())\n    P = []\n    X = {0, R}\n    Y = {0, C}\n    M = 0\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n            if y1 == 0:\n                L1 = x1\n            elif x1 == R:\n                L1 = R + y1\n            elif y1 == C:\n                L1 = 2 * R + C - x1\n            else:\n                L1 = 2 * (R + C) - y1\n            if y2 == 0:\n                L2 = x2\n            elif x2 == R:\n                L2 = R + y2\n            elif y2 == C:\n                L2 = 2 * R + C - x2\n            else:\n                L2 = 2 * (R + C) - y2\n            P.append([min(L1, L2), max(L1, L2)])\n    P = sorted(P, key=lambda a: a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1, x2 = P[i]\n        if Q == []:\n            Q.append([x1, x2])\n        else:\n            while Q[-1][1] < x1 and Q != []:\n                Q.pop()\n            if Q == []:\n                Q.append([x1, x2])\n            else:\n                y1, y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1, x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nmain()\n```\n\n**Execution Plan:**\n\n1. **Import statements and function definition**:\n   - The import statement `import sys` and the function definition `def main():` are always executed.\n   - Input function `input = sys.stdin.readline` is always executed.\n\n2. **Reading initial inputs**:\n   - Statements `R, C, N = map(int, input().split())` are executed, with values `R = 1`, `C = 0`, `N = 1` from the first line of input.\n\n3. **Initialization**:\n   - Lists and sets initialization `P = []`, `X = {0, R}`, `Y = {0, C}`, and `M = 0` are executed.\n\n4. **For loop execution**:\n   - The for loop `for i in range(N):` executes once since `N = 1`.\n\n5. **Reading edge inputs in the loop**:\n   - Statements `x1, y1, x2, y2 = map(int, input().split())` are executed with values from the second line of input: `x1 = 1`, `y1 = 1`, `x2 = 2`, `y2 = 2`.\n\n6. **Conditions inside the loop**:\n   - The if condition `(x1 in X or y1 in Y) and (x2 in X or y2 in Y)` is evaluated. Given that `X = {0, 1}` and `Y = {0, 0}`, neither `1 in Y` nor `2 in X` or `2 in Y` holds true. Therefore, the entire if block is skipped.\n\n7. **Sorting and calculating M**:\n   - Sorting `P = sorted(P, key=lambda a: a[0])` is executed.\n   - Length calculation `M = len(P)` is executed. Since `P` is empty, `M = 0`.\n\n8. **Flag initialization and Q list**:\n   - Statements `flag = 0` and `Q = []` are executed.\n\n9. **Second for loop execution**:\n   - The for loop `for i in range(M):` does not execute since `M = 0`.\n\n10. **Flag check and printing result**:\n    - The if condition `if flag == 1:` is checked and fails since `flag = 0`.\n    - Else block `else:` and `print(\"YES\")` are executed.\n\n**Final Code Coverage:**\n\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R, C, N = map(int, input().split())\n>     P = []\n>     X = {0, R}\n>     Y = {0, C}\n>     M = 0\n>     for i in range(N):\n>         x1, y1, x2, y2 = map(int, input().split())\n!         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n!             if y1 == 0:\n!                 L1 = x1\n!             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n!             if y2 == 0:\n!                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n!             P.append([min(L1, L2), max(L1, L2)])\n>     P = sorted(P, key=lambda a: a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n!     for i in range(M):\n!         x1, x2 = P[i]\n!         if Q == []:\n!             Q.append([x1, x2])\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n>     if flag == 1:\n!         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```\n\n**Output:**\n```\nYES\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n1 1 1\n1 1 1 1",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To develop a plan for step-by-step execution of the given Python program and predict the code coverage, we will execute the program with the provided test case input, and determine which lines are executed. Here\u2019s the plan:\n\n**Test Case Input:**\n```\n1 1 1\n1 1 1 1\n```\n\n**PYTHON PROGRAM:**\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R, C, N = map(int, input().split())\n    P = []\n    X = {0, R}\n    Y = {0, C}\n    M = 0\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n            if y1 == 0:\n                L1 = x1\n            elif x1 == R:\n                L1 = R + y1\n            elif y1 == C:\n                L1 = 2 * R + C - x1\n            else:\n                L1 = 2 * (R + C) - y1\n            if y2 == 0:\n                L2 = x2\n            elif x2 == R:\n                L2 = R + y2\n            elif y2 == C:\n                L2 = 2 * R + C - x2\n            else:\n                L2 = 2 * (R + C) - y2\n            P.append([min(L1, L2), max(L1, L2)])\n    P = sorted(P, key=lambda a: a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1, x2 = P[i]\n        if Q == []:\n            Q.append([x1, x2])\n        else:\n            while Q[-1][1] < x1 and Q != []:\n                Q.pop()\n            if Q == []:\n                Q.append([x1, x2])\n            else:\n                y1, y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1, x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()\n```\n\n**Step-by-step Execution:**\n\n1. **Import statements**: Import statements are always executed.\n   ```python\n   > def main():\n   >     import sys\n   >     input = sys.stdin.readline\n   ```\n\n2. **Reading initial inputs**: The `input` function is called to read the first line of inputs.\n   ```python\n   >     R, C, N = map(int, input().split())\n   ```\n\n3. **Initializing variables**: Initialization of variables `P`, `X`, `Y`, and `M`.\n   ```python\n   >     P = []\n   >     X = {0, R}\n   >     Y = {0, C}\n   >     M = 0\n   ```\n\n4. **For loop execution**: The for loop runs `N` times. Since `N` is 1, the loop will execute once.\n   ```python\n   >     for i in range(N):\n   ```\n\n5. **Reading division inputs**: Inside the loop, the second line of inputs is read.\n   ```python\n   >         x1, y1, x2, y2 = map(int, input().split())\n   ```\n\n6. **Checking conditions**: The `if` statement checks if conditions involving `x1`, `y1`, `x2`, and `y2` are met.\n   ```python\n   >         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n   ```\n\n7. **Evaluating conditions and appending to list**: Since `x1`, `y1`, `x2`, and `y2` match the conditions, the nested `if-elif` statements are executed, and `P` is appended.\n   ```python\n   >             if y1 == 0:\n   >                 L1 = x1\n   >             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n   >             if y2 == 0:\n   >                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n   >             P.append([min(L1, L2), max(L1, L2)])\n   ```\n\n8. **Sorting list**: The list `P` is sorted.\n   ```python\n   >     P = sorted(P, key=lambda a: a[0])\n   ```\n\n9. **Updating length of list**: The length of `P` is assigned to `M`.\n   ```python\n   >     M = len(P)\n   ```\n\n10. **Initializing flag and queue**: Variables `flag` and `Q` are initialized.\n    ```python\n    >     flag = 0\n    >     Q = []\n    ```\n\n11. **Processing intervals**: The second `for` loop processes the intervals in `P`.\n    ```python\n    >     for i in range(M):\n    ```\n\n12. **Handling intervals**: If `Q` is empty, append the interval to `Q`.\n    ```python\n    >         x1, x2 = P[i]\n    >         if Q == []:\n    >             Q.append([x1, x2])\n    ```\n\n13. **Processing non-empty queue**: Since `Q` is not empty, the while loop checks and pops elements if conditions are met.\n    ```python\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n    ```\n\n14. **Checking flag**: Based on the value of `flag`, print the appropriate message.\n    ```python\n>     if flag == 1:\n>         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n    ```\n\n**Final Code Coverage:**\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R, C, N = map(int, input().split())\n>     P = []\n>     X = {0, R}\n>     Y = {0, C}\n>     M = 0\n>     for i in range(N):\n>         x1, y1, x2, y2 = map(int, input().split())\n>         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n>             if y1 == 0:\n>                 L1 = x1\n!             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n>             if y2 == 0:\n>                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n>             P.append([min(L1, L2), max(L1, L2)])\n>     P = sorted(P, key=lambda a: a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n>     for i in range(M):\n>         x1, x2 = P[i]\n>         if Q == []:\n>             Q.append([x1, x2])\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n>     if flag == 1:\n>         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```\n\n**Output:**\n```\nYES\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!",">",">","!","!","!","!","!","!",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!",">","!",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!",">",">","!","!","!","!","!","!",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!","!","!","!","!",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n1 1 0\n1 1 1 1",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To predict the code coverage for the provided Python program using the given test case inputs, let's methodically walk through each step of the execution:\n\n**Test Case Input:**\n```\n1 1 0\n1 1 1 1\n```\n\n**Python Program:**\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()\n```\n\n**Execution Plan:**\n\n1. **Import Statements:** The import statements are always executed.\n   ```python\n   > import sys\n   ```\n\n2. **Input Reading:** The input reading mechanism is set up. Since `sys.stdin` is used, we assume the input is provided correctly.\n   ```python\n   > input = sys.stdin.readline\n   ```\n\n3. **Reading R, C, N:** The main function reads the first line of input.\n   ```python\n   > R,C,N = map(int,input().split())\n   ```\n\n4. **Initialization of Lists and Sets:** Variables and lists are initialized.\n   ```python\n   > P = []\n   > X = {0,R}\n   > Y = {0,C}\n   > M = 0\n   ```\n\n5. **For Loop Execution:** Since `N` is 0, the for loop will not execute any of its content.\n   ```python\n   ! for i in range(N):\n   ```\n\n6. **Sorting P:** Since `P` is empty, sorting does not change anything.\n   ```python\n   > P = sorted(P, key = lambda a:a[0])\n   ```\n\n7. **Calculating Length of P:** The length of `P` is determined, which is 0.\n   ```python\n   > M = len(P)\n   ```\n\n8. **Flag Initialization:**\n   ```python\n   > flag = 0\n   ```\n\n9. **For Loop Execution:** Since `M` is 0, the for loop will not execute any of its content.\n   ```python\n   ! for i in range(M):\n   ```\n\n10. **Flag Check:** The value of `flag` is checked.\n    ```python\n    > if flag == 1:\n    !     print(\"NO\")\n    else:\n    >     print(\"YES\")\n    ```\n\n**Final Code Coverage:**\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R,C,N = map(int,input().split())\n>     P = []\n>     X = {0,R}\n>     Y = {0,C}\n>     M = 0\n!     for i in range(N):\n!         x1,y1,x2,y2 = map(int,input().split())\n!         if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n!             if y1==0:\n!                 L1 = x1\n!             elif x1==R:\n!                 L1 = R+y1\n!             elif y1==C:\n!                 L1 = 2*R + C - x1\n!             else:\n!                 L1 = 2*(R+C) - y1\n!             if y2==0:\n!                 L2 = x2\n!             elif x2==R:\n!                 L2 = R+y2\n!             elif y2==C:\n!                 L2 = 2*R + C - x2\n!             else:\n!                 L2 = 2*(R+C) - y2\n!             P.append([min(L1,L2), max(L1,L2)])\n>     P = sorted(P, key = lambda a:a[0])\n>     M = len(P)\n>     flag = 0\n!     Q = []\n!     for i in range(M):\n!         x1,x2 = P[i]\n!         if Q == []:\n!             Q.append([x1,x2])\n!         else:\n!             while Q[-1][1] < x1 and Q!=[]:\n!                 Q.pop()\n!             if Q==[]:\n!                 Q.append([x1,x2])\n!             else:\n!                 y1,y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1,x2])\n>     if flag == 1:\n!         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```\n\n**Output:**\n```\nYES\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n1 0 1\n1 1 1 1",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To determine the code coverage for the provided Python program based on the given test case input, let's go through a step-by-step execution plan and analyze which lines of the code are executed.\n\n### Test Case Input:\n```\n1 0 1\n1 1 1 1\n```\n\n### Python Program:\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R, C, N = map(int, input().split())\n    P = []\n    X = {0, R}\n    Y = {0, C}\n    M = 0\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n            if y1 == 0:\n                L1 = x1\n            elif x1 == R:\n                L1 = R + y1\n            elif y1 == C:\n                L1 = 2 * R + C - x1\n            else:\n                L1 = 2 * (R + C) - y1\n            if y2 == 0:\n                L2 = x2\n            elif x2 == R:\n                L2 = R + y2\n            elif y2 == C:\n                L2 = 2 * R + C - x2\n            else:\n                L2 = 2 * (R + C) - y2\n            P.append([min(L1, L2), max(L1, L2)])\n    P = sorted(P, key=lambda a: a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1, x2 = P[i]\n        if Q == []:\n            Q.append([x1, x2])\n        else:\n            while Q[-1][1] < x1 and Q != []:\n                Q.pop()\n            if Q == []:\n                Q.append([x1, x2])\n            else:\n                y1, y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1, x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nmain()\n```\n\n### Step-by-Step Execution Plan and Code Coverage:\n\n1. **Import Statements and Function Declaration:**\n    - `import sys` is executed.\n    - `def main():` function declaration is executed.\n    - `input = sys.stdin.readline` is executed.\n\n2. **Reading Input:**\n    - `R, C, N = map(int, input().split())` is executed; values are `R=1`, `C=0`, `N=1`.\n\n3. **Initialization:**\n    - `P = []` is executed.\n    - `X = {0, R}` is executed; `X = {0, 1}`.\n    - `Y = {0, C}` is executed; `Y = {0, 0}`.\n    - `M = 0` is executed.\n\n4. **For Loop (Processing Each Line Segment):**\n    - `for i in range(N):` is executed; `N=1`, so loop will run once.\n    - `x1, y1, x2, y2 = map(int, input().split())` is executed; values are `x1=1`, `y1=1`, `x2=1`, `y2=1`.\n\n5. **Checking Conditions:**\n    - `if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):` is executed; condition is `False` because `y1=1` and `y2=1` are not in `Y`.\n    - All nested conditions and statements inside this `if` block are not executed.\n\n6. **Sorting and Calculations:**\n    - `P = sorted(P, key=lambda a: a[0])` is executed; `P` remains `[]`.\n    - `M = len(P)` is executed; `M=0`.\n\n7. **Flag and Queue Initialization:**\n    - `flag = 0` is executed.\n    - `Q = []` is executed.\n\n8. **For Loop (Processing Sorted Segments):**\n    - `for i in range(M):` is executed; `M=0`, so loop does not run.\n\n9. **Final Condition and Output:**\n    - `if flag == 1:` is executed; condition is `False`.\n    - `print(\"YES\")` is executed.\n\n### Final Code Coverage:\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R, C, N = map(int, input().split())\n>     P = []\n>     X = {0, R}\n>     Y = {0, C}\n>     M = 0\n>     for i in range(N):\n>         x1, y1, x2, y2 = map(int, input().split())\n>         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n!             if y1 == 0:\n!                 L1 = x1\n!             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n!             if y2 == 0:\n!                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n!             P.append([min(L1, L2), max(L1, L2)])\n>     P = sorted(P, key=lambda a: a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n>     for i in range(M):\n!         x1, x2 = P[i]\n!         if Q == []:\n!             Q.append([x1, x2])\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n>     if flag == 1:\n!         print(\"NO\")\n>     else:\n>         print(\"YES\")\n\n> main()\n```\n\nOutput: `YES`",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n0 1 1\n0 0 0 0",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To develop a plan for step-by-step execution of the given Python program and predict the code coverage, we will follow a similar approach as the Java example provided. Here's the plan:\n\n### Plan for Step-by-Step Execution:\n\n1. **Import Statements**: The import statements are always executed.\n   - `import sys` is covered.\n\n2. **Function Declaration**: The function declaration is always executed.\n   - `def main():` is covered.\n\n3. **Input Reading**: The input reading statement is executed. Since the input test case is '0 1 1' and '0 0 0 0', the `input().split()` will be executed.\n   - `input = sys.stdin.readline` is covered.\n   - `R, C, N = map(int, input().split())` is covered. (This will set R=0, C=1, N=1)\n\n4. **Variable Initialization**: The variable initialization statements are always executed.\n   - `P = []` is covered.\n   - `X = {0, R}` is covered. (Here, X will be {0})\n   - `Y = {0, C}` is covered. (Here, Y will be {0, 1})\n   - `M = 0` is covered.\n\n5. **For Loop Execution for N**: The for loop is executed. Given N=1, the loop will run once.\n   - `for i in range(N):` is covered.\n\n6. **Nested Input Reading**: Inside the for loop, input is read again.\n   - `x1, y1, x2, y2 = map(int, input().split())` is covered. (This will set x1=0, y1=0, x2=0, y2=0 for the second line of input `0 0 0 0`).\n\n7. **If Condition for Checking Boundaries**: The if condition checks if the coordinates are in the sets X and Y.\n   - `if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):` is covered.\n   - Here, both x1 and y1 are in X and Y respectively, so the condition is true.\n\n8. **Nested If Conditions for Calculating L1 and L2**: The nested if-else conditions are used to calculate L1 and L2.\n   - `if y1 == 0:` is covered. (Condition is true, hence L1 is set to x1 which is 0)\n   - `if y2 == 0:` is covered. (Condition is true, hence L2 is set to x2 which is 0)\n\n9. **Appending to List P**: The calculated L1 and L2 values are appended to list P.\n   - `P.append([min(L1, L2), max(L1, L2)])` is covered. (P becomes [[0, 0]])\n\n10. **Sorting List P**: The list P is sorted.\n    - `P = sorted(P, key=lambda a: a[0])` is covered. (P remains [[0, 0]])\n\n11. **Setting M to the Length of P**: The length of P is calculated and assigned to M.\n    - `M = len(P)` is covered. (M becomes 1)\n\n12. **Initializing Flag and Q**: Variables flag and Q are initialized.\n    - `flag = 0` is covered.\n    - `Q = []` is covered.\n\n13. **For Loop Execution for M**: The for loop is executed. Given M=1, the loop will run once.\n    - `for i in range(M):` is covered.\n\n14. **If Condition for Checking Q**: The if condition checks if Q is empty.\n    - `if Q == []:` is covered. (Condition is true, hence Q is appended with [x1, x2])\n\n15. **Appending to Q**: The values are appended to Q.\n    - `Q.append([x1, x2])` is covered. (Q becomes [[0, 0]])\n\n16. **Final If Condition for Flag**: The final if condition checks the flag value.\n    - `if flag == 1:` is covered. (Condition is false, so \"YES\" is printed)\n\n17. **Print Statements**: The appropriate print statements are executed.\n    - `print(\"YES\")` is covered.\n\n18. **Function Call**: The main function call is always executed.\n    - `main()` is covered.\n\nGiven the above plan and steps, here is the predicted code coverage:\n\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R, C, N = map(int, input().split())\n>     P = []\n>     X = {0, R}\n>     Y = {0, C}\n>     M = 0\n>     for i in range(N):\n>         x1, y1, x2, y2 = map(int, input().split())\n>         if (x1 in X or y1 in Y) and (x2 in X or y2 in Y):\n>             if y1 == 0:\n>                 L1 = x1\n!             elif x1 == R:\n!                 L1 = R + y1\n!             elif y1 == C:\n!                 L1 = 2 * R + C - x1\n!             else:\n!                 L1 = 2 * (R + C) - y1\n>             if y2 == 0:\n>                 L2 = x2\n!             elif x2 == R:\n!                 L2 = R + y2\n!             elif y2 == C:\n!                 L2 = 2 * R + C - x2\n!             else:\n!                 L2 = 2 * (R + C) - y2\n>             P.append([min(L1, L2), max(L1, L2)])\n>     P = sorted(P, key=lambda a: a[0])\n>     M = len(P)\n>     flag = 0\n>     Q = []\n>     for i in range(M):\n>         x1, x2 = P[i]\n>         if Q == []:\n>             Q.append([x1, x2])\n!         else:\n!             while Q[-1][1] < x1 and Q != []:\n!                 Q.pop()\n!             if Q == []:\n!                 Q.append([x1, x2])\n!             else:\n!                 y1, y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1, x2])\n>     if flag == 1:\n>         print(\"NO\")\n>     else:\n>         print(\"YES\")\n> main()\n```\n\n### Output:\nGiven that the input test case sets C to 0, this will raise a `ValueError` because the number of columns should be greater than 0 to be valid. The Python implementation above doesn't inherently check for this condition, but logically we know that it should.\n\n**Runtime Exception Raised:** `ValueError: invalid literal for int() with base 10: ''`, assuming the input is not read correctly due to the format or logic handling of the input values.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n-1 1 1\n1 1 1 1",
            "initial_code": "def main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())\n    P = []\n    X = {0,R}\n    Y = {0,C}\n    M = 0\n    for i in range(N):\n        x1,y1,x2,y2 = map(int,input().split())\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n            if y1==0:\n                L1 = x1\n            elif x1==R:\n                L1 = R+y1\n            elif y1==C:\n                L1 = 2*R + C - x1\n            else:\n                L1 = 2*(R+C) - y1\n            if y2==0:\n                L2 = x2\n            elif x2==R:\n                L2 = R+y2\n            elif y2==C:\n                L2 = 2*R + C - x2\n            else:\n                L2 = 2*(R+C) - y2\n            P.append([min(L1,L2), max(L1,L2)])\n    P = sorted(P, key = lambda a:a[0])\n    M = len(P)\n    flag = 0\n    Q = []\n    for i in range(M):\n        x1,x2 = P[i]\n        if Q == []:\n            Q.append([x1,x2])\n        else:\n            while Q[-1][1] < x1 and Q!=[]:\n                Q.pop()\n            if Q==[]:\n                Q.append([x1,x2])\n            else:\n                y1,y2 = Q[-1]\n                if y2 < x2:\n                    flag = 1\n                    break\n                else:\n                    Q.append([x1,x2])\n    if flag == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")\nmain()",
            "covered_code": "To determine the code coverage of the provided Python program based on the given test case, we'll follow a step-by-step execution plan. Let's break down the code and analyze which lines will be executed given the input:\n\nTest Case Input:\n```\n-1 1 1\n1 1 1 1\n```\n\n### Python Program:\n```python\ndef main():\n    import sys\n    input = sys.stdin.readline\n    R,C,N = map(int,input().split())                   # Line 3\n    P = []                                             # Line 4\n    X = {0,R}                                          # Line 5\n    Y = {0,C}                                          # Line 6\n    M = 0                                              # Line 7\n    for i in range(N):                                 # Line 8\n        x1,y1,x2,y2 = map(int,input().split())         # Line 9\n        if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):  # Line 10\n            if y1==0:                                  # Line 11\n                L1 = x1                                # Line 12\n            elif x1==R:                                # Line 13\n                L1 = R+y1                              # Line 14\n            elif y1==C:                                # Line 15\n                L1 = 2*R + C - x1                      # Line 16\n            else:                                      # Line 17\n                L1 = 2*(R+C) - y1                      # Line 18\n            if y2==0:                                  # Line 19\n                L2 = x2                                # Line 20\n            elif x2==R:                                # Line 21\n                L2 = R+y2                              # Line 22\n            elif y2==C:                                # Line 23\n                L2 = 2*R + C - x2                      # Line 24\n            else:                                      # Line 25\n                L2 = 2*(R+C) - y2                      # Line 26\n            P.append([min(L1,L2), max(L1,L2)])         # Line 27\n    P = sorted(P, key = lambda a:a[0])                 # Line 28\n    M = len(P)                                         # Line 29\n    flag = 0                                           # Line 30\n    Q = []                                             # Line 31\n    for i in range(M):                                 # Line 32\n        x1,x2 = P[i]                                   # Line 33\n        if Q == []:                                    # Line 34\n            Q.append([x1,x2])                          # Line 35\n        else:                                          # Line 36\n            while Q[-1][1] < x1 and Q!=[]:             # Line 37\n                Q.pop()                                # Line 38\n            if Q==[]:                                  # Line 39\n                Q.append([x1,x2])                      # Line 40\n            else:                                      # Line 41\n                y1,y2 = Q[-1]                          # Line 42\n                if y2 < x2:                            # Line 43\n                    flag = 1                           # Line 44\n                    break                              # Line 45\n                else:                                  # Line 46\n                    Q.append([x1,x2])                  # Line 47\n    if flag == 1:                                      # Line 48\n        print(\"NO\")                                    # Line 49\n    else:                                              # Line 50\n        print(\"YES\")                                   # Line 51\nmain()                                                 # Line 52\n```\n\n### Step-by-Step Execution Plan and Code Coverage:\n\n1. **Import Statements**:\n   - Import statements are always executed.\n   - `import sys` is executed.\n   - `input = sys.stdin.readline` is executed.\n\n2. **Reading Input**:\n   - `R,C,N = map(int,input().split())` (Line 3): This line tries to read the input and split it into three integers.\n     - Given input: `-1 1 1`\n     - Here, `R = -1`, `C = 1`, and `N = 1`.\n\n3. **Handling Invalid Input**:\n   - Since the program expects `R` to be greater than 0, this line will raise a `ValueError` because `R` is `-1`.\n   - As a result, none of the subsequent lines will be executed, and the program will terminate with an exception.\n\n### Final Code Coverage:\n```python\n> def main():\n>     import sys\n>     input = sys.stdin.readline\n>     R,C,N = map(int,input().split())\n!     P = []\n!     X = {0,R}\n!     Y = {0,C}\n!     M = 0\n!     for i in range(N):\n!         x1,y1,x2,y2 = map(int,input().split())\n!         if (x1 in X or y1 in Y) and  (x2 in X or y2 in Y):\n!             if y1==0:\n!                 L1 = x1\n!             elif x1==R:\n!                 L1 = R+y1\n!             elif y1==C:\n!                 L1 = 2*R + C - x1\n!             else:\n!                 L1 = 2*(R+C) - y1\n!             if y2==0:\n!                 L2 = x2\n!             elif x2==R:\n!                 L2 = R+y2\n!             elif y2==C:\n!                 L2 = 2*R + C - x2\n!             else:\n!                 L2 = 2*(R+C) - y2\n!             P.append([min(L1,L2), max(L1,L2)])\n!     P = sorted(P, key = lambda a:a[0])\n!     M = len(P)\n!     flag = 0\n!     Q = []\n!     for i in range(M):\n!         x1,x2 = P[i]\n!         if Q == []:\n!             Q.append([x1,x2])\n!         else:\n!             while Q[-1][1] < x1 and Q!=[]:\n!                 Q.pop()\n!             if Q==[]:\n!                 Q.append([x1,x2])\n!             else:\n!                 y1,y2 = Q[-1]\n!                 if y2 < x2:\n!                     flag = 1\n!                     break\n!                 else:\n!                     Q.append([x1,x2])\n!     if flag == 1:\n!         print(\"NO\")\n!     else:\n!         print(\"YES\")\n> main()\n```\n\n### Output:\n```\nError: ValueError - invalid literal for int() with base 10: '-1'\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "YES\n",
            "error": ""
        }
    ]
}