{
    "submission_id": "s567578812",
    "cycles": [
        {
            "test_case": "Test Case Input:\n3 2\n1 2\n2 3",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To predict the code coverage for the given Python program based on the test case input, we need to follow a similar step-by-step execution plan. Here\u2019s how it would look:\n\n### Test Case Input:\n```\n3 2\n1 2\n2 3\n```\n\n### Python Program:\n```python\nimport queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()\n```\n\n### Step-by-Step Execution Plan:\n1. **Import Statement:**\n    - `import queue` is always executed.\n2. **Function Definitions and Main Check:**\n    - `def main():` and `if __name__==\"__main__\":` are always executed.\n3. **Input Handling:**\n    - Read `n, m` values using `n, m = map(int, input().split())` with input `3 2`.\n    - Covered.\n4. **2D List Initialization:**\n    - `root=[[0 for i in range(n)] for i in range(n)]` initializes a 3x3 matrix with zeros.\n    - Covered.\n5. **Reading Edges and Filling Matrix:**\n    - The for loop `for i in range(m):` iterates twice because `m=2`.\n    - Covered.\n    - `a, b = map(int, input().split())` reads edges `1 2` and `2 3`.\n    - `root[a-1][b-1] = 1` and `root[b-1][a-1] = 1` fill the matrix.\n    - Covered.\n6. **List Initialization for Minimum Values:**\n    - `min = [-1 for i in range(n)]` initializes with `[-1, -1, -1]`.\n    - `min[0] = 2` sets the first element to 2.\n    - Both are covered.\n7. **Dictionary Initialization:**\n    - `dict = {}` initializes an empty dictionary.\n    - The for loop `for i in range(n):` iterates three times to initialize dictionary values.\n    - Both are covered.\n8. **Queue Initialization and Initial Setup:**\n    - `start = 0` and `toVis = queue.Queue()` initialize the starting point and queue.\n    - `check[start] = True` sets the first element of `check` to `True`.\n    - Covered.\n9. **Initial Queue Population:**\n    - The for loop `for i in range(len(root[0])):` iterates three times.\n    - Inside the loop, `if root[0][i] == 1:` checks connections from the start node.\n    - `toVis.put(i)`, `dict[i] = start`, and `check[i] = True` handle the connections.\n    - Covered.\n10. **Breadth-First Search (BFS):**\n    - `while(toVis.empty() != True):` runs while the queue is not empty.\n    - `now = toVis.get()` fetches the next node.\n    - Inside the nested for loop and if condition, the queue is updated, and the dictionary is filled.\n    - Covered.\n11. **Final Check for Connectivity:**\n    - The for loop `for i in range(1, n):` iterates twice for `i=1` and `i=2`.\n    - Inside the loop, `if dict[i] == -1:` checks for disconnected nodes.\n    - Since all nodes are connected, `print(\"No\")` and `return 0` are not executed.\n    - `print(\"Yes\")` and the second for loop `for i in range(1, n):` are executed.\n    - Covered.\n\n### Final Code Coverage:\n```python\n> import queue\n> def main():\n>     n,m=map(int,input().split())\n>     root=[[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a,b=map(int,input().split())\n>         root[a-1][b-1]=1\n>         root[b-1][a-1]=1\n>     min=[-1 for i in range(n)]\n>     min[0]=2\n>     dict={}\n>     for i in range(n):\n>         dict[i]=-1\n>     start=0\n>     check=[False]*n\n>     toVis=queue.Queue()\n>     check[start]=True\n>     for i in range(len(root[0])):\n>         if root[0][i]==1:\n>             toVis.put(i)\n>             dict[i]=start\n>             check[i]=True\n>     while(toVis.empty()!=True):\n>         now=toVis.get()\n>         check[now]=True\n>         for i in range(n):\n>             if root[now][i]==1 and check[i]==False:\n>                 toVis.put(i)\n>                 dict[i]=now\n>                 check[i]=True\n>     for i in range(1,n):\n!         if dict[i]==-1:\n!             print(\"No\")\n!             return 0\n>     print(\"Yes\")\n>     for i in range(1,n):\n>         print(dict[i]+1)         \n> if __name__==\"__main__\":\n>     main()\n```\n\n### Output:\n```\nYes\n1\n2\n```\n\nAll statements are covered except the condition for disconnected nodes and the corresponding print and return statements.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">"
            ],
            "output": "Yes\n1\n2\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To predict the code coverage for the provided Python program based on the given test case, let's follow a step-by-step plan similar to the example provided:\n\n### Test Case Input:\n```\n0 3\n1 2\n2 3\n3 4\n```\nThis input is not in the expected format, as it should have newline characters separating each input pair.\n\n### Python Program:\n```python\nimport queue\n\ndef main():\n    n, m = map(int, input().split())\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a-1][b-1] = 1\n        root[b-1][a-1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False] * n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while(toVis.empty() != True):\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Execution Plan and Code Coverage:\n\n1. **Import Statements**: Always executed.\n    ```\n    > import queue\n    ```\n\n2. **Function Definition**: Always executed.\n    ```\n    > def main():\n    ```\n\n3. **Main Method Execution**:\n    - The input `0 3` should be parsed here, but as it is not in the expected format, it will raise a `ValueError`.\n    ```\n    >     n, m = map(int, input().split())  # This line will be executed and raise an exception\n    ```\n\n4. **Exception Handling**:\n    - Since `input().split()` does not raise an explicit exception, the `ValueError` will occur due to the next expected input format not being met.\n    ```\n    ValueError: not enough values to unpack (expected 2, got 1)\n    ```\n\n5. **Rest of the Code**:\n    - None of the subsequent lines will be executed because the exception occurs before any of them are reached.\n\n### Final Code Coverage:\n\n```plaintext\n> import queue\n> def main():\n>     n, m = map(int, input().split())  # This line will raise an exception\n!     root = [[0 for i in range(n)] for i in range(n)]\n!     for i in range(m):\n!         a, b = map(int, input().split())\n!         root[a-1][b-1] = 1\n!         root[b-1][a-1] = 1\n!     min = [-1 for i in range(n)]\n!     min[0] = 2\n!     dict = {}\n!     for i in range(n):\n!         dict[i] = -1\n!     start = 0\n!     check = [False] * n\n!     toVis = queue.Queue()\n!     check[start] = True\n!     for i in range(len(root[0])):\n!         if root[0][i] == 1:\n!             toVis.put(i)\n!             dict[i] = start\n!             check[i] = True\n!     while(toVis.empty() != True):\n!         now = toVis.get()\n!         check[now] = True\n!         for i in range(n):\n!             if root[now][i] == 1 and check[i] == False:\n!                 toVis.put(i)\n!                 dict[i] = now\n!                 check[i] = True\n!     for i in range(1, n):\n!         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n!     print(\"Yes\")\n!     for i in range(1, n):\n!         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```\n\n### Output:\n```\nError: ValueError: not enough values to unpack (expected 2, got 1)\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">","!",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">","!",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 7, in main\n    root[a-1][b-1]=1\n    ~~~~^^^^^\nIndexError: list index out of range\n"
        },
        {
            "test_case": "Test Case Input:\n1 2\n2 3",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To predict the code coverage of the given Python program based on the provided test case input, we'll go through the code step by step. Here's the breakdown:\n\n### Test Case Input:\n```\n1 2\n2 3\n```\n\n### Python Program:\n```python\nimport queue\n\ndef main():\n    n, m = map(int, input().split())  # Test input: n=1, m=2\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a-1][b-1] = 1\n        root[b-1][a-1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False]*n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while(toVis.empty() != True):\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Step-by-step Execution Plan:\n\n1. **Import Statement**:\n   - `import queue`: Always executed.\n\n2. **Function Definition**:\n   - `def main():` : Always executed.\n\n3. **Reading Input**:\n   - `n, m = map(int, input().split())`: Always executed.\n\n4. **Initialization of `root` Matrix**:\n   - `root = [[0 for i in range(n)] for i in range(n)]`: Always executed.\n\n5. **Populating `root` Matrix**:\n   - `for i in range(m):`: Executed `m` times (2 times in this case).\n   - `a, b = map(int, input().split())`: Executed `m` times, always executed.\n   - `root[a-1][b-1] = 1`: Executed `m` times, always executed.\n   - `root[b-1][a-1] = 1`: Executed `m` times, always executed.\n\n6. **Initialization of `min` List**:\n   - `min = [-1 for i in range(n)]`: Always executed.\n   - `min[0] = 2`: Always executed.\n\n7. **Initialization of `dict` Dictionary**:\n   - `dict = {}`: Always executed.\n   - `for i in range(n):`: Executed `n` times (1 time in this case).\n   - `dict[i] = -1`: Executed `n` times, always executed.\n\n8. **Initialization of Variables**:\n   - `start = 0`: Always executed.\n   - `check = [False]*n`: Always executed.\n   - `toVis = queue.Queue()`: Always executed.\n   - `check[start] = True`: Always executed.\n\n9. **Populating `toVis` Queue**:\n   - `for i in range(len(root[0])):`: Executed `n` times (1 time in this case).\n   - `if root[0][i] == 1:`: Executed `n` times, not satisfied (since `root[0]` is `[0]`).\n   - `toVis.put(i)`, `dict[i] = start`, `check[i] = True`: Not executed.\n\n10. **Breadth-First Search (BFS) Traversal**:\n    - `while(toVis.empty() != True):`: Not executed (`toVis` is empty).\n\n11. **Checking for Unreachable Nodes**:\n    - `for i in range(1, n):`: Not executed (since `n` is 1, range(1, n) is empty).\n\n12. **Final Output**:\n    - `print(\"Yes\")`: Always executed.\n    - `for i in range(1, n):`: Not executed (since `n` is 1).\n\n13. **Main Function Invocation**:\n    - `if __name__ == \"__main__\":`: Always executed.\n    - `main()`: Always executed.\n\n### Final Code Coverage:\n```python\n> import queue\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n>         root[a-1][b-1] = 1\n>         root[b-1][a-1] = 1\n>     min = [-1 for i in range(n)]\n>     min[0] = 2\n>     dict = {}\n>     for i in range(n):\n>         dict[i] = -1\n>     start = 0\n>     check = [False] * n\n>     toVis = queue.Queue()\n>     check[start] = True\n>     for i in range(len(root[0])):\n!         if root[0][i] == 1:\n!             toVis.put(i)\n!             dict[i] = start\n!             check[i] = True\n!     while(toVis.empty() != True):\n!         now = toVis.get()\n!         check[now] = True\n!         for i in range(n):\n!             if root[now][i] == 1 and check[i] == False:\n!                 toVis.put(i)\n!                 dict[i] = now\n!                 check[i] = True\n!     for i in range(1, n):\n!         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n>     print(\"Yes\")\n!     for i in range(1, n):\n!         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```\n\n### Output:\n```\nYes\n```\n\nIn this case, the final code coverage shows that most of the code related to the BFS traversal and checking for unreachable nodes is not executed, since the input involves a single node (`n=1`).",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!",">",">",">",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 7, in main\n    root[a-1][b-1]=1\n    ~~~~^^^^^\nIndexError: list index out of range\n"
        },
        {
            "test_case": "Test Case Input:\n2 1\n1 2",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To predict the code coverage of the given Python program based on the provided test inputs, we need to follow a step-by-step execution plan and indicate whether each line is executed or not.\n\n**Test Case Input:**\n```\n2 1\n1 2\n```\n\n**Python Program:**\n```python\nimport queue\ndef main():\n    n, m = map(int, input().split())\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a-1][b-1] = 1\n        root[b-1][a-1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False] * n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while(toVis.empty() != True):\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)         \nif __name__ == \"__main__\":\n    main()\n```\n\n**Step-by-Step Execution Plan:**\n\n1. **Import Statement:**\n   - `import queue` is always executed.\n\n2. **Main Function Declaration:**\n   - `def main():` is always executed.\n\n3. **Input Parsing:**\n   - `n, m = map(int, input().split())` is executed, where `n=2` and `m=1`.\n\n4. **Root Matrix Initialization:**\n   - `root = [[0 for i in range(n)] for i in range(n)]` initializes a 2x2 matrix filled with zeros. This line is executed.\n\n5. **Filling the Root Matrix:**\n   - The loop `for i in range(m):` runs once because `m=1`.\n   - `a, b = map(int, input().split())` is executed, where `a=1` and `b=2`.\n   - `root[a-1][b-1] = 1` and `root[b-1][a-1] = 1` are executed, updating the root matrix to `[[0, 1], [1, 0]]`.\n\n6. **Min Array Initialization:**\n   - `min = [-1 for i in range(n)]` initializes `min` array to `[-1, -1]`. This line is executed.\n   - `min[0] = 2` sets the first element to `2`. This line is executed.\n\n7. **Dict Initialization:**\n   - `dict = {}` initializes an empty dictionary. This line is executed.\n   - The loop `for i in range(n):` runs twice because `n=2`.\n   - `dict[i] = -1` is executed twice, setting `dict` to `{0: -1, 1: -1}`.\n\n8. **BFS Initialization:**\n   - `start = 0` sets the start variable to `0`. This line is executed.\n   - `check = [False] * n` initializes `check` array to `[False, False]`. This line is executed.\n   - `toVis = queue.Queue()` initializes an empty queue. This line is executed.\n   - `check[start] = True` sets `check[0]` to `True`. This line is executed.\n\n9. **Initial Neighbors Check:**\n   - The loop `for i in range(len(root[0])):` runs twice because `len(root[0])=2`.\n   - `if root[0][i] == 1:` is executed twice; the condition is `False` for `i=0` and `True` for `i=1`.\n   - `toVis.put(i)`, `dict[i] = start`, and `check[i] = True` are executed for `i=1`, updating `toVis` to queue containing `1`, `dict` to `{0: -1, 1: 0}`, and `check` to `[True, True]`.\n\n10. **BFS Traversal:**\n    - `while(toVis.empty() != True):` loop runs once because the queue is not empty.\n    - `now = toVis.get()` retrieves `1` from the queue. This line is executed.\n    - `check[now] = True` sets `check[1]` to `True` again (it was already `True`). This line is executed.\n    - The loop `for i in range(n):` runs twice because `n=2`.\n    - `if root[now][i] == 1 and check[i] == False:` condition is `False` both times (`check[0]` and `check[1]` are both `True`).\n\n11. **Reachability Check:**\n    - The loop `for i in range(1, n):` runs once because `n=2`.\n    - `if dict[i] == -1:` condition is `False` because `dict[1]` is `0`. The corresponding `print(\"No\")` and `return 0` are not executed.\n\n12. **Successful Path Found:**\n    - `print(\"Yes\")` is executed, printing \"Yes\".\n    - The loop `for i in range(1, n):` runs once because `n=2`.\n    - `print(dict[i] + 1)` is executed, printing `1`.\n\n13. **Main Function Call:**\n    - `if __name__ == \"__main__\":` and `main()` are always executed.\n\n**Final Code Coverage:**\n```python\n> import queue\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n>         root[a-1][b-1] = 1\n>         root[b-1][a-1] = 1\n>     min = [-1 for i in range(n)]\n>     min[0] = 2\n>     dict = {}\n>     for i in range(n):\n>         dict[i] = -1\n>     start = 0\n>     check = [False] * n\n>     toVis = queue.Queue()\n>     check[start] = True\n>     for i in range(len(root[0])):\n>         if root[0][i] == 1:\n>             toVis.put(i)\n>             dict[i] = start\n>             check[i] = True\n>     while(toVis.empty() != True):\n>         now = toVis.get()\n>         check[now] = True\n>         for i in range(n):\n>             if root[now][i] == 1 and check[i] == False:\n>                 toVis.put(i)\n>                 dict[i] = now\n>                 check[i] = True\n>     for i in range(1, n):\n>         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n>     print(\"Yes\")\n>     for i in range(1, n):\n>         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "output": "Yes\n1\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n1 2",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "### Plan for Step-by-Step Execution:\n\n1. **Import Statements:**\n   - Import statements are always executed.\n   - `import queue` will be covered.\n\n2. **Function and Main Execution:**\n   - Function `main()` is defined and executed only when called.\n   - The block `if __name__ == \"__main__\":` is executed.\n\n3. **User Input and Initial Setup:**\n   - The input `1 2` is split into `n = 1` and `m = 2`.\n   - `root = [[0 for i in range(n)] for i in range(n)]` initializes `root` as a 1x1 matrix with `[[0]]`.\n\n4. **For Loop for Graph Edges:**\n   - The loop `for i in range(m):` will execute twice (since `m = 2`).\n\n5. **First Iteration of the Loop:**\n   - For the first iteration, `a, b = map(int, input().split())` reads the next input pair. This will raise a `ValueError` because there is no more input available after `1 2`.\n\n### Code Coverage:\n\nGiven the test case input `1 2`, the execution will fail during the second `map(int, input().split())` call because there will be no additional input available, resulting in a `ValueError`. The code will not proceed beyond this point.\n\n```python\n> import queue\n> def main():\n>     n,m=map(int,input().split())\n>     root=[[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n!         a,b=map(int,input().split())\n!         root[a-1][b-1]=1\n!         root[b-1][a-1]=1\n!     min=[-1 for i in range(n)]\n!     min[0]=2\n!     dict={}\n!     for i in range(n):\n!         dict[i]=-1\n!     start=0\n!     check=[False]*n\n!     toVis=queue.Queue()\n!     check[start]=True\n!     for i in range(len(root[0])):\n!         if root[0][i]==1:\n!             toVis.put(i)\n!             dict[i]=start\n!             check[i]=True\n!     while(toVis.empty()!=True):\n!         now=toVis.get()\n!         check[now]=True\n!         for i in range(n):\n!             if root[now][i]==1 and check[i]==False:\n!                 toVis.put(i)\n!                 dict[i]=now\n!                 check[i]=True\n!     for i in range(1,n):\n!         if dict[i]==-1:\n!             print(\"No\")\n!             return 0\n!     print(\"Yes\")\n!     for i in range(1,n):\n!         print(dict[i]+1)\n> if __name__==\"__main__\":\n>     main()\n```\n\n### Output:\n\n```plaintext\nValueError: not enough values to unpack (expected 2, got 0)\n```\n\nThis plan demonstrates that the code coverage stops early due to a `ValueError` caused by insufficient input. The remaining statements after the error point are not executed.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 6, in main\n    a,b=map(int,input().split())\n                ^^^^^^^\nEOFError: EOF when reading a line\n"
        },
        {
            "test_case": "Test Case Input:\n2 2\n1 2\n2 1",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "### Step-by-Step Execution Plan and Code Coverage\n\n#### Test Case Input:\n```\n2 2\n1 2\n2 1\n```\n\n#### Python Program:\n```python\nimport queue\n\ndef main():\n    n, m = map(int, input().split())\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a-1][b-1] = 1\n        root[b-1][a-1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False] * n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while toVis.empty() != True:\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Execution Plan:\n\n1. **Import Statements**:\n   - `import queue` is always executed.\n\n2. **Function Declaration and Main Function Execution**:\n   - Declaration of `main()` function is covered.\n   - `if __name__ == \"__main__\": main()` is covered.\n\n3. **Input Parsing**:\n   - `n, m = map(int, input().split())` parses `2 2`, setting `n=2` and `m=2`.\n\n4. **Matrix Initialization**:\n   - `root = [[0 for i in range(n)] for i in range(n)]` initializes a 2x2 matrix with zeros.\n   - This loop runs twice to initialize the matrix.\n\n5. **Filling the Matrix**:\n   - `for i in range(m):` runs twice because `m=2`.\n   - First iteration: `a, b = map(int, input().split())` parses `1 2`. This sets `root[0][1] = 1` and `root[1][0] = 1`.\n   - Second iteration: `a, b = map(int, input().split())` parses `2 1`. This sets `root[1][0] = 1` and `root[0][1] = 1` (already set in the first iteration).\n\n6. **Initialization of Lists and Dictionary**:\n   - `min = [-1 for i in range(n)]` runs twice, setting `min = [-1, -1]`.\n   - `min[0] = 2` sets the first element of `min` to 2.\n   - `dict = {}` initializes an empty dictionary.\n   - `for i in range(n): dict[i] = -1` runs twice, setting `dict = {0: -1, 1: -1}`.\n\n7. **BFS Initialization**:\n   - `start = 0` sets start node to 0.\n   - `check = [False] * n` initializes `check = [False, False]`.\n   - `toVis = queue.Queue()` initializes a queue.\n   - `check[start] = True` sets `check[0] = True`.\n\n8. **Root Node Processing**:\n   - `for i in range(len(root[0])):` runs twice because `len(root[0]) = 2`.\n   - First iteration: `if root[0][i] == 1:` is true for `i = 1`, so `toVis.put(1)`, `dict[1] = 0`, and `check[1] = True`.\n\n9. **BFS Loop**:\n   - `while toVis.empty() != True:` runs once because the queue is not empty.\n   - `now = toVis.get()` sets `now = 1`.\n   - `check[now] = True` sets `check[1] = True`.\n   - `for i in range(n):` runs twice.\n     - First iteration: `if root[now][i] == 1 and check[i] == False:` is false for `i = 0`.\n     - Second iteration: `if root[now][i] == 1 and check[i] == False:` is false for `i = 1`.\n\n10. **Check for Unvisited Nodes**:\n    - `for i in range(1, n):` runs once.\n    - `if dict[i] == -1:` is false for `i = 1`, so `print(\"No\")` and `return 0` are not executed.\n\n11. **Output Results**:\n    - `print(\"Yes\")` prints \"Yes\".\n    - `for i in range(1, n):` runs once.\n      - `print(dict[i] + 1)` prints `dict[1] + 1`, which is `1`.\n\n### Final Code Coverage:\n```python\n> import queue\n\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n>         root[a-1][b-1] = 1\n>         root[b-1][a-1] = 1\n>     min = [-1 for i in range(n)]\n>     min[0] = 2\n>     dict = {}\n>     for i in range(n):\n>         dict[i] = -1\n>     start = 0\n>     check = [False] * n\n>     toVis = queue.Queue()\n>     check[start] = True\n>     for i in range(len(root[0])):\n>         if root[0][i] == 1:\n>             toVis.put(i)\n>             dict[i] = start\n>             check[i] = True\n>     while toVis.empty() != True:\n>         now = toVis.get()\n>         check[now] = True\n>         for i in range(n):\n>             if root[now][i] == 1 and check[i] == False:\n>                 toVis.put(i)\n>                 dict[i] = now\n>                 check[i] = True\n>     for i in range(1, n):\n>         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n>     print(\"Yes\")\n>     for i in range(1, n):\n>         print(dict[i] + 1)\n\n> if __name__ == \"__main__\":\n>     main()\n```\n\n### Output:\n```\nYes\n1\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!",">",">",">",">",">"
            ],
            "output": "Yes\n1\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n3 3\n1 2\n2 3\n3 4",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To develop a step-by-step execution plan for the given Python program and predict the code coverage based on the provided test case, we will follow a similar approach as the illustration provided for the Java program. \n\n### Test Case Input:\n```\n3 3\n1 2\n2 3\n3 4\n```\n\n### Python Program:\n```python\nimport queue\n\ndef main():\n    n, m = map(int, input().split())\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a-1][b-1] = 1\n        root[b-1][a-1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False] * n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while toVis.empty() != True:\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Execution Plan and Code Coverage:\n\n1. **Import statement:**\n   ```python\n   import queue\n   ```\n   Import statements are always executed.\n   ```\n   > import queue\n   ```\n\n2. **Main function declaration:**\n   ```python\n   def main():\n   ```\n   Function declaration is always executed.\n   ```\n   > def main():\n   ```\n\n3. **Input reading and variable initialization:**\n   ```python\n   n, m = map(int, input().split())\n   ```\n   The input `\"3 3\"` will be read, and `n` will be set to 3, `m` will be set to 3.\n   ```\n   > n, m = map(int, input().split())\n   ```\n\n4. **2D list initialization:**\n   ```python\n   root = [[0 for i in range(n)] for i in range(n)]\n   ```\n   The 2D list `root` will be initialized.\n   ```\n   > root = [[0 for i in range(n)] for i in range(n)]\n   ```\n\n5. **For loop for reading edges:**\n   ```python\n   for i in range(m):\n       a, b = map(int, input().split())\n       root[a-1][b-1] = 1\n       root[b-1][a-1] = 1\n   ```\n   The loop will iterate 3 times (since `m = 3`), and will read `\"1 2\"`, `\"2 3\"`, `\"3 4\"`. The `root` matrix will be updated accordingly.\n   ```\n   > for i in range(m):\n   >     a, b = map(int, input().split())\n   >     root[a-1][b-1] = 1\n   >     root[b-1][a-1] = 1\n   ```\n\n6. **List and dictionary initializations:**\n   ```python\n   min = [-1 for i in range(n)]\n   min[0] = 2\n   dict = {}\n   for i in range(n):\n       dict[i] = -1\n   ```\n   The `min` list and `dict` dictionary will be initialized.\n   ```\n   > min = [-1 for i in range(n)]\n   > min[0] = 2\n   > dict = {}\n   > for i in range(n):\n   >     dict[i] = -1\n   ```\n\n7. **Queue and check list initialization:**\n   ```python\n   start = 0\n   check = [False] * n\n   toVis = queue.Queue()\n   check[start] = True\n   ```\n   The `start`, `check`, and `toVis` variables will be initialized.\n   ```\n   > start = 0\n   > check = [False] * n\n   > toVis = queue.Queue()\n   > check[start] = True\n   ```\n\n8. **For loop for initializing the queue:**\n   ```python\n   for i in range(len(root[0])):\n       if root[0][i] == 1:\n           toVis.put(i)\n           dict[i] = start\n           check[i] = True\n   ```\n   The loop will iterate 3 times (since `n = 3`), and `toVis` and `dict` will be updated accordingly.\n   ```\n   > for i in range(len(root[0])):\n   >     if root[0][i] == 1:\n   >         toVis.put(i)\n   >         dict[i] = start\n   >         check[i] = True\n   ```\n\n9. **While loop for BFS traversal:**\n   ```python\n   while toVis.empty() != True:\n       now = toVis.get()\n       check[now] = True\n       for i in range(n):\n           if root[now][i] == 1 and check[i] == False:\n               toVis.put(i)\n               dict[i] = now\n               check[i] = True\n   ```\n   The loop will iterate until `toVis` is empty, performing BFS traversal.\n   ```\n   > while toVis.empty() != True:\n   >     now = toVis.get()\n   >     check[now] = True\n   >     for i in range(n):\n   >         if root[now][i] == 1 and check[i] == False:\n   >             toVis.put(i)\n   >             dict[i] = now\n   >             check[i] = True\n   ```\n\n10. **For loop for checking connectivity:**\n    ```python\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    ```\n    The loop will iterate twice (since `n = 3`), checking if all nodes are connected. All nodes are connected, so \"No\" will not be printed.\n    ```\n    > for i in range(1, n):\n    >     if dict[i] == -1:\n    !         print(\"No\")\n    !         return 0\n    ```\n\n11. **Printing \"Yes\" and elements of dict:**\n    ```python\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n    ```\n    \"Yes\" will be printed, followed by the values in `dict`.\n    ```\n    > print(\"Yes\")\n    > for i in range(1, n):\n    >     print(dict[i] + 1)\n    ```\n\n12. **Function and script end:**\n    ```python\n    if __name__ == \"__main__\":\n        main()\n    ```\n    The main function call is always executed.\n    ```\n    > if __name__ == \"__main__\":\n    >     main()\n    ```\n\n### Final Code Coverage:\n```python\n> import queue\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n>         root[a-1][b-1] = 1\n>         root[b-1][a-1] = 1\n>     min = [-1 for i in range(n)]\n>     min[0] = 2\n>     dict = {}\n>     for i in range(n):\n>         dict[i] = -1\n>     start = 0\n>     check = [False] * n\n>     toVis = queue.Queue()\n>     check[start] = True\n>     for i in range(len(root[0])):\n>         if root[0][i] == 1:\n>             toVis.put(i)\n>             dict[i] = start\n>             check[i] = True\n>     while toVis.empty() != True:\n>         now = toVis.get()\n>         check[now] = True\n>         for i in range(n):\n>             if root[now][i] == 1 and check[i] == False:\n>                 toVis.put(i)\n>                 dict[i] = now\n>                 check[i] = True\n>     for i in range(1, n):\n>         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n>     print(\"Yes\")\n>     for i in range(1, n):\n>         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```\n\n### Runtime Exception:\n```\nIndexError: list index out of range\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 7, in main\n    root[a-1][b-1]=1\n    ~~~~~~~~~^^^^^\nIndexError: list assignment index out of range\n"
        },
        {
            "test_case": "Test Case Input:\n0 2",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "To predict the code coverage for the given Python program based on the provided test case input and following a step-by-step execution plan, we'll analyze how each line of code is executed or not. Here is the step-by-step execution plan:\n\n### Execution Plan\n\n1. **Imports**: Import statements are always executed.\n   - `import queue` is executed.\n   \n2. **Main Function Declaration**: The function declaration is always executed.\n   - `def main():` is executed.\n\n3. **Reading Input Values**: The code will attempt to read and unpack the input values `n` and `m` using `map(int, input().split())`.\n   - Since the input provided is `0 2`, the first line will successfully split into `n=0` and `m=2`.\n\n4. **2D List Initialization**: The 2D list `root` is initialized based on `n`.\n   - `root = [[0 for i in range(n)] for i in range(n)]` will be executed but results in an empty list due to `n=0`.\n\n5. **Filling the Adjacency Matrix**: The for loop iterates `m` times to fill the adjacency matrix.\n   - Since `m=2`, the loop will attempt to execute twice. However, it will fail on the first iteration because there is no input provided for the next `a, b` values.\n\n6. **List Initialization for `min`**: A list `min` is initialized.\n   - `min = [-1 for i in range(n)]` will be executed but results in an empty list due to `n=0`.\n\n7. **Setting Initial Value for `min[0]`**: The code attempts to set `min[0] = 2`.\n   - This will raise an `IndexError` since `min` is an empty list.\n\nGiven that an `IndexError` is raised during the execution, the subsequent lines will not be executed.\n\n### Code Coverage\n\nBased on the above plan, here is the coverage for each line of code:\n\n```python\n> import queue\n> def main():\n>     n,m=map(int,input().split())\n>     root=[[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n!         a,b=map(int,input().split())\n!         root[a-1][b-1]=1\n!         root[b-1][a-1]=1\n>     min=[-1 for i in range(n)]\n!     min[0]=2\n>     dict={}\n>     for i in range(n):\n!         dict[i]=-1\n>     start=0\n>     check=[False]*n\n>     toVis=queue.Queue()\n!     check[start]=True\n>     for i in range(len(root[0])):\n!         if root[0][i]==1:\n!             toVis.put(i)\n!             dict[i]=start\n!             check[i]=True\n!     while(toVis.empty()!=True):\n!         now=toVis.get()\n!         check[now]=True\n!         for i in range(n):\n!             if root[now][i]==1 and check[i]==False:\n!                 toVis.put(i)\n!                 dict[i]=now\n!                 check[i]=True\n!     for i in range(1,n):\n!         if dict[i]==-1:\n!             print(\"No\")\n!             return 0\n!     print(\"Yes\")\n!     for i in range(1,n):\n!         print(dict[i]+1)\n> if __name__==\"__main__\":\n>     main()\n```\n\n### Exception Raised\n\nOutput:\n```\nError: IndexError = list assignment index out of range\n```\n\nThe execution raises an `IndexError` due to attempting to access `min[0]` on an empty list, which halts further execution of the code.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 6, in main\n    a,b=map(int,input().split())\n                ^^^^^^^\nEOFError: EOF when reading a line\n"
        },
        {
            "test_case": "Test Case Input:\n0 3\n1 2\n2 0",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "Let's develop a step-by-step execution plan for the given Python program and predict the code coverage based on the provided test case input.\n\n### Test Case Input:\n```\n0 3\n1 2\n2 0\n```\n\n### PYTHON PROGRAM:\n```python\nimport queue\n\ndef main():\n    n, m = map(int, input().split())\n    root = [[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        root[a - 1][b - 1] = 1\n        root[b - 1][a - 1] = 1\n    min = [-1 for i in range(n)]\n    min[0] = 2\n    dict = {}\n    for i in range(n):\n        dict[i] = -1\n    start = 0\n    check = [False] * n\n    toVis = queue.Queue()\n    check[start] = True\n    for i in range(len(root[0])):\n        if root[0][i] == 1:\n            toVis.put(i)\n            dict[i] = start\n            check[i] = True\n    while toVis.empty() != True:\n        now = toVis.get()\n        check[now] = True\n        for i in range(n):\n            if root[now][i] == 1 and check[i] == False:\n                toVis.put(i)\n                dict[i] = now\n                check[i] = True\n    for i in range(1, n):\n        if dict[i] == -1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1, n):\n        print(dict[i] + 1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Step-by-Step Execution Plan and Code Coverage:\n\n1. **Import Statement**:\n   - `import queue`: Always executed.\n   ```plaintext\n   > import queue\n   ```\n\n2. **Function Definition**:\n   - `def main():`: Always executed.\n   ```plaintext\n   > def main():\n   ```\n\n3. **Input Reading and Initialization**:\n   - `n, m = map(int, input().split())`: Executed (with n=0 and m=3).\n   - `root = [[0 for i in range(n)] for i in range(n)]`: Executed (results in an empty list since n=0).\n   ```plaintext\n   > n, m = map(int, input().split())\n   > root = [[0 for i in range(n)] for i in range(n)]\n   ```\n\n4. **For Loop for Reading Edges**:\n   - `for i in range(m):`: Executed (m=3, so loop runs 3 times).\n   - Reading and processing edges:\n     - `a, b = map(int, input().split())`: Executed (3 times).\n     - `root[a - 1][b - 1] = 1` and `root[b - 1][a - 1] = 1`: Not executed due to `IndexError` (since `root` is an empty list).\n   ```plaintext\n   > for i in range(m):\n   >     a, b = map(int, input().split())\n   !     root[a - 1][b - 1] = 1\n   !     root[b - 1][a - 1] = 1\n   ```\n\n5. **Initialization of Lists**:\n   - `min = [-1 for i in range(n)]`: Executed (results in an empty list since n=0).\n   - `min[0] = 2`: Raises `IndexError` because `min` is an empty list.\n   ```plaintext\n   > min = [-1 for i in range(n)]\n   ! min[0] = 2\n   ```\n\n### Runtime Exception:\nThe execution will raise an `IndexError` at the line `min[0] = 2` because `min` is an empty list due to `n=0`.\n\n### Final Code Coverage:\n```plaintext\n> import queue\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n!         root[a - 1][b - 1] = 1\n!         root[b - 1][a - 1] = 1\n>     min = [-1 for i in range(n)]\n!     min[0] = 2\n!     dict = {}\n!     for i in range(n):\n!         dict[i] = -1\n!     start = 0\n!     check = [False] * n\n!     toVis = queue.Queue()\n!     check[start] = True\n!     for i in range(len(root[0])):\n!         if root[0][i] == 1:\n!             toVis.put(i)\n!             dict[i] = start\n!             check[i] = True\n!     while toVis.empty() != True:\n!         now = toVis.get()\n!         check[now] = True\n!         for i in range(n):\n!             if root[now][i] == 1 and check[i] == False:\n!                 toVis.put(i)\n!                 dict[i] = now\n!                 check[i] = True\n!     for i in range(1, n):\n!         if dict[i] == -1:\n!             print(\"No\")\n!             return 0\n!     print(\"Yes\")\n!     for i in range(1, n):\n!         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```\n\n### Exception:\n```plaintext\nError: IndexError: list assignment index out of range\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">","!","!","!","!","!","!","!","!",">",">"
            ],
            "output": "",
            "error": "Traceback (most recent call last):\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 39, in <module>\n    main()\n  File \"C:\\Users\\hridy\\Documents\\PhD_Research\\FSE'25\\fuzzwise_rebranded\\model\\temp_code.py\", line 7, in main\n    root[a-1][b-1]=1\n    ~~~~^^^^^\nIndexError: list index out of range\n"
        },
        {
            "test_case": "Test Case Input:\n2 0",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "### Plan for Step-by-Step Execution\n\n1. **Import Statements**: Import statements are always executed. Statement `import queue` will be covered.\n2. **Main function declaration**: Always executed. Statement `def main():` is covered.\n3. **User Input**: Always executed. Statement `n,m=map(int,input().split())` is covered.\n4. **Root List Initialization**: This part initializes a 2D list based on the value of `n`. Statement `root=[[0 for i in range(n)] for i in range(n)]` is covered.\n5. **For Loop Execution (Line 7)**: Since `m=0`, the for loop `for i in range(m):` does not execute. Thus, lines within this loop are not covered.\n6. **Min List Initialization**: Always executed. Statement `min=[-1 for i in range(n)]` is covered.\n7. **Min List Assignment**: Always executed. Statement `min[0]=2` is covered.\n8. **Dictionary Initialization**: Always executed. Statement `dict={}` is covered.\n9. **Dictionary Population Loop**: Always executed. Statement `for i in range(n):` and `dict[i]=-1` are covered.\n10. **Start Variable Initialization**: Always executed. Statement `start=0` is covered.\n11. **Check List Initialization**: Always executed. Statement `check=[False]*n` is covered.\n12. **Queue Initialization**: Always executed. Statement `toVis=queue.Queue()` is covered.\n13. **Setting Check for Start**: Always executed. Statement `check[start]=True` is covered.\n14. **For Loop to Add Neighbors of Start to Queue**: Always executed. Statement `for i in range(len(root[0])):` is covered. However, since `root` was not populated due to `m=0`, the inner statements won't have an effect.\n15. **While Loop Execution (Line 23)**: Since `toVis` queue is empty, the while loop `while(toVis.empty()!=True):` does not execute. Thus, lines within this loop are not covered.\n16. **For Loop to Check Dictionary Values (Line 30)**: Always executed. Statement `for i in range(1,n):` is covered.\n17. **If Condition to Check Dictionary Values**: Always executed. Statement `if dict[i]==-1:` is covered. Given the dictionary was populated but not modified further, the condition is true, and `print(\"No\")` statement is executed. The function returns `0` and terminates.\n18. **Closing Statements**: The function ends, so remaining print statements are not executed.\n19. **Main Function Call**: Always executed. The statement `if __name__==\"__main__\":` and `main()` are covered.\n\n### Final Code Coverage\n\n```python\n> import queue\n> def main():\n>     n,m=map(int,input().split())\n>     root=[[0 for i in range(n)] for i in range(n)]\n!     for i in range(m):\n!         a,b=map(int,input().split())\n!         root[a-1][b-1]=1\n!         root[b-1][a-1]=1\n>     min=[-1 for i in range(n)]\n>     min[0]=2\n>     dict={}\n>     for i in range(n):\n>         dict[i]=-1\n>     start=0\n>     check=[False]*n\n>     toVis=queue.Queue()\n>     check[start]=True\n>     for i in range(len(root[0])):\n!         if root[0][i]==1:\n!             toVis.put(i)\n!             dict[i]=start\n!             check[i]=True\n!     while(toVis.empty()!=True):\n!         now=toVis.get()\n!         check[now]=True\n!         for i in range(n):\n!             if root[now][i]==1 and check[i]==False:\n!                 toVis.put(i)\n!                 dict[i]=now\n!                 check[i]=True\n>     for i in range(1,n):\n>         if dict[i]==-1:\n>             print(\"No\")\n>             return 0\n!     print(\"Yes\")\n!     for i in range(1,n):\n!         print(dict[i]+1)\n> if __name__==\"__main__\":\n>     main()\n```\n\n### Output\n\n**Error**: ArithmeticError (due to improper initialization and access of `root` list).\n\nBy following the step-by-step plan, we ensured that all statements were analyzed for execution coverage based on the given input and program logic.",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "No\n",
            "error": ""
        },
        {
            "test_case": "Test Case Input:\n3 3\n1 2\n2 3\n3 1",
            "initial_code": "import queue\ndef main():\n    n,m=map(int,input().split())\n    root=[[0 for i in range(n)] for i in range(n)]\n    for i in range(m):\n        a,b=map(int,input().split())\n        root[a-1][b-1]=1\n        root[b-1][a-1]=1\n    min=[-1 for i in range(n)]\n    min[0]=2\n    dict={}\n    for i in range(n):\n        dict[i]=-1\n    start=0\n    check=[False]*n\n    toVis=queue.Queue()\n    check[start]=True\n    for i in range(len(root[0])):\n        if root[0][i]==1:\n            toVis.put(i)\n            dict[i]=start\n            check[i]=True\n    while(toVis.empty()!=True):\n        now=toVis.get()\n        check[now]=True\n        for i in range(n):\n            if root[now][i]==1 and check[i]==False:\n                toVis.put(i)\n                dict[i]=now\n                check[i]=True\n    for i in range(1,n):\n        if dict[i]==-1:\n            print(\"No\")\n            return 0\n    print(\"Yes\")\n    for i in range(1,n):\n        print(dict[i]+1)         \nif __name__==\"__main__\":\n    main()",
            "covered_code": "Let's analyze the given Python program and predict the code coverage based on the provided test case.\n\nThe provided test case input:\n```\n3 3\n1 2\n2 3\n3 1\n```\n\n### Step-by-Step Execution Plan:\n\n1. **Import Statement:**\n    - `import queue` is always executed.\n   \n2. **Main Function Declaration:**\n   - `def main():` is always executed.\n\n3. **Input Reading and Initial Setup:**\n   - `n, m = map(int, input().split())` reads `n = 3` and `m = 3`.\n   - `root` matrix is initialized with zeros.\n   - Loop to read `m` edges and update the `root` matrix:\n     - First iteration: `a, b = map(int, input().split())` reads `a = 1` and `b = 2`. Updates `root[0][1]` and `root[1][0]` to 1.\n     - Second iteration: `a, b = map(int, input().split())` reads `a = 2` and `b = 3`. Updates `root[1][2]` and `root[2][1]` to 1.\n     - Third iteration: `a, b = map(int, input().split())` reads `a = 3` and `b = 1`. Updates `root[2][0]` and `root[0][2]` to 1.\n\n4. **Initialize Minimum Distance List:**\n   - `min = [-1 for i in range(n)]` initializes `min` list with `[-1, -1, -1]`.\n   - `min[0] = 2` sets the first element to 2, resulting in `min = [2, -1, -1]`.\n\n5. **Initialize Dictionary and Other Variables:**\n   - `dict = {}` initializes an empty dictionary.\n   - Loop to initialize `dict`:\n     - First iteration: `dict[0] = -1`.\n     - Second iteration: `dict[1] = -1`.\n     - Third iteration: `dict[2] = -1`.\n   - `start = 0`.\n   - `check = [False] * n` initializes `check` list with `[False, False, False]`.\n   - `toVis = queue.Queue()` initializes an empty queue.\n   - `check[start] = True` sets `check[0]` to `True`, resulting in `check = [True, False, False]`.\n\n6. **Queue Initialization:**\n   - Loop to enqueue adjacent nodes of the start node:\n     - First iteration: `root[0][0]` is 0, nothing happens.\n     - Second iteration: `root[0][1]` is 1, enqueues `1` and updates `dict[1] = 0` and `check[1] = True`.\n     - Third iteration: `root[0][2]` is 1, enqueues `2` and updates `dict[2] = 0` and `check[2] = True`.\n\n7. **BFS Loop:**\n   - While loop runs while `toVis` is not empty:\n     - First iteration: `now = toVis.get()` gets `1`.\n       - Loop to check adjacent nodes of `now`:\n         - First sub-iteration: `root[1][0]` is 1 but `check[0]` is `True`, nothing happens.\n         - Second sub-iteration: `root[1][1]` is 0, nothing happens.\n         - Third sub-iteration: `root[1][2]` is 1 but `check[2]` is `True`, nothing happens.\n     - Second iteration: `now = toVis.get()` gets `2`.\n       - Loop to check adjacent nodes of `now`:\n         - First sub-iteration: `root[2][0]` is 1 but `check[0]` is `True`, nothing happens.\n         - Second sub-iteration: `root[2][1]` is 1 but `check[1]` is `True`, nothing happens.\n         - Third sub-iteration: `root[2][2]` is 0, nothing happens.\n\n8. **Check for Connectivity:**\n   - Loop to check if all nodes are visited:\n     - First iteration: `dict[1] != -1` is `True`, nothing happens.\n     - Second iteration: `dict[2] != -1` is `True`, nothing happens.\n   - Prints \"Yes\".\n\n9. **Print the Path:**\n   - Loop to print the path:\n     - First iteration: `print(dict[1] + 1)` prints `1`.\n     - Second iteration: `print(dict[2] + 1)` prints `1`.\n\n10. **Main Function Execution:**\n    - `if __name__ == \"__main__\": main()` always executed.\n\n### Final Code Coverage:\n```\n> import queue\n> def main():\n>     n, m = map(int, input().split())\n>     root = [[0 for i in range(n)] for i in range(n)]\n>     for i in range(m):\n>         a, b = map(int, input().split())\n>         root[a-1][b-1] = 1\n>         root[b-1][a-1] = 1\n>     min = [-1 for i in range(n)]\n>     min[0] = 2\n>     dict = {}\n>     for i in range(n):\n>         dict[i] = -1\n>     start = 0\n>     check = [False] * n\n>     toVis = queue.Queue()\n>     check[start] = True\n>     for i in range(len(root[0])):\n>         if root[0][i] == 1:\n>             toVis.put(i)\n>             dict[i] = start\n>             check[i] = True\n>     while(toVis.empty() != True):\n>         now = toVis.get()\n>         check[now] = True\n>         for i in range(n):\n>             if root[now][i] == 1 and check[i] == False:\n>                 toVis.put(i)\n>                 dict[i] = now\n>                 check[i] = True\n>     for i in range(1, n):\n>         if dict[i] == -1:\n>             print(\"No\")\n>             return 0\n>     print(\"Yes\")\n>     for i in range(1, n):\n>         print(dict[i] + 1)\n> if __name__ == \"__main__\":\n>     main()\n```",
            "test_seed_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "cumulative_coverage": [
                ">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">",">"
            ],
            "output": "Yes\n1\n1\n",
            "error": ""
        }
    ]
}