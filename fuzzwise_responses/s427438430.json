{
  "submission_id": "s427438430",
  "cycles": [
    {
      "test_case": "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4\n3\n2 3\n1 4",
        "Test Case Input:\n3\n2\n1 2\n2 3",
        "Test Case Input:\n4\n3\n1 2\n2 3\n3 4",
        "Test Case Input:\n5\n4\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n5\n4\n1 2\n1 3\n2 4\n3 5",
        "Test Case Input:\n5\n4\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n3\n2\n1 2\n2 3",
        "Test Case Input:\n3\n2\n1 2\n2 3",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and tets case-\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. User Input and Program Output : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\", \"int N = nextInt();\", \"int M = nextInt();\" are covered. \n5. Initializing parent array : always executed. Statement \"parent = new int [N+1];\" is covered.\n6. Initializing matrix array : always executed. Statements \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" and \"for (int x=1; x<=N; x++) {\" are covered.\n7. Filling the matrix array : always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n8. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n9. bfs method Execution : always executed. Statements inside the bfs method are covered.\n10. Checking parent array : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0){\" are covered.\n11. Printing output based on flag : always executed. Statements \"System.out.println(\"Yes\");\", \"System.out.println(parent[x]);\", and \"System.out.println(\"No\");\" are covered.\n12. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4\n5 6",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 0",
        "Test Case Input:\na 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n3 4",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n4 3\n1 0\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "Plan for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n\n2. Main method declaration: Always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader and InputStreamReader: Always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n\n4. Input values for N and M: Always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n5. parent array initialization: Always executed. Statement \"parent = new int [N+1];\" is covered.\n\n6. ArrayList initialization: Always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n\n7. For loop to initialize ArrayList: Executed M-1 times. Statements within the for loop are covered.\n\n8. bfs method call: Executed once. Statement \"bfs(matrix, 1);\" is covered.\n\n9. bfs method declaration and execution: Always executed. Statement \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. The while loop within the bfs method is executed.\n\n10. bfs method while loop: Executed based on the size of the queue. Statements within the while loop are covered.\n\n11. nextInt method call: Executed N times. Statement \"int cur = queue.poll();\" is covered.\n\n12. For loop within bfs method: Executed based on the size of matrix[cur]. Statements within the for loop are covered.\n\n13. if condition within bfs method: Executed based on the value of parent[now]. Statements within the if condition are covered.\n\n14. nextInt method call: Executed N times. Statement \"parent[now] = cur;\" is covered.\n\n15. queue.add method call: Executed based on the value of parent[now]. Statement \"queue.add(now);\" is covered.\n\n16. return statement within bfs method: Always executed. Statement \"return false;\" is covered.\n\n17. flag check within main method: Executed once. Statement \"if(flag) {\" is covered.\n\n18. For loop within flag check: Executed N times. Statements within the for loop are covered.\n\n19. System.out.println within flag check: Executed once. Statement \"System.out.println(parent[x]);\" is covered.\n\n20. else condition within flag check: Executed once. Statement \"System.out.println(\"No\");\" is covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n2 1\n1 2",
        "Test Case Input:\n4 2\n1 1\n2 3\n3 4",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4\n5\n\nTest Case Input:\n4 0\n1 2\n2 3\n3 4\nTest Case Input:\n4 3\n1 2\n2 3\n3 4\nTest Case Input:\n4 0\n1 2\n2 3\n3 4\nTest Case Input:\n4 3\n1 2\n2 3\n3 4\n",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4\n5 6",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n4 2\n1 2\n2 3",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statements \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. BufferedReader and PrintWriter object creation : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\" are covered.\n4. User Input : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n5. Initializing parent array and matrix : always executed. Statements \"parent = new int [N+1];\" and \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" are covered.\n6. Loop for initializing matrix : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n7. ArrayList initialization : always executed. Statement \"matrix[x] = new ArrayList<Integer>();\" is covered.\n8. Loop for adding edges to matrix : always executed. Statement \"for (int x=1; x<M; x++) {\" is covered.\n9. User Input for edges : always executed. Statements \"int one = nextInt();\" and \"int two = nextInt();\" are covered.\n10. Adding edges to matrix : always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n11. Function call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n12. bfs method declaration and execution : always executed. Statements \"public static boolean bfs (ArrayList [] matrix,  int start) {\" and \"Queue <Integer> queue = new LinkedList<Integer>();\" are covered.\n13. Loop for processing matrix elements : always executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n14. Loop for processing neighbors of current element : always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n15. Checking and updating parent array : always executed. Statements \"if(parent[now]==0) {\" and \"parent[now] = cur;\" are covered.\n16. Adding neighbor to queue : always executed. Statement \"queue.add(now);\" is covered.\n17. return statement : always executed. Statement \"return false;\" is covered.\n18. Checking parent array to determine if all nodes are connected : always executed. Statements \"boolean flag = true;\" and \"for (int x=1; x<=N; x++) {\" are covered.\n19. Printing output based on flag value : always executed. Statements \"if(flag) {\" and \"System.out.println(\"Yes\");\" are covered.\n20. Loop for printing parent array : always executed. Statement \"for (int x=2; x<=N; x++) {\" is covered.\n21. Printing output if flag is false : always executed. Statement \"else {\" is covered.\n22. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5 5\n1 2\n1 3\n2 4\n3 4\n4 5",
      "test_mutations": [
        "Test Case Input:\n-5 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4\nTest Case Input:\n0 0\n1 2\n2 3\n3 4\nTest Case Input:\n4 0\n1 2\n2 3\n3 4\nTest Case Input:\n4 0\n1 2\n2 3\n3 4\nTest Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4\n",
        "Test Case Input:\n5 5\n1 2\n1 3\n2 4\n3 4\n4 5"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader and InputStreamReader Initialization : always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered. \n5. Integer Input : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered. \n6. parent array Initialization : always executed. Statement \"parent = new int [N+1];\" is covered.\n7. ArrayList Initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n8. ArrayList Initialization in Loop : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n9. For loop to add elements to the ArrayLists : always executed. Statements \"int one = nextInt();\" and \"int two = nextInt();\" are covered.\n10. Adding elements to the ArrayLists : always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n11. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n12. bfs method execution : always executed. Statement \"Queue <Integer> queue = new LinkedList<Integer>();\" is covered.\n13. while loop in bfs method : always executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n14. cur variable initialization : always executed. Statement \"int cur = queue.poll();\" is covered. \n15. for loop in bfs method : always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n16. now variable initialization : always executed. Statement \"int now = (int) matrix[cur].get(x);\" is covered.\n17. if condition in bfs method : always executed. Statement \"if(parent[now]==0){\" is covered.\n18. parent array update : always executed. Statement \"parent[now] = cur;\" is covered.\n19. Adding to queue in bfs method : always executed. Statement \"queue.add(now);\" is covered.\n20. return statement in bfs method : always executed. Statement \"return false;\" is covered.\n21. flag variable initialization : always executed. Statement \"boolean flag = true;\" is covered.\n22. for loop to check parent array : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n23. if condition in for loop : always executed. Statement \"if(parent[x] == 0){\" is covered.\n24. flag variable update : always executed. Statement \"flag = false;\" is covered.\n25. break statement in for loop : always executed. Statement \"break;\" is covered.\n26. if condition after for loop : always executed. Statement \"if(flag){\" is covered.\n27. Printing \"Yes\" : always executed. Statement \"System.out.println(\"Yes\");\" is covered.\n28. for loop to print parent array : always executed. Statement \"for (int x=2; x<=N; x++) {\" is covered.\n29. Printing parent[x] : always executed. Statement \"System.out.println(parent[x]);\" is covered.\n30. else condition after if statement : always executed. Statement \"else{\" is covered.\n31. Printing \"No\" : always executed. Statement \"System.out.println(\"No\");\" is covered.\n32. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n0 0",
      "test_mutations": [
        "Test Case Input:\n0 2\n1 2\n2 3",
        "Test Case Input:\n1 0",
        "Test Case Input:\n0 0\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n0 0",
        "Test Case Input:\n0 4\n1 2\n2 3\n3 4",
        "Test Case Input:\n5 4\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n0 0"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main method declaration and throws : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. BufferedReader and InputStreamReader : always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n4. Variable declarations and initialization : always executed. Statements \"int N = nextInt();\", \"int M = nextInt();\", and \"parent = new int [N+1];\" are covered.\n5. Arraylist matrix initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n6. For loop for matrix initialization : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n7. For loop for adding edges to matrix : always executed. Statements \"for (int x=1; x<M; x++) {\" and \"matrix[one].add(two);\" are covered.\n8. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n9. bfs method execution : always executed. Statements \"public static boolean bfs (ArrayList [] matrix,  int start) {\" and \"Queue <Integer> queue = new LinkedList<Integer>();\" are covered.\n10. While loop within bfs method : always executed. Statements \"while (!queue.isEmpty()) {\" and \"int cur = queue.poll();\" are covered.\n11. For loop within while loop : always executed. Statements \"for (int x=0; x<matrix[cur].size(); x++) {\" and \"int now = (int) matrix[cur].get(x);\" are covered.\n12. If condition within for loop : always executed. Statement \"if(parent[now]==0) {\" is covered.\n13. Statements within if condition : executed based on the value of parent[now]. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n14. return statement within bfs method : always executed. Statement \"return false;\" is covered.\n15. boolean flag declaration and initialization : always executed. Statement \"boolean flag = true;\" is covered.\n16. For loop for checking parent array : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0) {\" are covered.\n17. Statements within if condition : executed based on the value of flag. Statements \"flag = false;\" and \"break;\" are covered.\n18. if-else condition : executed based on the value of flag. Statements \"if(flag) {\" and \"System.out.println(\"Yes\");\" are covered.\n19. For loop for printing parent array : executed based on the value of flag. Statements \"for (int x=2; x<=N; x++) {\" and \"System.out.println(parent[x]);\" are covered.\n20. else condition : executed based on the value of flag. Statement \"System.out.println(\"No\");\" is covered.\n21. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n2 2\n1 2\n2 1",
      "test_mutations": [
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\na 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-2 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n1 0\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n2 2\n1 2\n2 1"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main method declaration and IOException handling: always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. BufferedReader and InputStreamReader initialization: always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n4. Variable initialization and declaration: always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n5. parent array initialization: always executed. Statement \"parent = new int [N+1];\" is covered.\n6. ArrayList initialization: always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n7. ArrayList population: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n8. For loop for adding edges to the matrix: always executed. Statements \"for (int x=1; x<M; x++) {\" and \"int one = nextInt(); int two = nextInt();\" are covered.\n9. Adding edges to the matrix: always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n10. bfs method call: always executed. Statement \"bfs(matrix, 1);\" is covered.\n11. bfs method execution: always executed. Statements \"public static boolean bfs (ArrayList [] matrix, int start) {\" and \"Queue <Integer> queue = new LinkedList<Integer>();\" are covered.\n12. bfs while loop: always executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n13. bfs for loop: always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n14. bfs if condition: always executed. Statements \"int now = (int) matrix[cur].get(x);\" and \"if(parent[now]==0) {\" are covered.\n15. bfs if block: always executed. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n16. bfs while loop completion and return statement: always executed. Statements \"}\" and \"return false;\" are covered.\n17. flag initialization and for loop: always executed. Statements \"boolean flag = true;\" and \"for (int x=1; x<=N; x++) {\" are covered.\n18. flag if condition: always executed. Statements \"if(parent[x] == 0) {\" and \"flag = false;\" are covered.\n19. flag if block: always executed. Statements \"break;\" and \"}\" are covered.\n20. flag if-else block: always executed. Statement \"if(flag) {\" and \"System.out.println(\"Yes\");\" are covered.\n21. for loop for printing parent array: always executed. Statement \"for (int x=2; x<=N; x++) {\" is covered.\n22. for loop print statement: always executed. Statement \"System.out.println(parent[x]);\" is covered.\n23. flag else block: always executed. Statement \"else {\" and \"System.out.println(\"No\");\" are covered.\n24. Closing brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n2 2\n1 2\n2 1",
        "Test Case Input:\n2.5 3.7\n1.2 3.4\n5.6 7.8\n9.0 10.1",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 null",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-1 5\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4\n",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n2 2\n1 2\n2 1",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader, Printwriter, StringTokenizer, and parent[] declarations: always executed. Statements \"static StringTokenizer st;\", \"static BufferedReader br;\", \"static PrintWriter out;\", \"static int parent[];\" are covered.\n\n4. BufferedReader initialization: always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n\n5. User input for N and M: always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n6. parent[] array initialization: always executed. Statement \"parent = new int [N+1];\" is covered.\n\n7. ArrayList matrix[] initialization: always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n\n8. For loop for matrix[] initialization: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n\n9. For loop for input and adding to matrix[]: always executed. Statements \"for (int x=1; x<M; x++) {\" and \"int one = nextInt();\", \"int two = nextInt();\", \"matrix[one].add(two);\", \"matrix[two].add(one);\" are covered.\n\n10. bfs() method call: always executed. Statement \"bfs(matrix, 1);\" is covered.\n\n11. bfs() method declaration and execution: executed only if the condition in the while loop is true. Statement \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. The while loop will run for each element in the queue until the queue is empty. The for loop inside the while loop will run for each element in matrix[cur]. Therefore, the while loop and the for loop will be covered.\n\n12. Condition check for parent[x] and flag assignment: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0){\", \"flag = false;\", \"break;\" are covered.\n\n13. Printing \"Yes\" if flag is true: always executed. Statement \"if(flag){\", \"System.out.println(\"Yes\");\" are covered.\n\n14. Printing the parent array: always executed. Statements \"for (int x=2; x<=N; x++) {\", \"System.out.println(parent[x]);\" are covered.\n\n15. Printing \"No\" if flag is false: always executed. Statement \"else{\", \"System.out.println(\"No\");\" is covered.\n\n16. nextInt(), nextLong(), nextDouble() and next() method declarations: always executed. Statements \"public static int nextInt() throws IOException {\", \"public static long nextLong() throws IOException {\", \"public static double nextDouble() throws IOException {\", \"static String next() throws IOException {\" are covered.\n\n17. next() method execution: executed only if the condition in the while loop is true. Statement \"while (st == null || !st.hasMoreTokens())\", \"st = new StringTokenizer(br.readLine().trim());\" is covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 2\n1 2\n3 4",
        "Test Case Input:\n4 2\n1 2\n2 3\n4 5\nExplanation: This test case has a different number of edges (M) than the number of given edges in the input.",
        "Test Case Input:\n5 0\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n2.5 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n2 1\n1 2",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\""
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader and InputStreamReader Initialization : always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n5. User Input and Program Output : always executed. Statements \"int N = nextInt();\", \"int M = nextInt();\" are covered.\n6. parent array initialization : always executed. Statement \"parent = new int [N+1];\" is covered.\n7. matrix array initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n8. For loop 1 : executed M-1 times. Statement \"for (int x=1; x<M; x++) {\" is covered.\n9. For loop 1 contents : executed M-1 times. Statements \"int one = nextInt();\", \"int two = nextInt();\", \"matrix[one].add(two);\", \"matrix[two].add(one);\" are covered.\n10. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n11. bfs method declaration and execution : always executed. Statements \"public static boolean bfs (ArrayList [] matrix,  int start) {\", \"Queue <Integer> queue = new LinkedList<Integer>();\", \"queue.add(start);\", \"while (!queue.isEmpty()) {\", \"int cur = queue.poll();\", \"for (int x=0; x<matrix[cur].size(); x++) {\", \"int now = (int) matrix[cur].get(x);\", \"if(parent[now]==0){\", \"parent[now] = cur;\", \"queue.add(now);\", \"}\" are covered.\n12. boolean flag assignment : always executed. Statement \"boolean flag = true;\" is covered.\n13. For loop 2 : executed N times. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n14. If condition : always executed. Statements \"if(parent[x] == 0){\", \"flag = false;\", \"break;\", \"}\" are covered.\n15. If condition true block : executed if the if condition is true. Statements \"System.out.println(\"Yes\");\", \"for (int x=2; x<=N; x++) {\", \"System.out.println(parent[x]);\" are covered.\n16. If condition false block : executed if the if condition is false. Statement \"System.out.println(\"No\");\" is covered.\n17. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n2 0\n1 2",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 0",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 2\n1 2\n2 3",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n4 2\n1 2\n3 4",
        "Test Case Input:\n1 0",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. BufferedReader, PrintWriter, and other variable declarations: always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\", \"int N = nextInt();\", \"int M = nextInt();\", \"parent = new int [N+1];\", and \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" are covered.\n4. For loop to initialize the matrix: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n5. For loop to add edges in the matrix: always executed. Statements \"for (int x=1; x<M; x++) {\" and \"matrix[one].add(two);\" are covered.\n6. bfs method call: always executed. Statement \"bfs(matrix, 1);\" is covered.\n7. bfs method execution: always executed. Statements \"Queue <Integer> queue = new LinkedList<Integer>();\" and \"while (!queue.isEmpty()) {\" are covered.\n8. For loop inside the bfs method: always executed. Statements \"for (int x=0; x<matrix[cur].size(); x++) {\" and \"int now = (int) matrix[cur].get(x);\" are covered.\n9. If condition inside the for loop: always executed. Statements \"if(parent[now]==0){\" and \"parent[now] = cur;\" are covered.\n10. Statements after bfs method call in main method: always executed. Statements \"boolean flag = true;\", \"for (int x=1; x<=N; x++) {\", \"if(parent[x] == 0){\", \"flag = false;\", \"break;\", \"}\", \"if(flag){\", \"System.out.println(\"Yes\");\", \"for (int x=2; x<=N; x++) {\", \"System.out.println(parent[x]);\", \"}\", \"else{\", \"System.out.println(\"No\");\", \"}\" are covered.\n11. nextInt, nextLong, nextDouble, and next methods execution: always executed. Statements \"public static int nextInt() throws IOException {\", \"return Integer.parseInt(next());\", \"public static long nextLong() throws IOException {\", \"return Long.parseLong(next());\", \"public static double nextDouble() throws IOException {\", \"return Double.parseDouble(next());\", \"static String next() throws IOException {\", \"while (st == null || !st.hasMoreTokens())\", \"st = new StringTokenizer(br.readLine().trim());\", \"return st.nextToken();\", \"}\" are covered.\n12. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n4 2\n1 2\n2 3\n3 4",
        "Test Case Input:\n2 2\n1 2\n2 0",
        "Test Case Input:\n```\n4 3\n1 2\n2 3\n3 4\n```\n\nTest Case Input:\n```\n4 0\n1 2\n2 3\n3 4\n```\n\nTest Case Input:\n```\n4 0\n1 2\n2 3\n3 4\n```\n\nTest Case Input:\n```\n5 5\n1 2\n1 3\n2 4\n3 4\n4 5\n```\n\nTest Case Input:\n```\n0 0\n```\n\nTest Case Input:\n```\n2 2\n1 2\n2 1\n```\n\nTest Case Input:\n```\n4 3\n1 2\n2 3\n3 4\n```\n\nTest Case Input:\n```\n4 3\n1 2\n2 3\n3 4\n```\n\nTest Case Input:\n```\n-3 0\n1 2\n2 3\n3 4\n```",
        "Test Case Input:\n\"4\" \"3\"\n\"1\" \"2\"\n\"2\" \"3\"\n\"3\" \"4\"",
        "Test Case Input:\n2 2\n1 2\n2 1",
        "Test Case Input:\n2 1\n1 2",
        "Test Case Input:\n-4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n5 0\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and tets case-\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader, InputStreamReader and PrintWriter declaration : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"out = new PrintWriter(System.out);\" are covered. \n5. User Input and Program Output : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered. \n6. parent array initialization : always executed. Statement \"parent = new int [N+1];\" is covered. \n7. ArrayList Initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered. \n8. Loop for ArrayList Initialization : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered. \n9. Adding elements to ArrayList : always executed. Statements \"matrix[x] = new ArrayList<Integer>();\" is covered. \n10. Loop for matrix elements : always executed. Statement \"for (int x=1; x<M; x++) {\" is covered. \n11. Taking input for matrix elements : always executed. Statements \"int one = nextInt();\" and \"int two = nextInt();\" are covered. \n12. Adding elements to ArrayList : always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered. \n13. Function call : always executed. Statement \"bfs(matrix, 1);\" is covered. \n14. bfs method Declaration and Execution : method declaration is always executed. \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. \n15. Queue initialization and adding element : always executed. Statements \"Queue <Integer> queue = new LinkedList<Integer>();\" and \"queue.add(start);\" are covered. \n16. Loop for bfs : always executed. Statement \"while (!queue.isEmpty()) {\" is covered. \n17. Taking element from queue : always executed. Statement \"int cur = queue.poll();\" is covered. \n18. Loop for matrix elements inside bfs method : always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered. \n19. Assigning parent value : always executed. Statement \"parent[now] = cur;\" is covered. \n20. Adding element to queue : always executed. Statement \"queue.add(now);\" is covered. \n21. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\na 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case-\n\n1. Import statements : Import statements are always executed. Statements \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader object creation : always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n5. Reading input values : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n6. parent array initialization : always executed. Statement \"parent = new int[N+1];\" is covered.\n7. matrix ArrayList initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n8. for loop for matrix ArrayList initialization : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n9. for loop for adding edges to the matrix ArrayList : always executed. Statements \"for (int x=1; x<M; x++) {\" and \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n10. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n11. bfs method declaration and execution : always executed. Statement \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. \n12. Queue object creation : always executed. Statement \"Queue <Integer> queue = new LinkedList<Integer>();\" is covered.\n13. while loop for bfs traversal : always executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n14. queue poll and matrix traversal : always executed. Statements \"int cur = queue.poll();\" and \"for (int x=0; x<matrix[cur].size(); x++) {\" are covered.\n15. if condition inside matrix traversal : always executed. Statement \"if(parent[now]==0) {\" is covered.\n16. parent array updation and queue addition : always executed. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n17. return statement : always executed. Statement \"return false;\" is covered.\n18. flag initialization : always executed. Statement \"boolean flag = true;\" is covered.\n19. for loop for parent array check : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0) {\" are covered.\n20. if - else condition : always executed. Statements \"if(flag) {\" and \"System.out.println(\"Yes\");\" and \"for (int x=2; x<=N; x++) {\" and \"System.out.println(parent[x]);\" are covered.\n21. else condition : always executed. Statement \"else {\" is covered.\n22. Closing Brackets : always covered.\n23. Methods for reading input values : always executed. Statements \"public static int nextInt() throws IOException {\" and \"public static long nextLong() throws IOException {\" and \"public static double nextDouble() throws IOException {\" and \"static String next() throws IOException {\" are covered.\n24. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "The step by step execution plan for the given code snippet is as follows:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n\n2. Main method declaration: Always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader, InputStreamReader, and PrintWriter initialization: Always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\"\nare covered.\n\n4. User input: The nextInt() method is called twice to get the values of N and M. These statements are always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n5. Parent array initialization: Always executed. Statement \"parent = new int [N+1];\" is covered.\n\n6. Matrix array initialization: Always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n\n7. Matrix array population: The for loop will execute M-1 times. The statements inside the loop will be executed accordingly. Statements \"int one = nextInt();\" and \"int two = nextInt();\" will be executed M-1 times. The statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" will also be executed M-1 times.\n\n8. bfs method call: The bfs method is called once. The statement \"bfs(matrix, 1);\" is covered.\n\n9. bfs method execution: The while loop will iterate until the queue is empty. The statements inside the loop will be executed accordingly. The statements \"int cur = queue.poll();\" and \"int now = (int) matrix[cur].get(x);\" will be executed based on the size of the matrix[cur] array.\n\n10. parent array update: The statement \"parent[now] = cur;\" will be executed based on the condition \"if(parent[now]==0);\".\n\n11. Queue update: The statement \"queue.add(now);\" will be executed based on the condition \"if(parent[now]==0);\".\n\n12. bfs method return: The statement \"return false;\" is not covered since it is not reachable in this code.\n\n13. parent array check: The for loop will iterate N times. The statement inside the loop will be executed accordingly. The statement \"if(parent[x] == 0)\" will be executed N times.\n\n14. Print statements: The if-else condition will execute either the \"Yes\" block or the \"No\" block. The statements \"System.out.println(\"Yes\");\" and \"System.out.println(\"No\");\" will be executed once.\n\n15. Print parent array: The for loop will iterate N-1 times. The statement \"System.out.println(parent[x]);\" will be executed N-1 times.\n\n16. Closing brackets: Always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n0 0",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-5 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n4 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and tets case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader and InputStreamReader initialization : always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n5. Reading values for N and M : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n6. parent array initialization : always executed. Statement \"parent = new int [N+1];\" is covered.\n7. matrix ArrayList initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n8. For loop for ArrayList initialization : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n9. For loop to read values for matrix : always executed. Statements \"for (int x=1; x<M; x++) {\" and \"int one = nextInt();\" are covered.\n10. ArrayList addition : always executed. Statements \"int two = nextInt();\", \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n11. bfs method call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n12. bfs method execution : always executed. Statement \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered.\n13. Queue initialization and start node addition : always executed. Statements \"Queue <Integer> queue = new LinkedList<Integer>();\" and \"queue.add(start);\" are covered.\n14. while loop : always executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n15. queue poll : always executed. Statement \"int cur = queue.poll();\" is covered.\n16. for loop : always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n17. now variable initialization : always executed. Statement \"int now = (int) matrix[cur].get(x);\" is covered.\n18. if condition : always executed. Statement \"if(parent[now]==0){\" is covered.\n19. parent assignment and queue addition : always executed. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n20. return statement : always executed. Statement \"return false;\" is covered.\n21. flag variable initialization : always executed. Statement \"boolean flag = true;\" is covered.\n22. for loop : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n23. if condition : always executed. Statement \"if(parent[x] == 0){\" is covered.\n24. flag variable assignment : always executed. Statement \"flag = false;\" is covered.\n25. break statement : always executed. Statement \"break;\" is covered.\n26. if condition : always executed. Statement \"if(flag){\" is covered.\n27. System.out.println statements : always executed. Statements \"System.out.println(\"Yes\");\" and \"System.out.println(\"No\");\" are covered.\n28. for loop : always executed. Statement \"for (int x=2; x<=N; x++) {\" is covered.\n29. System.out.println statement : always executed. Statement \"System.out.println(parent[x]);\" is covered.\n30. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n5 0\n1 2\n2 3\n3 4\n4 5",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 3\n1 2\n2 3\n3 1",
        "Test Case Input:\n0 3\n1 2\n2 3",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader and PrintWriter object creation : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"out = new PrintWriter(System.out);\" are covered.\n5. User Input and Program Output : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n6. Integer array initialization : always executed. Statement \"parent = new int [N+1];\" is covered.\n7. ArrayList array initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n8. For loop for ArrayList initialization : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n9. For loop for adding edges to the graph : always executed. Statements \"for (int x=1; x<M; x++) {\" and \"int one = nextInt();\" and \"int two = nextInt();\" are covered.\n10. Adding edges to the graph : always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n11. bfs function call : always executed. Statement \"bfs(matrix, 1);\" is covered.\n12. bfs function Execution : Since the queue is not empty, the while loop is executed. Statement \"while (!queue.isEmpty()) {\" is covered.\n13. Extracting element from queue : always executed. Statement \"int cur = queue.poll();\" is covered.\n14. For loop for checking neighbors : always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n15. Checking if parent of neighbor is zero : always executed. Statement \"if(parent[now]==0){\" is covered.\n16. Updating parent of neighbor and adding it to the queue : always executed. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n17. Returning false : always executed. Statement \"return false;\" is covered.\n18. Checking if all nodes have a parent : always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0){\" and \"flag = false;\" and \"break;\" are covered.\n19. Printing \"Yes\" and parent nodes : always executed. Statements \"System.out.println(\"Yes\");\" and \"for (int x=2; x<=N; x++) {\" and \"System.out.println(parent[x]);\" are covered.\n20. Printing \"No\" : always executed. Statement \"System.out.println(\"No\");\" is covered.\n21. nextInt, nextLong, nextDouble, and next methods : always executed. Statements \"public static int nextInt() throws IOException {\" and \"return Integer.parseInt(next());\", \"public static long nextLong() throws IOException {\" and \"return Long.parseLong(next());\", \"public static double nextDouble() throws IOException {\" and \"return Double.parseDouble(next());\", \"static String next() throws IOException {\" and \"while (st == null || !st.hasMoreTokens())\" and \"st = new StringTokenizer(br.readLine().trim());\" and \"return st.nextToken();\" are covered.\n22. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n7 6\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n2 2\n1 a\n2 3",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 2\n1 2\n2 3",
        "Test Case Input:\n7 6\n1 2\n1 3\n2 4\n3 4\n4 5\n4 6"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statements \"import java.util.*;\", \"import java.io.*;\" are covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n4. BufferedReader, PrintWriter and StringTokenizer Declarations : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\", \"static StringTokenizer st;\", \"static BufferedReader br;\", \"static PrintWriter out;\" are covered. \n5. Variable Declarations and User Input : always executed. Statements \"int N = nextInt();\", \"int M = nextInt();\", \"parent = new int [N+1];\" are covered.\n6. ArrayList Declaration and Initialization : always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n7. For loop 1 : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n8. ArrayList Additions : always executed. Statements \"matrix[x] = new ArrayList<Integer>();\", \"matrix[one].add(two);\", \"matrix[two].add(one);\" are covered.\n9. bfs method call in main method : always executed. Statement \"bfs(matrix, 1);\" is covered.\n10. bfs method Declaration and Execution : method declaration is always executed. \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. The while loop will be executed since the queue is not empty. Statement \"int cur = queue.poll();\" is covered. The for loop will be executed since matrix[cur] is not empty. Statement \"int now = (int) matrix[cur].get(x);\" is covered. The if condition is satisfied and statement \"parent[now] = cur;\" is covered. The next iteration of the while loop will be executed. Statement \"return false;\" is not covered. \n11. Statements after bfs method call in main method : always executed. Statements \"boolean flag = true;\", \"for (int x=1; x<=N; x++) {\" are covered. The if condition is satisfied and statements \"if(parent[x] == 0){\", \"flag = false;\", \"break;\" are covered. The else block is not executed so statement \"if(flag){\" is not covered. \n12. For loop 2 : always executed. Statement \"for (int x=2; x<=N; x++) {\" is covered.\n13. Output Statements : always executed. Statements \"System.out.println(\"Yes\");\", \"System.out.println(parent[x]);\", \"System.out.println(\"No\");\" are covered.\n14. Closing Brackets : always covered. \nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }\n",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3 2\n1 2\n2 3",
      "test_mutations": [
        "Test Case Input:\n2 2\n1 2\n2 1",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n3 2\n1 2\n2 3"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. Variable Declarations and User Input : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\", \"int N = nextInt();\", \"int M = nextInt();\", \"parent = new int [N+1];\", \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" are covered.\n4. ArrayList Initialization : always executed. Statement \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n5. For loop Execution : Since M=2, the for loop condition (x<M) is true, and the loop block will be executed. Statement \"for (int x=1; x<M; x++) {\" will be covered.\n6. For loop contents : always executed. Statements \"int one = nextInt();\", \"int two = nextInt();\", \"matrix[one].add(two);\", \"matrix[two].add(one);\" are covered.\n7. Function call within main method : The function bfs will be executed. \n8. bfs method Declaration and Execution : method declaration is always executed. \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. The while loop is executed. Statements \"int cur = queue.poll();\", \"for (int x=0; x<matrix[cur].size(); x++) {\" and \"int now = (int) matrix[cur].get(x);\" are covered. \n9. if-else condition : Since parent[2] = 0, the if condition 'parent[x] == 0' is satisfied. Statement \"if(parent[x] == 0){\" is covered. \n10. Printing output : always executed. Statements \"System.out.println(\"Yes\");\", \"System.out.println(parent[x]);\" and \"System.out.println(\"No\");\" are covered. \n11. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 2\n1 2\n2 3",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statements \"import java.util.*;\", \"import java.io.*;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n3. Initializing BufferedReader, PrintWriter and StringTokenizer : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\", \"out = new PrintWriter(new OutputStreamWriter(System.out));\", \"static StringTokenizer st;\" are covered.\n4. User Input and Program Output : always executed. Statements \"int N = nextInt();\", \"int M = nextInt();\", \"parent = new int [N+1];\" are covered.\n5. Initializing ArrayList and matrix : always executed. Statements \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\", \"for (int x=1; x<=N; x++) {\", \"matrix[x] = new ArrayList<Integer>();\", \"}\" are covered.\n6. For loop for input values : always executed. Statements \"for (int x=1; x<M; x++) {\", \"int one = nextInt();\", \"int two = nextInt();\", \"matrix[one].add(two);\", \"matrix[two].add(one);\", \"}\" are covered.\n7. bfs method call : always executed. Statements \"bfs(matrix, 1);\" is covered.\n8. bfs method execution : always executed. Statements \"public static boolean bfs (ArrayList [] matrix,  int start) {\", \"Queue <Integer> queue = new LinkedList<Integer>();\", \"queue.add(start);\", \"while (!queue.isEmpty()) {\", \"int cur = queue.poll();\", \"for (int x=0; x<matrix[cur].size(); x++) {\", \"int now = (int) matrix[cur].get(x);\", \"if(parent[now]==0){\", \"parent[now] = cur;\", \"queue.add(now);\", \"}\", \"}\", \"}\", \"return false;\", \"}\" are covered.\n9. Checking flag value : always executed. Statements \"boolean flag = true;\", \"for (int x=1; x<=N; x++) {\", \"if(parent[x] == 0){\", \"flag = false;\", \"break;\", \"}\", \"}\" are covered.\n10. Printing output based on flag value : always executed. Statements \"if(flag){\", \"System.out.println(\"Yes\");\", \"for (int x=2; x<=N; x++) {\", \"System.out.println(parent[x]);\", \"}\", \"}\", \"else{\", \"System.out.println(\"No\");\", \"}\" are covered.\n11. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n5 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n4 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the above code snippet and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered. \n\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader and PrintWriter objects creation : always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\"\nare covered.\n\n4. Input values N and M : always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n5. Parent array creation : always executed. Statement \"parent = new int [N+1];\" is covered.\n\n6. ArrayList creation : always executed. Statements \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" and \"for (int x=1; x<=N; x++) {matrix[x] = new ArrayList<Integer>();}\" are covered.\n\n7. For loop : executed for the given input values. Statement \"for (int x=1; x<M; x++) {\" is covered.\n\n8. Input values for one and two : executed for the given input values. Statements \"int one = nextInt();\" and \"int two = nextInt();\" are covered.\n\n9. ArrayList addition : executed for the given input values. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n\n10. bfs method call : executed for the given input values. Statement \"bfs(matrix, 1);\" is covered.\n\n11. bfs method declaration and execution : always executed. Statement \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered.\n\n12. Queue object creation : always executed. Statement \"Queue <Integer> queue = new LinkedList<Integer>();\" is covered.\n\n13. While loop : executed based on the condition. Statement \"while (!queue.isEmpty()) {\" is covered.\n\n14. queue.poll() : executed based on the condition. Statement \"int cur = queue.poll();\" is covered.\n\n15. For loop : executed for the given input values. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n\n16. now value : executed for the given input values. Statement \"int now = (int) matrix[cur].get(x);\" is covered.\n\n17. if condition : executed based on the condition. Statement \"if(parent[now]==0) {\" is covered.\n\n18. parent[now] and queue.add(now) : executed based on the condition. Statements \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n\n19. return statement : always executed. Statement \"return false;\" is covered.\n\n20. boolean flag : always executed. Statement \"boolean flag = true;\" is covered.\n\n21. For loop : always executed. Statement \"for (int x=1; x<=N; x++) {\" is covered.\n\n22. if condition : always executed. Statement \"if(parent[x] == 0) {\" is covered.\n\n23. System.out.println : always executed. Statements \"System.out.println(\"Yes\");\", \"System.out.println(parent[x]);\", and \"System.out.println(\"No\");\" are covered.\n\n24. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\na 3\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n\"a\" 3\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN: \n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" is covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader and InputStreamReader objects creation: always executed. Statement \"br = new BufferedReader(new InputStreamReader(System.in));\" is covered.\n\n4. User Input: always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n5. parent array initialization: always executed. Statement \"parent = new int [N+1];\" is covered.\n\n6. ArrayList creation and initialization: always executed. Statements \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n\n7. For loop execution: since M=3, the for loop condition (x<M) is true, and the loop block will be executed. Statement \"for (int x=1; x<M; x++) {\" is covered.\n\n8. Inside the for loop: user input statements are always executed. Statements \"int one = nextInt();\" and \"int two = nextInt();\" are covered.\n\n9. ArrayList operations: always executed. Statements \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n\n10. Function call: The function bfs will be executed. \n\n11. bfs method declaration and execution: method declaration is always executed. \"public static boolean bfs (ArrayList [] matrix,  int start) {\" is covered. The while loop will be executed at least once. Statement \"while (!queue.isEmpty()) {\" is covered. The for loop inside the while loop will be executed based on the size of matrix[cur]. Statements \"int cur = queue.poll();\" and \"int now = (int) matrix[cur].get(x);\" are covered. The if condition inside the for loop will be executed if parent[now] is equal to 0. \n\n12. return statement: always executed. \"return false;\" is covered.\n\n13. Statements after while loop in bfs method: no statements after the while loop will be executed since the while loop failed to complete execution due to an empty queue. \n\n14. return statement in main method: always executed. \"return false;\" is covered.\n\n15. Statements after for loop in main method: always executed. Statements \"if(flag){\", \"System.out.println(\"Yes\");\", \"for (int x=2; x<=N; x++) {\", \"System.out.println(parent[x]);\", \"}\", \"else{\", \"System.out.println(\"No\");\", \"}\" are covered.\n\n16. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;\n>     static PrintWriter out;\n>     static int parent[];\n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
      "test_mutations": [
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\na 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n4 3\n1 a\n2 3\n3 4",
        "Test Case Input:\n0 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4",
        "Test Case Input:\na 3\n1 2\n2 3\n3 4",
        "Test Case Input:\n-3 0\n1 2\n2 3\n3 4"
      ],
      "initial_code": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static StringTokenizer st;\n    static BufferedReader br;  \n    static PrintWriter out;\n    static int parent[]; \n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        int N = nextInt();\n        int M = nextInt();\n        parent = new int [N+1];\n        ArrayList<Integer> matrix [] = new ArrayList [M+1];\n        for (int x=1; x<=N; x++) {\n            matrix[x] = new ArrayList<Integer>();\n        }\n        for (int x=1; x<M; x++) {\n            int one = nextInt();\n            int two = nextInt();\n            matrix[one].add(two);\n            matrix[two].add(one);\n        }\n        bfs(matrix, 1);\n        boolean flag = true;\n        for (int x=1; x<=N; x++) {\n            if(parent[x] == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            System.out.println(\"Yes\");\n            for (int x=2; x<=N; x++) {\n                System.out.println(parent[x]);\n            }\n        }\n        else{\n            System.out.println(\"No\");\n        }\n    }\n    public static boolean bfs (ArrayList [] matrix,  int start) {\n        Queue <Integer> queue = new LinkedList<Integer>();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int cur = queue.poll();\n            for (int x=0; x<matrix[cur].size(); x++) {\n                int now = (int) matrix[cur].get(x);\n                if(parent[now]==0){\n                    parent[now] = cur;\n                    queue.add(now);\n                }\n            }\n        }\n        return false;\n    }\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n    static String next() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine().trim());\n        return st.nextToken();\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.*;\" and \"import java.io.*;\" will be covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) throws IOException {\" is covered.\n\n3. BufferedReader, InputStreamReader, and StringTokenizer objects initialization: always executed. Statements \"br = new BufferedReader(new InputStreamReader(System.in));\" and \"st = new StringTokenizer(br.readLine().trim());\" will be covered.\n\n4. Variable initialization: always executed. Statements \"int N = nextInt();\" and \"int M = nextInt();\" are covered.\n\n5. parent array initialization: always executed. Statement \"parent = new int [N+1];\" is covered.\n\n6. matrix ArrayList array initialization: always executed. Statement \"ArrayList<Integer> matrix [] = new ArrayList [M+1];\" is covered.\n\n7. For loop for matrix ArrayList initialization: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"matrix[x] = new ArrayList<Integer>();\" are covered.\n\n8. For loop for matrix ArrayList population: always executed. Statements \"for (int x=1; x<M; x++) {\" and \"matrix[one].add(two);\" and \"matrix[two].add(one);\" are covered.\n\n9. bfs method call: always executed. Statement \"bfs(matrix, 1);\" is covered.\n\n10. bfs method execution: statements inside while loop are executed based on the condition. Since the queue is not empty, the while loop will execute. Statement \"while (!queue.isEmpty()) {\" is covered.\n\n11. cur variable assignment: always executed. Statement \"int cur = queue.poll();\" is covered.\n\n12. For loop for matrix ArrayList traversal: always executed. Statement \"for (int x=0; x<matrix[cur].size(); x++) {\" is covered.\n\n13. now variable assignment: always executed. Statement \"int now = (int) matrix[cur].get(x);\" is covered.\n\n14. if condition inside for loop: always executed. Statements \"if(parent[now]==0) {\" and \"parent[now] = cur;\" and \"queue.add(now);\" are covered.\n\n15. return statement in bfs method: always executed. Statement \"return false;\" is covered.\n\n16. flag variable initialization: always executed. Statement \"boolean flag = true;\" is covered.\n\n17. For loop for parent array traversal: always executed. Statements \"for (int x=1; x<=N; x++) {\" and \"if(parent[x] == 0) {\" and \"flag = false;\" and \"break;\" are covered.\n\n18. if-else condition: always executed. Statements \"if(flag) {\" and \"System.out.println(\"Yes\");\" and \"for (int x=2; x<=N; x++) {\" and \"System.out.println(parent[x]);\" are covered. Statement \"else {\" and \"System.out.println(\"No\");\" are also covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.*;\n> import java.io.*;\n> public class Main {\n>     static StringTokenizer st;\n>     static BufferedReader br;  \n>     static PrintWriter out;\n>     static int parent[]; \n>     public static void main(String[] args) throws IOException {\n>         br = new BufferedReader(new InputStreamReader(System.in));\n>         int N = nextInt();\n>         int M = nextInt();\n>         parent = new int [N+1];\n>         ArrayList<Integer> matrix [] = new ArrayList [M+1];\n>         for (int x=1; x<=N; x++) {\n>             matrix[x] = new ArrayList<Integer>();\n>         }\n>         for (int x=1; x<M; x++) {\n>             int one = nextInt();\n>             int two = nextInt();\n>             matrix[one].add(two);\n>             matrix[two].add(one);\n>         }\n>         bfs(matrix, 1);\n>         boolean flag = true;\n>         for (int x=1; x<=N; x++) {\n>             if(parent[x] == 0){\n>                 flag = false;\n>                 break;\n>             }\n>         }\n>         if(flag){\n>             System.out.println(\"Yes\");\n>             for (int x=2; x<=N; x++) {\n>                 System.out.println(parent[x]);\n>             }\n>         }\n>         else{\n>             System.out.println(\"No\");\n>         }\n>     }\n>     public static boolean bfs (ArrayList [] matrix,  int start) {\n>         Queue <Integer> queue = new LinkedList<Integer>();\n>         queue.add(start);\n>         while (!queue.isEmpty()) {\n>             int cur = queue.poll();\n>             for (int x=0; x<matrix[cur].size(); x++) {\n>                 int now = (int) matrix[cur].get(x);\n>                 if(parent[now]==0){\n>                     parent[now] = cur;\n>                     queue.add(now);\n>                 }\n>             }\n>         }\n>         return false;\n>     }\n>     public static int nextInt() throws IOException {\n>         return Integer.parseInt(next());\n>     }\n>     public static long nextLong() throws IOException {\n>         return Long.parseLong(next());\n>     }\n>     public static double nextDouble() throws IOException {\n>         return Double.parseDouble(next());\n>     }\n>     static String next() throws IOException {\n>         while (st == null || !st.hasMoreTokens())\n>             st = new StringTokenizer(br.readLine().trim());\n>         return st.nextToken();\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    }
  ]
}