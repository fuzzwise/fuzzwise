{
  "submission_id": "s586173662",
  "cycles": [
    {
      "test_case": "Test Case Input:\n5\n3\n2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n5\n10\n3",
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n3\n2\n1",
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n3\n2\n1",
        "Test Case Input:\n3\n2\n1",
        "Test Case Input:\n5\n3\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main Class Declaration: always executed. Statement \"public class Main {\" is covered.\n\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. For loop Execution: Since n = 5 and k = 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" is covered.\n\n6. For loop contents: Statements inside the for loop will be executed:\n   - Statement \"ans *= m-1;\" is covered.\n   - Statement \"ans %= 998244353;\" is covered.\n\n7. Function call within main method:\n   - Statement \"ans *= combination(n, k);\" is covered.\n   - Statement \"ans %= 998244353;\" is covered.\n\n8. combination method Declaration and Execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The condition \"k == 0\" is not satisfied, so the else block will be executed. The factorial method will be called.\n\n9. factorial method Declaration and Execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. The condition \"l == 0\" is not satisfied, so the else block will be executed. The factorial method will be called recursively.\n\n10. Recursive calls to factorial method: The factorial method will be called recursively until the base case is reached (l == 0). The recursive calls will be covered.\n\n11. Calculation of factorial and division:\n    - Statement \"return l * factorial(l-1);\" is covered.\n    - Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n\n12. Final calculation and program output:\n    - Statement \"System.out.println(ans);\" is covered.\n\n13. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\ntwo",
      "test_mutations": [
        "Test Case Input:\n\"abc\"\n3\n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n\"5\" 3 2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"abc\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"abc\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\""
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered. \n3. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered. \n4. For loop Execution : Since n is 5 and k is 3, the for loop condition (i<n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered. \n5. For loop contents : Statements inside the for loop are executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\", are covered. \n6. combination method call : Statement \"ans *= combination(n, k);\" will be covered. \n7. combination Method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since the value of k is not zero, the ternary operator condition 'k == 0' is not satisfied. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered. \n8. factorial method call : Statements \"factorial(n)\", \"factorial(k)\", \"factorial(n - k)\" are covered. \n9. factorial Method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since the value of l is not zero, the ternary operator condition 'l == 0' is not satisfied. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" is covered. \n10. Statements after for loop in Main method : Statement \"ans %= 998244353;\" is covered. \n11. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n0",
        "Test Case Input:\n5\n3\ntwo",
        "Test Case Input:\n5\n3\ntwo",
        "Test Case Input:\n0\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered. \n5. For loop Execution : Since n=5 and k=3, the for loop condition (i<n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered. \n6. For loop contents : Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered. \n7. Function call within main method : The function combination will be executed. \n8. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since the value of k is not 0, the else condition of the ternary operator is executed. Statements \"return factorial(n) / (factorial(k) * factorial(n - k));\" will be covered. \n9. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since the value of l is not 0, the else condition of the ternary operator is executed. Statements \"return l * factorial(l-1);\" will be covered. \n10. Statements inside main method after for loop : Statements \"ans *= combination(n, k);\", \"ans %= 998244353;\", \"System.out.println(ans);\" will be covered. \n11. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n5\n3\n-1",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n5\n3\n-1",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop execution: The loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered.\n7. combination method call: The method combination will always be called. Statement \"ans *= combination(n, k);\" is covered.\n8. combination method declaration and execution: Method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But since k is not 0, the else condition will be executed and statement \"return factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n9. factorial method call: The method factorial will always be called. Statements \"ans *= combination(n, k);\", \"ans %= 998244353;\" are covered.\n10. factorial method declaration and execution: Method declaration is always executed. \"private static long factorial(long l) {\" is covered. But since l is not 0, the else condition will be executed and statement \"return l * factorial(l-1);\" is covered.\n11. Statements after the for loop in the main method: Statement \"ans *= combination(n, k);\" is covered.\n12. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\ntwo",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n\"5\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n\"two\"",
        "Test Case Input:\n5\n3\n\"two\""
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and tets case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n4. For loop Execution : Since n=5 and k=3, the for loop condition (i<n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" will be covered.\n5. For loop contents : Statements within the for loop will be executed for each iteration. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be executed.\n6. combination method call within main method : The combination method will be called within the main method. Statement \"ans *= combination(n, k);\" will be covered.\n7. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since k=3 is not equal to 0, factorial method will be called. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n8. factorial method call within combination method : The factorial method will be called within the combination method. Statements \"factorial(n)\", \"factorial(k)\", \"factorial(n - k)\" will be covered.\n9. factorial method declaration and execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l=2, the factorial method will be called recursively for l=1. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" is covered for l=2 and l=1.\n10. Statements after for loop in Main method : no statements after the for loop will be executed since the for loop completed execution successfully. Statement \"ans *= combination(n, k);\" and \"ans %= 998244353;\" are covered. \n11. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\" \"3\" \"2\"",
        "Test Case Input:\nfive\n3\n2",
        "Test Case Input:\nnull\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n-5\n3\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User input and program output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. For loop execution: The loop will run for n-k-1 times since the condition (i < n-k) is true. The loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" is covered.\n\n6. For loop contents: Statements \"ans *= m-1;\", \"ans %= 998244353;\" are executed inside the loop. They will be covered for each iteration of the loop.\n\n7. combination method call: The method combination will be called once inside the for loop. Statement \"ans *= combination(n, k);\" is covered.\n\n8. combination method declaration: always executed. Statement \"private static long combination(long n, long k) {\" is covered.\n\n9. factorial method call: The method factorial will be called three times: once for each factorial() call inside the combination method. Statements \"factorial(n)\", \"factorial(k)\", \"factorial(n - k)\" are covered.\n\n10. factorial method declaration: always executed. Statement \"private static long factorial(long l) {\" is covered.\n\n11. Closing brackets: always covered.\n\n12. System.out.println() statement: always executed. Statement \"System.out.println(ans);\" is covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n\"5\" \n3 \n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n\"5\" \n\"3\"\n\"-2\"",
        "Test Case Input:\n-5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: Always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: Always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User input and program output: Always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop execution: The loop will iterate n-k-1 times. If n-k >= 1, the loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" is covered.\n6. For loop contents: The statements inside the loop will be executed n-k-1 times. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered.\n7. Combination method call: The combination method is always called. Statement \"ans *= combination(n, k);\" is covered.\n8. Combination method declaration and execution: The method declaration is always executed. Statement \"private static long combination(long n, long k) {\" is covered. The method execution depends on the value of k. If k is equal to 0, the return statement will be executed. Otherwise, the factorial method will be called.\n9. Factorial method call: The factorial method is always called. Statement \"factorial(n)\" and \"factorial(n - k)\" are covered.\n10. Factorial method declaration and execution: The method declaration is always executed. Statement \"private static long factorial(long l) {\" is covered. The method execution depends on the value of l. If l is equal to 0, the return statement will be executed. Otherwise, the factorial method will be called recursively.\n11. Closing brackets: Always covered.\n\nFinal code coverage of the Java program based on its test case and given step-by-step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\na\n3\n2",
      "test_mutations": [
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\ntwo",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\na\n3\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. For loop execution: Since n = 3 and k = 2, the for loop condition (i < n - k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" is covered.\n\n6. For loop contents: Statements inside the for loop are always executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be executed.\n\n7. combination method call: Statement \"ans *= combination(n, k);\" will be executed.\n\n8. combination method declaration and execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The method will return a value based on the condition. If k == 0, the condition will be true and the statement \"return 1;\" will be covered. Otherwise, the statement \"return factorial(n) / (factorial(k) * factorial(n - k));\" will be covered.\n\n9. factorial method call: The factorial method will be called twice in the combination method. Statements \"factorial(n)\" and \"factorial(k)\" will be executed.\n\n10. factorial method declaration and execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. The method will return a value based on the condition. If l == 0, the condition will be true and the statement \"return 1;\" will be covered. Otherwise, the statement \"return l * factorial(l-1);\" will be covered.\n\n11. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n-5\n3\ntwo",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"  \n\"3\"  \n\"two\"",
        "Test Case Input:\n\"5\" (string)\n\"3\" (string)\n\"2\" (string)",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered. \n4. Initialization of ans variable : always executed. Statement \"long ans = m;\" is covered.\n5. For loop Execution : Since n = 5 and k = 3, the for loop condition (i<n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" is covered.\n6. For loop contents : Statements inside the for loop are executed for each iteration. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered. \n7. Function call within main method : The function combination will be executed. \n8. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The condition \"k == 0\" is not satisfied, so the else part will be executed. Statements \"return factorial(n) / (factorial(k) * factorial(n - k));\" and \"return l * factorial(l-1);\" are covered. \n9. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. The condition \"l == 0\" is not satisfied, so the else part will be executed. Statement \"return l * factorial(l-1);\" is covered.\n10. Statements after for loop in Main method : Statements \"ans *= combination(n, k);\", \"ans %= 998244353;\" and \"System.out.println(ans);\" are covered.\n11. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n2\n3\n-1",
        "Test Case Input:\n5\n3\ntwo",
        "Test Case Input:\n\"5\" \n3 \n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n3. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n4. For loop Execution : Since n = 5 and k = 3, the for loop condition (i < n - k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n5. For loop contents : Statements inside the for loop block will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered.\n6. combination method call : Since k = 3, the condition (k == 0) is false, and the factorial method will be called. Statement \"ans *= combination(n, k);\" will be covered.\n7. factorial method call : The factorial method will be called recursively until the base case (l == 0) is reached. Statements \"return l == 0 ? 1 : l * factorial(l-1);\" and \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" will be covered.\n8. Statements after for loop in Main method : Statement \"ans *= combination(n, k);\" will be covered.\n9. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\ntwo",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n1\n2\n3",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n3\n0\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\""
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main Class Declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop Execution: Since n = 5 and k = 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered.\n7. combination method call: The method combination will be executed. Statement \"ans *= combination(n, k);\" will be covered.\n8. combination Method Declaration and Execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since the value of k is not zero, the factorial method will be called.\n9. factorial Method Declaration and Execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since the value of l is not zero, the factorial method will be called recursively.\n10. factorial Method Recursive Calls: The factorial method will be called recursively until the base case is reached. The recursive calls to factorial method will be covered.\n11. factorial Method Base Case: The base case of the factorial method (l == 0) will be executed. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" is covered.\n12. factorial Method Return: The factorial method will return the factorial value. The return statement \"return l == 0 ? 1 : l * factorial(l-1);\" is covered.\n13. combination Method Return: The combination method will return the combination value. The return statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n14. For loop Iteration: The for loop will iterate until the condition (i < n-k) becomes false. The for loop iteration statements will be covered.\n15. Statements after for loop in Main method: no statements after the for loop will be executed since the for loop completed its execution. Statement \"ans *= combination(n, k);\" is covered.\n16. Program Output: Statement \"System.out.println(ans);\" is covered.\n17. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"five\"\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop Execution: Since n=5, k=3, and the condition (i<n-k) is true, the for loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed for each iteration. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered.\n7. combination method call and execution: The combination method will be called and executed within the for loop. Statement \"ans *= combination(n, k);\" is covered.\n8. combination method Declaration and Execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The factorial method will be called and executed within the combination method. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n9. factorial method Declaration and Execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. The factorial method will be recursively called and executed. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" is covered.\n10. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n\"five\"\n3\n2",
        "Test Case Input:\n\"5\" \n\"3\" \n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n10\n0\n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n2. Main class declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method declaration and user input : always executed. Statements \"public static void main(String[] args) {\" and \"Scanner sc = new Scanner(System.in);\" are covered. \n4. Variable declarations and user input : always executed. Statements \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered. \n5. Calculation of 'ans' variable : The for loop will execute n-k-1 times. For each iteration, the statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered. \n6. Function call - combination method : The function combination will execute only if the value of k is not 0. \n7. combination method declaration and execution : method declaration is always executed. Statement \"private static long combination(long n, long k) {\" is covered. But, since the value of k is 0, the condition 'k == 0' is true and the return statement \"return 1;\" is covered. \n8. Function call - factorial method : The function factorial will execute twice. \n9. factorial method declaration and execution : method declaration is always executed. Statement \"private static long factorial(long l) {\" is covered. But, since the value of l is 0, the condition 'l == 0' is true and the return statement \"return 1;\" is covered. \n10. Calculation of 'ans' variable (continued) : After the for loop, the statement \"ans *= combination(n, k);\" will be covered. \n11. Calculation of 'ans' variable (continued) : The statement \"ans %= 998244353;\" will be covered. \n12. Program output : The statement \"System.out.println(ans);\" will be covered. \n13. Closing brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n3\n0\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"five\"\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n3\n5\n\"two\"",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. For loop execution: Since n is 5 and k is 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" will be covered.\n\n6. For loop contents: Statements within the for loop will be executed multiple times based on the value of n-k.\n\n7. ans *= m-1: This statement is executed within the for loop block. Statement \"ans *= m-1;\" will be covered.\n\n8. ans %= 998244353: This statement is executed within the for loop block. Statement \"ans %= 998244353;\" will be covered.\n\n9. Combination method call: This statement is executed within the for loop block. Statement \"ans *= combination(n, k);\" will be covered.\n\n10. combination method declaration and execution: Method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The method will be executed if the condition \"k == 0\" is true.\n\n11. factorial method call: This statement is executed within the combination method. Statement \"factorial(n)\" and \"factorial(k)\" will be covered.\n\n12. factorial method declaration and execution: Method declaration is always executed. \"private static long factorial(long l) {\" is covered. The method will be executed if the condition \"l == 0\" is true.\n\n13. Statements after the for loop in the main method: The statement \"ans *= combination(n, k);\" is executed after the for loop. Statement \"ans *= combination(n, k);\" will be covered.\n\n14. ans %= 998244353: This statement is executed after the for loop. Statement \"ans %= 998244353;\" will be covered.\n\n15. System.out.println(ans): This statement is executed after the for loop. Statement \"System.out.println(ans);\" will be covered.\n\n16. Closing brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\ntwo",
      "test_mutations": [
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n\"five\"\n3\n2",
        "Test Case Input:\n\"a\"\n3\n2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n1\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\""
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given Java program and test case:\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop execution: Since n = 5 and k = 3, the for loop condition (i < n - k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered.\n7. combination method call: The method combination will be called with the values of n and k. Statement \"ans *= combination(n, k);\" will be covered.\n8. combination method declaration and execution: Method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The method execution will depend on the condition k == 0. Since k is not 0, the else condition will be executed. Statement \"return factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n9. factorial method call: The method factorial will be called with the value of n. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is covered.\n10. factorial method declaration and execution: Method declaration is always executed. \"private static long factorial(long l) {\" is covered. The method execution will depend on the condition l == 0. Since l is not 0, the else condition will be executed. Statement \"return l * factorial(l-1);\" is covered.\n11. factorial method call: The method factorial will be called recursively with a decreasing value of l. Statement \"return l * factorial(l-1);\" is covered multiple times until l becomes 0.\n12. factorial method execution: When l becomes 0, the condition l == 0 becomes true and the base case is reached. Statement \"return 1;\" is covered.\n13. combination method execution: The value returned by the combination method is multiplied with ans. Statement \"ans *= combination(n, k);\" is covered.\n14. ans %= 998244353: The value of ans is updated. Statement \"ans %= 998244353;\" is covered.\n15. System.out.println(ans): The final value of ans is printed. Statement \"System.out.println(ans);\" is covered.\n16. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n0\n2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n1\n2\n3",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n0\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output : always executed. Statements \"Scanner scanner = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. Calculation of ans in a for loop : Since n = 5 and k = 0, the for loop condition (i < n-k) is true, and the loop block will be executed. \n\n6. Calculation of ans in the for loop : Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be executed.\n\n7. Calculation of ans outside the for loop : Statement \"ans *= combination(n, k);\" will be executed.\n\n8. Calculation of combination : Statement \"ans *= combination(n, k);\" will be executed.\n\n9. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. \n\n10. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered.\n\n11. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\ntwo",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main class declaration : always executed. Statement \"public class Main {\" is covered.\n\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n4. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n5. For loop Execution : Since n = 5 and k = 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n\n6. For loop contents : The statements within the for loop block will be executed.\n\n7. ans *= m-1; : The statement \"ans *= m-1;\" is executed within the for loop block.\n\n8. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n9. combination method call : The method combination(n, k) will be executed within the for loop block.\n\n10. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since k = 3 and n = 5, the condition \"k == 0\" is not satisfied and the factorial method will be called.\n\n11. factorial method call : The method factorial(l) will be executed within the combination method.\n\n12. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 5, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n13. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n14. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 4, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n15. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n16. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 3, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n17. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n18. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 2, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n19. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n20. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 1, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n21. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n22. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 0, the condition \"l == 0\" is satisfied and the factorial method will return 1.\n\n23. factorial method call return : The factorial method call will return the value 1.\n\n24. factorial method call return : The factorial method call will return the value 1.\n\n25. factorial method call return : The factorial method call will return the value 2.\n\n26. factorial method call return : The factorial method call will return the value 6.\n\n27. combination method call return : The combination method call will return the value 10.\n\n28. ans *= combination(n, k); : The statement \"ans *= combination(n, k);\" is executed within the for loop block.\n\n29. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n30. For loop iteration : The for loop will iterate again with i = 2.\n\n31. ans *= m-1; : The statement \"ans *= m-1;\" is executed within the for loop block.\n\n32. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n33. combination method call : The method combination(n, k) will be executed within the for loop block.\n\n34. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since k = 3 and n = 5, the condition \"k == 0\" is not satisfied and the factorial method will be called.\n\n35. factorial method call : The method factorial(l) will be executed within the combination method.\n\n36. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 5, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n37. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n38. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 4, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n39. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n40. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 3, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n41. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n42. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 2, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n43. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n44. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 1, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n45. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n46. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 0, the condition \"l == 0\" is satisfied and the factorial method will return 1.\n\n47. factorial method call return : The factorial method call will return the value 1.\n\n48. factorial method call return : The factorial method call will return the value 1.\n\n49. factorial method call return : The factorial method call will return the value 2.\n\n50. factorial method call return : The factorial method call will return the value 6.\n\n51. combination method call return : The combination method call will return the value 10.\n\n52. ans *= combination(n, k); : The statement \"ans *= combination(n, k);\" is executed within the for loop block.\n\n53. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n54. For loop iteration : The for loop will iterate again with i = 3.\n\n55. ans *= m-1; : The statement \"ans *= m-1;\" is executed within the for loop block.\n\n56. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n57. combination method call : The method combination(n, k) will be executed within the for loop block.\n\n58. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since k = 3 and n = 5, the condition \"k == 0\" is not satisfied and the factorial method will be called.\n\n59. factorial method call : The method factorial(l) will be executed within the combination method.\n\n60. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 5, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n61. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n62. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 4, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n63. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n64. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 3, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n65. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n66. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 2, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n67. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n68. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 1, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n69. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n70. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 0, the condition \"l == 0\" is satisfied and the factorial method will return 1.\n\n71. factorial method call return : The factorial method call will return the value 1.\n\n72. factorial method call return : The factorial method call will return the value 1.\n\n73. factorial method call return : The factorial method call will return the value 2.\n\n74. factorial method call return : The factorial method call will return the value 6.\n\n75. combination method call return : The combination method call will return the value 10.\n\n76. ans *= combination(n, k); : The statement \"ans *= combination(n, k);\" is executed within the for loop block.\n\n77. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n78. For loop iteration : The for loop will iterate again with i = 4.\n\n79. ans *= m-1; : The statement \"ans *= m-1;\" is executed within the for loop block.\n\n80. ans %= 998244353; : The statement \"ans %= 998244353;\" is executed within the for loop block.\n\n81. combination method call : The method combination(n, k) will be executed within the for loop block.\n\n82. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since k = 3 and n = 5, the condition \"k == 0\" is not satisfied and the factorial method will be called.\n\n83. factorial method call : The method factorial(l) will be executed within the combination method.\n\n84. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since l = 5, the condition \"l == 0\" is not satisfied and the factorial method will be called recursively.\n\n85. factorial method call (recursion) : The method factorial(l-1) will be executed within the factorial method.\n\n86. factorial method Declaration and Execution (recursion) : method declaration is always executed. \"private static long factorial(long l) {\"",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\ntwo",
        "Test Case Input:\n-5\n3\ntwo",
        "Test Case Input:\n\"a\"\n3\n2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n3\n2\n\"two\"",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop Execution : Since n is 5 and k is 3, the loop condition (i<n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" will be covered.\n6. For loop contents : the statements inside the for loop will be executed 2 times. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered twice.\n7. combination method call : the combination method will be called once. Statement \"ans *= combination(n, k);\" will be covered.\n8. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered.\n9. factorial method call : the factorial method will be called three times. Statements \"factorial(n)\", \"factorial(k)\", \"factorial(n - k)\" will be covered three times.\n10. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered.\n11. Closing Brackets : always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n3\n5\ntwo",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"2\"",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n3\n2\n\"three\"",
        "Test Case Input:\n3\n5\n\"two\""
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main Class Declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop Execution: Since n = 3 and k = 1, the for loop condition (i < n - k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++){\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered.\n7. combination method call: The combination method will be executed. Statement \"ans *= combination(n, k);\" is covered.\n8. combination method Declaration: method declaration is always executed. \"private static long combination(long n, long k){\" is covered.\n9. factorial method call: The factorial method will be executed. Statements \"factorial(n)\", \"factorial(k)\", \"factorial(n - k)\" are covered.\n10. factorial method Declaration: method declaration is always executed. \"private static long factorial(long l){\" is covered.\n11. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\ntwo",
      "test_mutations": [
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n\"a\"\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\ntwo",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\ntwo"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop Execution : Since n = 5 and k = 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents : always executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be executed.\n7. combination method call and execution : combination method will be executed only if k is not equal to 0. The value of k is not 0 in this case, so statement \"ans *= combination(n, k);\" will be covered.\n8. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. The factorial method will be called within the combination method.\n9. factorial method call and execution : factorial method will be executed only if l is not equal to 0. The value of l is not 0 in this case, so statement \"return l * factorial(l-1);\" will be covered.\n10. factorial method Declaration and Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. The factorial method will be called recursively until l becomes 0.\n11. Closing Brackets : always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is :\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k) {\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l) {\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n3\n-2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n2\n3\n\"two\"",
        "Test Case Input:\n0\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop execution: Since n = 5 and k = 3, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop will be executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be covered.\n7. Function call within main method: The function combination will be executed.\n8. combination method Declaration and Execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since the value of k is not 0, the else condition is executed. Statements \"return factorial(n) / (factorial(k) * factorial(n - k));\" will be covered.\n9. factorial method Declaration and Execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. Since l is not 0, the else condition is executed. Statements \"return l * factorial(l-1);\" will be covered.\n10. Statements after for loop in Main method: Statement \"ans *= combination(n, k);\" will be covered.\n11. Closing Brackets: always covered.\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\na\n3\n2",
      "test_mutations": [
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\na\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n3\n2\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n-3\n2",
        "Test Case Input:\na\n3\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n2. Main class declaration: always executed. Statement \"public class Main {\" is covered.\n3. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n5. For loop execution: Since n = 3 and k = 2, the for loop condition (i < n - k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered.\n6. For loop contents: Statements inside the for loop are executed. Statements \"ans *= m-1;\", \"ans %= 998244353;\" are covered.\n7. Combination method call: Statement \"ans *= combination(n, k);\" is executed. The combination method will be called.\n8. Combination method declaration and execution: Method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. Since k = 2, the condition (k == 0) is false. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" will be covered. The factorial method will be called.\n9. Factorial method declaration and execution: Method declaration is always executed. \"private static long factorial(long l) {\" is covered. Since l = 3, the condition (l == 0) is false. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" will be covered.\n10. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n5\n0\n2",
      "test_mutations": [
        "Test Case Input:\n\"5\"\n\"3\"\n\"two\"",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input: \n\n1\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\nabc\n3\n2",
        "Test Case Input:\n2\n3\n\"two\"",
        "Test Case Input:\n3\n2\n-2",
        "Test Case Input:\n5\n0\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n1. Import statements : Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered. \n2. Main Class Declaration : always executed. Statement \"public class Main {\" is covered. \n3. Main method decalarion : always executed. Statement \"public static void main(String[] args) {\" is covered.\n4. User Input and Program Output : always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered. \n5. For loop Execution : Since n = 5 and k = 0, the for loop condition (i < n-k) is true, and the loop block will be executed. Statement \"for (int i=1;i<n-k;i++) {\" will be covered. \n6. For loop contents : loop contents will be executed 4 times. Statements \"ans *= m-1;\", \"ans %= 998244353;\" will be executed. \n7. Function call : combination method will be executed. Statement \"ans *= combination(n, k);\" will be covered. \n8. combination method Declaration and Execution : method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. \n9. factorial method Execution : method declaration is always executed. \"private static long factorial(long l) {\" is covered. \n10. Statements after for loop in Main method : no statements after the for loop will be executed since the for loop completed its execution. Statement \"ans %= 998244353;\" will be covered. \n11. Closing Brackets : always covered. \n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is : \n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n>             ans *= m-1;\n>             ans %= 998244353;\n>         }\n>         ans *= combination(n, k);\n>         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n>         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n>         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    },
    {
      "test_case": "Test Case Input:\n-5\n3\n2",
      "test_mutations": [
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n-5\n3\n-2",
        "Test Case Input:\n5\n3\n-2",
        "Test Case Input:\n5\n0\n2",
        "Test Case Input:\n-5\n3\n2"
      ],
      "initial_code": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n        long ans = m;\n        for (int i=1;i<n-k;i++){\n            ans *= m-1;\n            ans %= 998244353;\n        }\n        ans *= combination(n, k);\n        ans %= 998244353;\n        System.out.println(ans);\n    }\n    private static long combination(long n, long k){\n        return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n    }\n    private static long factorial(long l){\n        return l == 0 ? 1 : l * factorial(l-1);\n    }\n}",
      "covered_code": "PLAN for step by step execution of the given java program and test case:\n\n1. Import statements: Import statements are always executed. Statement \"import java.util.Scanner;\" will be covered.\n\n2. Main method declaration: always executed. Statement \"public static void main(String[] args) {\" is covered.\n\n3. User Input and Program Output: always executed. Statements \"Scanner sc = new Scanner(System.in);\", \"int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\" are covered.\n\n4. Initialization of ans variable: always executed. Statement \"long ans = m;\" is covered.\n\n5. For loop Execution: Since n = -5, the for loop condition (i < n - k) is false, and the loop block will not be executed. Statement \"for (int i=1;i<n-k;i++) {\" is not covered.\n\n6. combination method call: Since the for loop is not executed, the combination method will not be called. Statement \"ans *= combination(n, k);\" is not covered.\n\n7. Print statement: always executed. Statement \"System.out.println(ans);\" is covered.\n\n8. combination method Declaration and Execution: method declaration is always executed. \"private static long combination(long n, long k) {\" is covered. But, since the value of k is not equal to 0, the else condition is satisfied and the factorial method will be called. Statement \"return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\" is not covered.\n\n9. factorial method Declaration and Execution: method declaration is always executed. \"private static long factorial(long l) {\" is covered. But, since the value of l is not equal to 0, the else condition is satisfied and the factorial method will be called recursively. Statement \"return l == 0 ? 1 : l * factorial(l-1);\" is not covered.\n\n10. Closing Brackets: always covered.\n\nFinal code coverage of the Java program based on its test case and given step by step reasoning for execution is:\n> import java.util.Scanner;\n> public class Main {\n>     public static void main(String[] args) {\n>         Scanner sc = new Scanner(System.in);\n>         int n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n>         long ans = m;\n>         for (int i=1;i<n-k;i++){\n!             ans *= m-1;\n!             ans %= 998244353;\n>         }\n!         ans *= combination(n, k);\n!         ans %= 998244353;\n>         System.out.println(ans);\n>     }\n>     private static long combination(long n, long k){\n!         return k == 0 ? 1 : factorial(n) / (factorial(k) * factorial(n - k));\n>     }\n>     private static long factorial(long l){\n!         return l == 0 ? 1 : l * factorial(l-1);\n>     }\n> }",
      "test_seed_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ],
      "cumulative_coverage": [
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">",
        ">"
      ]
    }
  ]
}